<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <script data-ad-client="ca-pub-1566816837076058" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    <title>
        【面试】最容易被问到的N种排序算法！ |
        
        程序员小明
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"mynamecoder.com","root":"/"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true},"style":{"primary_color":"#0066cc","avatar":"/images/avatar.png","favicon":"/images/logo.svg","img_position":"left","left_side_width":"260px","content_max_width":"900px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"冰冻三尺 非一日之寒"}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":false},"version":"3.0.4"};
    KEEP.language = {"search":"搜索...","prev":"上一页","next":"下一页","prev_posts":"上一篇","next_posts":"下一篇","page":"第 %d 页","recent_posts":"最新文章","share":"分享","powered_by":"由 %s 驱动","theme":"主题","rss_feed":"RSS Feed","category":"分类","categories":"分类","tag":"标签","tags":"标签","tagcloud":"标签云","comment":"评论","home":"首页","archive":"归档","archives":"归档","about":"关于","site_uv":"访问人数","site_pv":"总访问量","links":"友链","link":"友链","top":"顶置","read_more":"阅读全文","wordcount":"字","min2read":"分钟","changelog":"更新日志","copyright":{"title":"本文标题","author":"本文作者","link":"本文链接","create_time":"创建时间","license_title":"版权声明","license_content":"本博客所有文章除特别声明外，均采用 %s 许可协议。转载请注明出处！"},"ago":{"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"}};
  </script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="page-container">

    

    <header class="page-header">
        <div class="header-progress"></div>
    </header>

    <main class="page-main">

        <div class="page-main-content">

            <div class="page-main-content-top">
                <header class="header-wrapper">

    <div class="header-content">
        <a class="logo-title" href="/">
            程序员小明
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        首页
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        归档
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/categories"
                    >
                        分类
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/tags"
                    >
                        标签
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/about"
                    >
                        关于
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


            </div>

            <div class="page-main-content-middle">

                <main class="main-content normal-code-theme">

                    
                        <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">【面试】最容易被问到的N种排序算法！</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span>小明</span>
                        <span class="level">Lv7</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-calendar"></i> 2019-06-20 20:34:14
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/">日常开发</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    </li>
                
                    <li>
                        | <a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <blockquote>
<p>面试官：小明，是吧？你都知道哪些排序算法，哪几种是稳定排序？<br>小明：这个我有总结！</p>
</blockquote>
<h1 id="关于排序稳定性的定义"><a href="#关于排序稳定性的定义" class="headerlink" title="关于排序稳定性的定义"></a>关于排序稳定性的定义</h1><p>通俗地讲就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<h1 id="现实生活中稳定排序如何表现呢？"><a href="#现实生活中稳定排序如何表现呢？" class="headerlink" title="现实生活中稳定排序如何表现呢？"></a>现实生活中稳定排序如何表现呢？</h1><blockquote>
<p>举个例子：<br>某次学校发奖学金，只有排在前三个的有奖，结果一排序把原来在第三位的并列第三名给弄到第四位了，他估计不会乐意😂</p>
</blockquote>
<p>接下来给大家用java代码演绎一下常见的几种排序，前提：有一个数组arr，要求从小到大排序。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>简单选择排序的思想是：从第一个位置开始，逐渐向后，选择后面的无序序列中的最小值放到该位置。很简单，直接上代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;选择排序</span><br><span class="line">for(int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;&#x2F;&#x2F; 做第i趟排序</span><br><span class="line">    int k &#x3D; i;</span><br><span class="line">    for(int j &#x3D; k + 1; j &lt; arr.length; j++)&#123;&#x2F;&#x2F; 选最小的记录</span><br><span class="line">        if(arr[j] &lt; arr[k])&#123; </span><br><span class="line">            k &#x3D; j; &#x2F;&#x2F;记下目前找到的最小值所在的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span><br><span class="line">    if(i !&#x3D; k)&#123;  &#x2F;&#x2F;交换a[i]和a[k]</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[k];</span><br><span class="line">        arr[k] &#x3D; temp;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那选择排序是稳定排序吗？"><a href="#那选择排序是稳定排序吗？" class="headerlink" title="那选择排序是稳定排序吗？"></a>那选择排序是稳定排序吗？</h2><blockquote>
<p>举个例子，假如有序列[5,8,5,2,9]按从小到大排序，第一遍排序,第一个元素“5”会和第四个元素“2”交换，那么原序列中两个“5”的相对前后顺序此时就遭到破坏了，由此可见，选择排序不是一个稳定的排序算法。</p>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序就是相邻的两个元素之间按照要求进行比较交换，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 冒泡排序</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; &#x2F;&#x2F;外层循环n-1</span><br><span class="line">    for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123; &#x2F;&#x2F;内层循环n-i-1</span><br><span class="line">        if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F;从第一个开始，往后两两比较大小，如果前面的比后面的大，交换位置</span><br><span class="line">            int tmp &#x3D; arr[j];</span><br><span class="line">            arr[j] &#x3D; arr[j + 1];</span><br><span class="line">            arr[j + 1] &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那冒泡排序是稳定排序吗？"><a href="#那冒泡排序是稳定排序吗？" class="headerlink" title="那冒泡排序是稳定排序吗？"></a>那冒泡排序是稳定排序吗？</h2><p>因为发生在相邻的元素之间，所以，如果两个元素相等，我们是不会多此一举把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定</strong>排序算法。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 插入排序</span><br><span class="line">for (int index &#x3D; 1; index &lt; length; index++) &#123; &#x2F;&#x2F;外层向右的index，即作为比较对象的数据的index</span><br><span class="line">    int temp &#x3D; arr[index]; &#x2F;&#x2F;用作比较的数据</span><br><span class="line">    int leftindex &#x3D; index - 1;</span><br><span class="line">    while (leftindex &gt;&#x3D; 0 &amp;&amp; arr[leftindex] &gt; temp) &#123; &#x2F;&#x2F;当比到最左边或者遇到比temp小的数据时，结束循环</span><br><span class="line">        arr[leftindex + 1] &#x3D; arr[leftindex];</span><br><span class="line">        leftindex--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[leftindex + 1] &#x3D; temp;&#x2F;&#x2F;把temp放到空位上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，左边会产生一个只有一个元素的有序序列，比较是从该有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。</p>
<h2 id="那插入排序是稳定排序吗？"><a href="#那插入排序是稳定排序吗？" class="headerlink" title="那插入排序是稳定排序吗？"></a>那插入排序是稳定排序吗？</h2><p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序有两个方向，左边的i下标一直往右走，当<code>a[i] &lt;= a[center_index]</code>，其中<code>center_index</code>是中枢元素的数组下标，一般取为数组<strong>第0个元素</strong>。而右边的j下标一直往左走，当<code>a[j] &gt; a[center_index]</code>。如果i和j都走不动了，<code>i &lt;= j</code>，交换<code>a[i]</code>和<code>a[j]</code>,重复上面的过程，直到<code>i &gt; j</code>。 交换<code>a[j]</code>和<code>a[center_index]</code>，完成一趟快速排序。在中枢元素和<code>a[j]</code>交换的时候，很有可能把前面的元素的稳定性打乱，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 快速排序</span><br><span class="line">public static void sort(int[] a, int low, int height) &#123;</span><br><span class="line">        int i &#x3D; low;</span><br><span class="line">        int j &#x3D; height;</span><br><span class="line">        if (i &gt; j) &#123;    &#x2F;&#x2F;放在k之前，防止下标越界</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int k &#x3D; a[i];</span><br><span class="line">        while (i &lt; j) &#123;   </span><br><span class="line">            while (i &lt; j &amp;&amp; a[j] &gt; k) &#123;    &#x2F;&#x2F;找出小的数</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i &lt; j &amp;&amp; a[i] &lt;&#x3D; k) &#123;  &#x2F;&#x2F;找出大的数</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;   &#x2F;&#x2F;交换</span><br><span class="line">                int swap &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; a[j];</span><br><span class="line">                a[j] &#x3D; swap;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;交换K</span><br><span class="line">        k &#x3D; a[i];</span><br><span class="line">        a[i] &#x3D; a[low];</span><br><span class="line">        a[low] &#x3D; k;</span><br><span class="line">        &#x2F;&#x2F;对左边进行排序,递归算法</span><br><span class="line">        sort(a, low, i - 1);</span><br><span class="line">        &#x2F;&#x2F;对右边进行排序</span><br><span class="line">        sort(a, i + 1, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那快速排序是稳定排序吗？"><a href="#那快速排序是稳定排序吗？" class="headerlink" title="那快速排序是稳定排序吗？"></a>那快速排序是稳定排序吗？</h2><blockquote>
<p>比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第五个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
</blockquote>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 归并排序</span><br><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr &#x3D; &#123;11,44,23,67,88,65,34,48,9,12&#125;;</span><br><span class="line">		int[] tmp &#x3D; new int[arr.length];    &#x2F;&#x2F;新建一个临时数组存放</span><br><span class="line">		mergeSort(arr,0,arr.length-1,tmp);</span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void merge(int[] arr,int low,int mid,int high,int[] tmp)&#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		int j &#x3D; low,k &#x3D; mid+1;  &#x2F;&#x2F;左边序列和右边序列起始索引</span><br><span class="line">		while(j &lt;&#x3D; mid &amp;&amp; k &lt;&#x3D; high)&#123;</span><br><span class="line">			if(arr[j] &lt; arr[k])&#123;</span><br><span class="line">				tmp[i++] &#x3D; arr[j++];</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				tmp[i++] &#x3D; arr[k++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;若左边序列还有剩余，则将其全部拷贝进tmp[]中</span><br><span class="line">		while(j &lt;&#x3D; mid)&#123;    </span><br><span class="line">			tmp[i++] &#x3D; arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		while(k &lt;&#x3D; high)&#123;</span><br><span class="line">			tmp[i++] &#x3D; arr[k++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int t&#x3D;0;t&lt;i;t++)&#123;</span><br><span class="line">			arr[low+t] &#x3D; tmp[t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public static void mergeSort(int[] arr,int low,int high,int[] tmp)&#123;</span><br><span class="line">		if(low&lt;high)&#123;</span><br><span class="line">			int mid &#x3D; (low+high)&#x2F;2;</span><br><span class="line">			mergeSort(arr,low,mid,tmp); &#x2F;&#x2F;对左边序列进行归并排序</span><br><span class="line">			mergeSort(arr,mid+1,high,tmp);  &#x2F;&#x2F;对右边序列进行归并排序</span><br><span class="line">			merge(arr,low,mid,high,tmp);    &#x2F;&#x2F;合并两个有序序列</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那归并排序是稳定排序吗？"><a href="#那归并排序是稳定排序吗？" class="headerlink" title="那归并排序是稳定排序吗？"></a>那归并排序是稳定排序吗？</h2><p>可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是<strong>稳定</strong>的排序算法。</p>
<h1 id="基数排序（又称桶子法）"><a href="#基数排序（又称桶子法）" class="headerlink" title="基数排序（又称桶子法）"></a>基数排序（又称桶子法）</h1><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p>
<p><img src="https://s2.ax1x.com/2019/06/21/Vxw1G4.gif" alt="桶子法动画"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基数排序（又称桶子法）</span><br><span class="line">public static void myRadixSort(int[] arr) &#123;</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;        找到最大的数</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; max) &#123;</span><br><span class="line">            max &#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;        获取最大数的位数</span><br><span class="line">    int times &#x3D; 0;</span><br><span class="line">    while (max &gt; 0) &#123;</span><br><span class="line">        max &#x3D; max &#x2F; 10;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;        创建一个二维的list</span><br><span class="line">    List&lt;ArrayList&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;  创建10个list（每一位有从0到9，一共10个数，每个list数组用来存放每次迭代中，0-9 每个数组中需要装入的数）</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        ArrayList list1 &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F;在二维数组中把这10个数组加进去，相当于二维数组的行，从0-9的行</span><br><span class="line">        list.add(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;        进行times次分配和收集</span><br><span class="line">    for (int i &#x3D; 0; i &lt; times; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            分配</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            int x &#x3D; arr[j] % (int) Math.pow(10, i + 1) &#x2F; (int) Math.pow(10, i);</span><br><span class="line">            &#x2F;&#x2F; list.get(x) 是在返回第0的这个行的list上面的数，然后再 add(arr[j]) 是把当前的这个数添加到末尾去</span><br><span class="line">            list.get(x).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;            收集        ------------&gt;   把这0-9共10个list里面的数值存到一个数组里面</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">            while (list.get(j).size() &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 把list这个二维list中的第j行返回并赋值给list2</span><br><span class="line">                ArrayList&lt;Integer&gt; list2 &#x3D; list.get(j);</span><br><span class="line">                &#x2F;&#x2F;  把list2这个数组中的第0个位置的元素，赋值给arr[count]         </span><br><span class="line">                arr[count] &#x3D; list2.get(0);</span><br><span class="line">                &#x2F;&#x2F;   把list2这个数组中的第0个位置的元素删除掉，则后面的元素会自动移上来                      </span><br><span class="line">                list2.remove(0);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那基数排序是稳定排序吗？"><a href="#那基数排序是稳定排序吗？" class="headerlink" title="那基数排序是稳定排序吗？"></a>那基数排序是稳定排序吗？</h2><p>由上可得，基数排序基于分别排序，分别收集，所以其是稳定的<strong>排序算法</strong>。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序是按照不同步长对元素进行<strong>插入排序</strong>，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高，所以，希尔排序的时间复杂度会比O(n^2)好一些。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 希尔排序</span><br><span class="line">int incrementNum &#x3D; arr.length &#x2F; 2;</span><br><span class="line">while (incrementNum &gt;&#x3D; 1) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;进行插入排序</span><br><span class="line">        for (int j &#x3D; i; j &lt; arr.length - incrementNum; j &#x3D; j + incrementNum) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + incrementNum]) &#123;</span><br><span class="line">                int temple &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; arr[j + incrementNum];</span><br><span class="line">                arr[j + incrementNum] &#x3D; temple;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置新的增量</span><br><span class="line">    incrementNum &#x3D; incrementNum &#x2F; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="那希尔排序是稳定排序吗？"><a href="#那希尔排序是稳定排序吗？" class="headerlink" title="那希尔排序是稳定排序吗？"></a>那希尔排序是稳定排序吗？</h2><p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html" >堆排序<i class="fas fa-external-link-alt"></i></a>的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了,代码举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 堆排序</span><br><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.构建大顶堆</span><br><span class="line">    for (int i &#x3D; arr.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F;从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">    for (int j &#x3D; arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">        swap(arr, 0, j);&#x2F;&#x2F;将堆顶元素与末尾元素进行交换</span><br><span class="line">        adjustHeap(arr, 0, j);&#x2F;&#x2F;重新对堆进行调整</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="line">*</span><br><span class="line">* @param arr</span><br><span class="line">* @param i</span><br><span class="line">* @param length</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void adjustHeap(int[] arr, int i, int length) &#123;</span><br><span class="line">    int temp &#x3D; arr[i];&#x2F;&#x2F;先取出当前元素i</span><br><span class="line">    for (int k &#x3D; i * 2 + 1; k &lt; length; k &#x3D; k * 2 + 1) &#123;&#x2F;&#x2F;从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">        if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;&#x2F;&#x2F;如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr[k] &gt; temp) &#123;&#x2F;&#x2F;如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">            arr[i] &#x3D; arr[k];</span><br><span class="line">            i &#x3D; k;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] &#x3D; temp;&#x2F;&#x2F;将temp值放到最终的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 交换元素</span><br><span class="line">*</span><br><span class="line">* @param arr</span><br><span class="line">* @param a</span><br><span class="line">* @param b</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void swap(int[] arr, int a, int b) &#123;</span><br><span class="line">    int temp &#x3D; arr[a];</span><br><span class="line">    arr[a] &#x3D; arr[b];</span><br><span class="line">    arr[b] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那堆排序是稳定排序吗？"><a href="#那堆排序是稳定排序吗？" class="headerlink" title="那堆排序是稳定排序吗？"></a>那堆排序是稳定排序吗？</h2><p>我们知道堆的结构是节点i的孩子为<code>2 * i</code>和<code>2 * i + 1</code>节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第<code>n / 2</code>开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为<code>n / 2 - 1， n / 2 - 2， ... 1</code>这些个父节点选择元素时，就会破坏稳定性。有可能第<code>n / 2</code>个父节点交换把后面一个元素交换过去了，而第<code>n / 2 - 1</code>个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>不稳定的排序: 选择排序、快速排序、希尔排序、堆排序</li>
<li>稳定排序：冒泡排序、插入排序、归并排序、基数排序</li>
</ul>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：【面试】最容易被问到的N种排序算法！</li>
        <li>本文作者：小明</li>
        <li>创建时间：2019-06-20 20:34:14</li>
        <li>
            本文链接：https://mynamecoder.com/p/7836.html
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/p/1b5.html"
                        >
                            <span class="left arrow-icon flex-center" >
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">mybatis常用总结</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/p/17df.html"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">阿里云企业云邮箱收发设置</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center" >
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                    
                </main>

            </div>

            <div class="page-main-content-bottom">
                <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span> -
            
            2020 <i class="fas fa-heart icon-animate"></i> <a href="/">小明</a>
        </div>
        
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数 <span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量 <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动 | 主题 <a class="theme-version" target="_blank"></a>
        </div>
    </div>
</footer>

            </div>
        </div>
    </main>

    <div class="sidebar-tools">
        <div class="tools-container">
    <ul class="tools-list">
        

        

        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

    </ul>
</div>

    </div>

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">

    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-top flex-center">
            <i class="fas fa-arrow-up"></i>
        </li>

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="tools-ul-1">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

    </ul>
</div>

    </div>

    <!-- page aside -->
    <aside class="page-aside">
        
            .post-toc-wrap {
  width: 100%;
  font-size: 0.92rem;
  box-sizing: border-box;

  .post-toc {

    ol {
      list-style: none;
      margin: 0;
      padding: 0 2px 12px 10px;
      text-align: left;

      &:last-child {
        padding-bottom: 0;
      }

      > ol {
        padding-left: 0;
      }

      a {
        transition-property: all;
        transition();
      }
    }

    .nav-item {
      line-height: 1.8;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .nav {
      .nav-child {
        display: hexo-config('toc.expand_all') ? block : none;
      }

      .active > .nav-child {
        display: block;
      }

      .active-current > .nav-child {
        display: block;

        > .nav-item {
          display: block;
        }
      }

      .active > a {
        color: var(--primary-color);
      }

      .active-current > a {
        color: var(--primary-color);
      }
    }
  }
}


        
    </aside>

    <!-- image viewer -->
    <div class="image-viewer-container">
    <div class="img-box">
        <img src="">
    </div>
</div>


</div>



    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fas fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/local-search.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/left-side-toggle.js"></script>

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/code-copy.js"></script>
    

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.4/source/js/toc.js"></script>
    


</body>
</html>