<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git删除暂存区或版本库中的文件</title>
    <url>/p/48.html</url>
    <content><![CDATA[<h1 id="故事提要"><a href="#故事提要" class="headerlink" title="故事提要"></a>故事提要</h1><blockquote>
<p>小明今天遇到了一个bug，莫名奇妙改着改着就乱了，万分后悔，一心想回退到之前的版本重新开始，不过庆幸的是使用了git托管，一起来看看git作为管理工具的强大之处吧。</p>
</blockquote>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Git有三大区（工作区、暂存区、版本库）以及几个状态（untracked、unstaged、uncommited），下面只是简述下Git的大概工作流程，详细的可以参见<a class="link"   href="http://www.cnblogs.com/cposture/category/642672.html" >其他有关Git的文章<i class="fas fa-external-link-alt"></i></a>。 </p>
<ul>
<li><p>打开你的项目文件夹，除了隐藏的.git文件夹，其他项目文件位于的地方便是工作区，工作区的文件需要添加到Git的暂存区（git add），随后再提交到Git的版本库（git commit）。</p>
</li>
<li><p>首次新建的文件都是untracked状态（未跟踪），此时需要git add到暂存区，Git便会在暂存区中生成一个该文件的索引，文件此时处于uncommited状态，需要git commit生成版本库。添加到了版本库之后，再对文件进行修改，那么文件的状态会变为unstaged状态。<br>简单的认识了Git的工作流程，接下来便可以看看如何删除错误添加到暂存区或版本库里的文件了！</p>
</li>
</ul>
<h1 id="删除错误添加到暂存区的文件"><a href="#删除错误添加到暂存区的文件" class="headerlink" title="删除错误添加到暂存区的文件"></a>删除错误添加到暂存区的文件</h1><p>有时你在工作区新建了文件TestFile，并且已经将它添加到了暂存区，git会告知，现有有一个文件未提交到版本库，如下图：<br><img src="https://i.ibb.co/t3dWQ1r/2019-05-07-6-32-30.png" alt="未提交到版本库"></p>
<h1 id="仅仅删除暂存区里的文件"><a href="#仅仅删除暂存区里的文件" class="headerlink" title="仅仅删除暂存区里的文件"></a>仅仅删除暂存区里的文件</h1><p>此时你想撤销错误添加到暂存区里的文件，可以输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm --cache 文件名</span><br></pre></td></tr></table></figure>
<p><img src="https://i.ibb.co/fkp4Khq/2019-05-07-6-33-26.png" alt="撤销错误添加到暂存区"></p>
<p>上面的命令仅仅删除暂存区的文件而已，不会影响工作区的文件，如上图，TestFile.txt仍然存在，此时输入下面命令，git会告知有一个未跟踪的文件TestFile.txt。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<h1 id="删除暂存区和工作区的文件"><a href="#删除暂存区和工作区的文件" class="headerlink" title="删除暂存区和工作区的文件"></a>删除暂存区和工作区的文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -f 文件名</span><br></pre></td></tr></table></figure>
<p><strong>工作区的文件也被删除了。</strong></p>
<p><img src="https://i.ibb.co/K6K77vj/2019-05-07-6-33-54.png" alt="工作区的文件"></p>
<h1 id="删除错误提交的commit"><a href="#删除错误提交的commit" class="headerlink" title="删除错误提交的commit"></a>删除错误提交的commit</h1><p>有时，不仅添加到了暂存区，而且commit到了版本库，这个时候就不能使用git rm了，需要使用git reset命令。<br>错误提交到了版本库，此时无论工作区、暂存区，还是版本库，这三者的内容都是一样的，所以在这种情况下，只是删除了工作区和暂存区的文件，下一次用该版本库回滚那个误添加的文件还会重新生成。<br>这个时候，我们必须撤销版本库的修改才能解决问题！<br>git reset有三个选项，–hard、–mixed、–soft。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;仅仅只是撤销已提交的版本库，不会修改暂存区和工作区</span><br><span class="line">git reset --soft 版本库ID</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;仅仅只是撤销已提交的版本库和暂存区，不会修改工作区</span><br><span class="line">git reset --mixed 版本库ID</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;彻底将工作区、暂存区和版本库记录恢复到指定的版本库</span><br><span class="line">git reset --hard 版本库ID</span><br></pre></td></tr></table></figure>
<p>那我们到底应该用哪个选项好呢？</p>
<ul>
<li>如果你是在提交了后，对工作区的代码做了修改，并且想保留这些修改，那么可以使用git reset –mixed 版本库ID，注意这个版本库ID应该不是你刚刚提交的版本库ID，而是刚刚提交版本库的上一个版本库。如下图：</li>
<li>如果不想保留这些修改，可以直接使用彻底的恢复命令，git reset –hard 版本库ID。</li>
<li>为什么不使用–soft呢，因为它只是恢复了版本库，暂存区仍然存在你错误提交的文件索引，还需要进一步使用上一节的删除错误添加到暂存区的文件，详细见上文。</li>
</ul>
<p><img src="https://i.ibb.co/L9QcfCR/2019-05-07-6-34-10.png" alt="版本历史"></p>
<h2 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h2><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8日常开发系列：Consumer详解</title>
    <url>/p/9bfd.html</url>
    <content><![CDATA[<p>java.util.function中 <strong>Function</strong>, <strong>Supplier</strong>, <strong>Consumer</strong>, <strong>Predicate</strong>和其他函数式接口广泛用在支持lambda表达式的API中。这些接口有一个抽象方法，会被lambda表达式的定义所覆盖。</p>
<a id="more"></a>
<p>Consumer的作用顾名思义,是给定义一个参数,对其进行(消费)处理,处理的方式可以是任意操作.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void accept(T t);</span><br><span class="line"></span><br><span class="line">    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其核心方法如下:</p>
<ul>
<li>void accept(T t);<br>对给定的参数T执行定义的操作</li>
</ul>
<ul>
<li>default Consumer<T> andThen(Consumer&lt;? super T&gt; after)<br>对给定的参数T执行定义的操作执行再继续执行after定义的操作</li>
</ul>
<p>下面对上述方法进行实例测试：</p>
<h2 id="accept-T-t"><a href="#accept-T-t" class="headerlink" title="accept(T t)"></a>accept(T t)</h2><p>比如将给定的一批用户里面的名称为”lisi”的用户都给打包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 此处使用lombok插件（值得了解）</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; lisiList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Consumer&lt;Person&gt; consumer  &#x3D; x -&gt; &#123;</span><br><span class="line">    if (x.getName().equals(&quot;lisi&quot;))&#123;</span><br><span class="line">        lisiList.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Stream.of(</span><br><span class="line">        new Person(21,&quot;zhangsan&quot;),</span><br><span class="line">        new Person(22,&quot;lisi&quot;),</span><br><span class="line">        new Person(23,&quot;wangwu&quot;),</span><br><span class="line">        new Person(24,&quot;wangwu&quot;),</span><br><span class="line">        new Person(23,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;zhangsan&quot;)</span><br><span class="line">).forEach(consumer);</span><br><span class="line"></span><br><span class="line">System.out.println(JSON.toJSONString(lisiList));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;age&quot;:22,&quot;name&quot;:&quot;lisi&quot;&#125;,&#123;&quot;age&quot;:23,&quot;name&quot;:&quot;lisi&quot;&#125;,&#123;&quot;age&quot;:26,&quot;name&quot;:&quot;lisi&quot;&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="default-Consumer-andThen-Consumer-lt-super-T-gt-after"><a href="#default-Consumer-andThen-Consumer-lt-super-T-gt-after" class="headerlink" title="default Consumer andThen(Consumer&lt;? super T&gt; after)"></a>default Consumer<T> andThen(Consumer&lt;? super T&gt; after)</h2><p>比如将给定的一批用户里面的名称为”lisi”且年龄大于22岁的用户都给打包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; lisiList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">Consumer&lt;Person&gt; consumer  &#x3D; x -&gt; &#123;</span><br><span class="line">    if (x.getName().equals(&quot;lisi&quot;))&#123;</span><br><span class="line">        lisiList.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">consumer &#x3D; consumer.andThen(</span><br><span class="line">        x -&gt; lisiList.removeIf(y -&gt; y.getAge() &lt; 23)</span><br><span class="line">);</span><br><span class="line">Stream.of(</span><br><span class="line">        new Person(21,&quot;zhangsan&quot;),</span><br><span class="line">        new Person(22,&quot;lisi&quot;),</span><br><span class="line">        new Person(23,&quot;wangwu&quot;),</span><br><span class="line">        new Person(24,&quot;wangwu&quot;),</span><br><span class="line">        new Person(23,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;lisi&quot;),</span><br><span class="line">        new Person(26,&quot;zhangsan&quot;)</span><br><span class="line">).forEach(consumer);</span><br><span class="line"></span><br><span class="line">System.out.println(JSON.toJSONString(lisiList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;age&quot;:23,&quot;name&quot;:&quot;lisi&quot;&#125;,&#123;&quot;age&quot;:26,&quot;name&quot;:&quot;lisi&quot;&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="与Consumer相关的接口"><a href="#与Consumer相关的接口" class="headerlink" title="与Consumer相关的接口"></a>与Consumer<T>相关的接口</h2><ul>
<li>BiConsumer&lt;T, U&gt;</li>
</ul>
<p>处理一个两个参数</p>
<ul>
<li>DoubleConsumer</li>
</ul>
<p>处理一个double类型的参数</p>
<ul>
<li>IntConsumer</li>
</ul>
<p>处理一个int类型的参数</p>
<ul>
<li>LongConsumer</li>
</ul>
<p>处理一个long类型的参数</p>
<ul>
<li>ObjIntConsumer<T></li>
</ul>
<p>处理两个参数,且第二个参数必须为int类型</p>
<ul>
<li>ObjLongConsumer<T></li>
</ul>
<p>处理两个参数,且第二个参数必须为long类型</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>「Elasticsearch」ES重建索引怎么才能做到数据无缝迁移呢？</title>
    <url>/p/20547.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>众所周知，Elasticsearch是⼀个实时的分布式搜索引擎，为⽤户提供搜索服务。当我们决定存储某种数据，在创建索引的时候就需要将数据结构，即Mapping确定下来，于此同时索引的设定和很多固定配置将不能改变。</p>
<a id="more"></a>
<p>那如果后续业务发生变化，需要改变数据结构或者更换ES更换分词器怎么办呢？为此，Elastic团队提供了很多通过辅助⼯具来帮助开发⼈员进⾏重建索引的方案。<br>如果对 <code>reindex</code> API 不熟悉，那么在遇到重构的时候，必然事倍功半，效率低下。反之，就可以方便地进行索引重构，省时省力。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>假设之前我们已经存在一个blog索引，因为更换分词器需要对该索引中的数据进行重建索引，以便支持业务使用新的分词规则搜索数据，并且尽可能使这个变化对外服务没有感知，大概分为以下几个步骤：​</p>
<ul>
<li>新增⼀个索引<code>blog_lastest</code>，Mapping数据结构与<code>blog</code>索引一致</li>
<li>将<code>blog</code>数据同步至<code>blog_lastest</code></li>
<li>删除<code>blog</code>索引</li>
<li>数据同步后给<code>blog_lastest</code>添加别名<code>blog</code></li>
</ul>
<h3 id="新建索引"><a href="#新建索引" class="headerlink" title="新建索引"></a>新建索引</h3><blockquote>
<p>在这里推荐一个ES管理工具<strong>Kibana</strong>，主要针对数据的探索、可视化和分析。</p>
</blockquote>
<p><img src="https://img.mynamecoder.com/mweb/16093371925425.jpg" alt="官网"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">put &#x2F;blog_lastest&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;title&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                &quot;analyzer&quot;:&quot;ik_max_word&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;author&quot;:&#123;</span><br><span class="line">                &quot;type&quot;:&quot;keyword&quot;,</span><br><span class="line">                &quot;fields&quot;:&#123;</span><br><span class="line">                    &quot;seg&quot;:&#123;</span><br><span class="line">                        &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">                        &quot;analyzer&quot;:&quot;ik_max_word&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将旧索引数据copy到新索引"><a href="#将旧索引数据copy到新索引" class="headerlink" title="将旧索引数据copy到新索引"></a>将旧索引数据copy到新索引</h3><h4 id="同步等待"><a href="#同步等待" class="headerlink" title="同步等待"></a>同步等待</h4><p>接⼝将会在 reindex 结束后返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_reindex</span><br><span class="line">&#123;</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;dest&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog_lastest&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>kibana</code> 中的使用如下所示<br><img src="https://img.mynamecoder.com/mweb/16093465633359.jpg" alt="-w706"></p>
<p>当然高版本（7.1.1）中，ES都有提供对应的<code>Java REST Client</code>，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReindexRequest reindexRequest &#x3D; new ReindexRequest();</span><br><span class="line">reindexRequest.setSourceIndices(&quot;blog&quot;).setSource.setDestIndex(&quot;blog_lastest&quot;);</span><br><span class="line">TaskSubmissionResponse taskSubmissionResponse &#x3D; client.submitReindexTask(reindexRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>
<p>为了防止赘述，接下来举例全部以<code>kibana</code>中请求介绍，如果有需要用<code>Java REST Client</code>，可以自行去ES官网查看。</p>
<h4 id="异步执⾏"><a href="#异步执⾏" class="headerlink" title="异步执⾏"></a>异步执⾏</h4><p>如果 reindex 时间过⻓，建议加上 <code>wait_for_completion=false</code> 的参数条件，这样 reindex 将直接返回 <code>taskId</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_reindex?wait_for_completion&#x3D;false</span><br><span class="line">&#123;</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;dest&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog_lastest&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;task&quot; : &quot;dpBihNSMQfSlboMGlTgCBA:4728038&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="op-type-参数"><a href="#op-type-参数" class="headerlink" title="op_type 参数"></a>op_type 参数</h4><p><code>op_type</code> 参数控制着写入数据的冲突处理方式，如果把 <code>op_type</code> 设置为 <code>create</code>【默认值】，在 <code>_reindex</code> API 中，表示写入时只在 <code>dest</code> <code>index</code>中添加不存在的 doucment，如果相同的 document 已经存在，则会报 <code>version confilct</code> 的错误，那么索引操作就会失败。【这种方式与使用 _create API 时效果一致】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog_lastest&quot;,</span><br><span class="line">    &quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这样设置了，也就不存在更新数据的场景了【冲突数据无法写入】，我们也可以把 <code>op_type</code> 设置为 <code>index</code>，表示所有的数据全部重新索引创建。</p>
<h4 id="conflicts-配置"><a href="#conflicts-配置" class="headerlink" title="conflicts 配置"></a>conflicts 配置</h4><p>默认情况下，当发生 <code>version conflict</code> 的时候，<code>_reindex</code> 会被 <code>abort</code>，任务终止【此时数据还没有 <code>reindex</code> 完成】，在返回体中的 <code>failures</code> 指标中会包含冲突的数据【有时候数据会非常多】，除非把 <code>conflicts</code> 设置为 <code>proceed</code>。</p>
<p>关于 <code>abort</code> 的说明，如果产生了 <code>abort</code>，已经执行的数据【例如更新写入的】仍然存在于目标索引，此时任务终止，还会有数据没有被执行，也就是漏数了。换句话说，该执行过程不会回滚，只会终止。如果设置了 <code>proceed</code>，任务在检测到数据冲突的情况下，不会终止，会跳过冲突数据继续执行，直到所有数据执行完成，此时不会漏掉正常的数据，只会漏掉有冲突的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;blog_lastest&quot;,</span><br><span class="line">    &quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;conflicts&quot;: &quot;proceed&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以故意把 <code>op_type</code> 设置为 <code>create</code>，人为制造数据冲突的场景，测试时更容易观察到冲突现象。</p>
<p>如果把 <code>conflicts</code> 设置为 <code>proceed</code>，在返回体结果中不会再出现 <code>failures</code> 的信息，但是通过 <code>version_conflicts</code> 指标可以看到具体的数量。</p>
<h4 id="批次大小配置"><a href="#批次大小配置" class="headerlink" title="批次大小配置"></a>批次大小配置</h4><p>当你发现<code>reindex</code>的速度有些慢的时候，可以在 <code>query</code> 参数的同一层次【即 <code>source</code> 参数中】添加 <code>size</code> 参数，表示 <code>scroll size</code> 的大小【会影响批次的次数，进而影响整体的速度】，如果不显式设置，默认是一批 1000 条数据，在一开始的简单示例中也看到了。<br>如下，设置 <code>scroll size</code> 为 5000：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_reindex?wait_for_completion&#x3D;false</span><br><span class="line">&#123;</span><br><span class="line">	&quot;source&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog&quot;,</span><br><span class="line">		&quot;size&quot;:5000</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;dest&quot;: &#123;</span><br><span class="line">		&quot;index&quot;: &quot;blog_lastest&quot;,</span><br><span class="line">		&quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;conflicts&quot;: &quot;proceed&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试后，速度达到了 30 分钟 500 万左右，明显提升了很多。</p>
<h4 id="根据taskId可以实时查看任务的执行状态"><a href="#根据taskId可以实时查看任务的执行状态" class="headerlink" title="根据taskId可以实时查看任务的执行状态"></a>根据taskId可以实时查看任务的执行状态</h4><p>一般来说，如果我们的 <code>source index</code> 很大【比如几百万数据量】，则可能需要比较长的时间来完成 <code>_reindex</code> 的工作，可能需要几十分钟。而在此期间不可能一直等待结果返回，可以去做其它事情，如果中途需要查看进度，可以通过 <code>_tasks</code> API 进行查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_tasks&#x2F;&#123;taskId&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;completed&quot; : false,</span><br><span class="line">  &quot;task&quot; : &#123;</span><br><span class="line">    &quot;node&quot; : &quot;dpBihNSMQfSlboMGlTgCBA&quot;,</span><br><span class="line">    &quot;id&quot; : 4704218,</span><br><span class="line">    &quot;type&quot; : &quot;transport&quot;,</span><br><span class="line">    &quot;action&quot; : &quot;indices:data&#x2F;write&#x2F;reindex&quot;,</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行完毕时，<code>completed</code>为true<br>查看任务进度以及取消任务，除了根据taskId查看以外，我们还可以通过查看所有的任务中筛选本次<code>reindex</code>的任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _tasks?detailed&#x3D;true&amp;actions&#x3D;*reindex</span><br></pre></td></tr></table></figure>
<p>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;nodes&quot; : &#123;</span><br><span class="line">    &quot;dpBihNSMQfSlboMGlTgCBA&quot; : &#123;</span><br><span class="line">      &quot;name&quot; : &quot;node-16111-9210&quot;,</span><br><span class="line">      &quot;transport_address&quot; : &quot;192.168.XXX.XXX:9310&quot;,</span><br><span class="line">      &quot;host&quot; : &quot;192.168.XXX.XXX&quot;,</span><br><span class="line">      &quot;ip&quot; : &quot;192.168.16.111:9310&quot;,</span><br><span class="line">      &quot;roles&quot; : [</span><br><span class="line">        &quot;ingest&quot;,</span><br><span class="line">        &quot;master&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;attributes&quot; : &#123;</span><br><span class="line">        &quot;xpack.installed&quot; : &quot;true&quot;,</span><br><span class="line">        &quot;transform.node&quot; : &quot;false&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tasks&quot; : &#123;</span><br><span class="line">        &quot;dpBihNSMQfSlboMGlTgCBA:6629305&quot; : &#123;</span><br><span class="line">          &quot;node&quot; : &quot;dpBihNSMQfSlboMGlTgCBA&quot;,</span><br><span class="line">          &quot;id&quot; : 6629305,</span><br><span class="line">          &quot;type&quot; : &quot;transport&quot;,</span><br><span class="line">          &quot;action&quot; : &quot;indices:data&#x2F;write&#x2F;reindex&quot;,</span><br><span class="line">          &quot;status&quot; : &#123;</span><br><span class="line">            &quot;total&quot; : 8361421,</span><br><span class="line">            &quot;updated&quot; : 0,</span><br><span class="line">            &quot;created&quot; : 254006,</span><br><span class="line">            &quot;deleted&quot; : 0,</span><br><span class="line">            &quot;batches&quot; : 743,</span><br><span class="line">            &quot;version_conflicts&quot; : 3455994,</span><br><span class="line">            &quot;noops&quot; : 0,</span><br><span class="line">            &quot;retries&quot; : &#123;</span><br><span class="line">              &quot;bulk&quot; : 0,</span><br><span class="line">              &quot;search&quot; : 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;throttled_millis&quot; : 0,</span><br><span class="line">            &quot;requests_per_second&quot; : -1.0,</span><br><span class="line">            &quot;throttled_until_millis&quot; : 0</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;description&quot; : &quot;reindex from [blog] to [blog_lastest][_doc]&quot;,</span><br><span class="line">          &quot;start_time_in_millis&quot; : 1609338953464,</span><br><span class="line">          &quot;running_time_in_nanos&quot; : 1276738396689,</span><br><span class="line">          &quot;cancellable&quot; : true,</span><br><span class="line">          &quot;headers&quot; : &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意观察里面的几个重要指标，例如从 <code>description</code> 中可以看到任务描述，从 tasks 中可以找到任务的 <code>id</code>【例如 <code>dpBihNSMQfSlboMGlTgCBA:6629305</code>】，从 <code>cancellable</code> 可以判断任务是否支持取消操作。<br>这个 API 其实就是模糊匹配，同理也可以查询其它类型的任务信息，例如使用 <code>GET _tasks?detailed=true&amp;actions=*byquery</code> 查看查询请求的状态。<br>当集群的任务太多时我们就可以根据<code>task_id</code>，也就是上面提到<code>GET /_tasks/task_id</code> 方式更加准确地查询指定任务的状态，避免集群的任务过多，不方便查看。<br>如果遇到操作失误的场景，想取消任务，有没有办法呢？<br>当然有啦，虽然覆水难收，通过调用<br><code>_tasks API</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST _tasks&#x2F;task_id&#x2F;_cancel</span><br></pre></td></tr></table></figure>
<p>这里的 <code>task_id</code> 就是通过上面的查询任务接口获取的任务id（任务要支持取消操作，即【cancellable 为 true】时方能收效）。</p>
<h3 id="删除旧索引"><a href="#删除旧索引" class="headerlink" title="删除旧索引"></a>删除旧索引</h3><p>当我们通过 API 查询发现任务完成后，就可以进行后续操作，我这里是要删除旧索引，然后再给新索引起别名，用于替换旧索引，这样才能保证对外服务没有任何感知。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;blog</span><br></pre></td></tr></table></figure>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_aliases</span><br><span class="line">&#123;</span><br><span class="line">    &quot;actions&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;add&quot;:&#123;</span><br><span class="line">                &quot;index&quot;:&quot;blog_lastest&quot;,</span><br><span class="line">                &quot;alias&quot;:&quot;blog&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过别名访问新索引"><a href="#通过别名访问新索引" class="headerlink" title="通过别名访问新索引"></a>通过别名访问新索引</h3><p>进行过以上操作后，我们可以使用一个简单的搜索验证服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;blog&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;match&quot;: &#123;</span><br><span class="line">			&quot;author&quot;: &quot;james&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果搜索结果达到我们的预期目标，至此，数据索引重建迁移完成。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 1.8 处理时间常用举例</title>
    <url>/p/f00a.html</url>
    <content><![CDATA[<blockquote>
<p>在Java 8以前，日期和时间处理一直被广大java程序员抱怨太难用，首先是<code>java.util</code>和<code>java.sql</code>中，都包含<code>Date</code>类，如果要处理<code>java.text.DateFormat</code>类处理。同时<code>java.util.Date</code>中既包含了日期，又包含了时间，所以java8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方日期库<code>joda</code>很多的优点。</p>
</blockquote>
<p>在java8中，<code>java.time</code>包下主要包含下面几个主要的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Instant：时间戳  </span><br><span class="line">Duration：持续时间，时间差  </span><br><span class="line">LocalDate：只包含日期，比如：2016-10-20  </span><br><span class="line">LocalTime：只包含时间，比如：23:12:10  </span><br><span class="line">LocalDateTime：包含日期和时间，比如：2016-10-20 23:14:21  </span><br><span class="line">Period：时间段  </span><br><span class="line">ZoneOffset：时区偏移量，比如：+8:00  </span><br><span class="line">ZonedDateTime：带时区的时间  </span><br><span class="line">Clock：时钟，比如获取目前美国纽约的时间  </span><br></pre></td></tr></table></figure>
<p>以及<code>java.time.format</code>包中的</p>
<p><code>DateTimeFormatter：时间格式化</code></p>
<p>下面我们通过例子来看如何使用java8新的日期时间库</p>
<h2 id="获取今天的日期"><a href="#获取今天的日期" class="headerlink" title="获取今天的日期"></a>获取今天的日期</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate todayDate &#x3D; LocalDate.now();  </span><br><span class="line">System.out.println(&quot;今天的日期：&quot;+todayDate);  </span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">今天的日期：2016-10-20</span><br></pre></td></tr></table></figure>
<h2 id="指定日期，进行相应操作"><a href="#指定日期，进行相应操作" class="headerlink" title="指定日期，进行相应操作"></a>指定日期，进行相应操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;取2016年10月的第1天</span><br><span class="line">LocalDate firstDay &#x3D; oneday.with(TemporalAdjusters.firstDayOfMonth());  </span><br><span class="line">System.out.println(firstDay);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取2016年10月的第1天，另外一种写法</span><br><span class="line">LocalDate firstDay2 &#x3D; oneday.withDayOfMonth(1);  </span><br><span class="line">System.out.println(firstDay2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;取2016年10月的最后1天，不用考虑大月，小月，平年，闰年</span><br><span class="line">LocalDate lastDay &#x3D; oneday.with(TemporalAdjusters.lastDayOfMonth());  </span><br><span class="line">System.out.println(lastDay);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前日期＋1天</span><br><span class="line">LocalDate tomorrow &#x3D; oneday.plusDays(1);  </span><br><span class="line">System.out.println(tomorrow);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前日期-7天</span><br><span class="line">LocalDate minus &#x3D; oneday.minus(7, ChronoUnit.DAYS);</span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">LocalDate minus &#x3D; oneday.minusDays(7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否为闰年</span><br><span class="line">boolean isLeapYear &#x3D; tomorrow.isLeapYear();  </span><br><span class="line">System.out.println(isLeapYear);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行结果</span><br><span class="line">2016-10-20  </span><br><span class="line">2016-10-01  </span><br><span class="line">2016-10-01  </span><br><span class="line">2016-10-31  </span><br><span class="line">2016-10-21  </span><br><span class="line">true  </span><br></pre></td></tr></table></figure>
<h2 id="生日检查或者账单日检查"><a href="#生日检查或者账单日检查" class="headerlink" title="生日检查或者账单日检查"></a>生日检查或者账单日检查</h2><p>开发过程中，经常需要为过生日的用户送上一些祝福，例如，用户的生日为1990-10-12，如果今天是2016-10-12，那么今天就是用户的生日（按公历／身份证日期来算），那么通过java8新的日期库，我们该如何来进行判断？</p>
<p>在java8中，可以使用<code>MonthDay</code>，该类不包含年份信息，当然还有一个类是<code>YearMonth</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate birthday &#x3D; LocalDate.of(1990, 10, 12);  </span><br><span class="line">MonthDay birthdayMd &#x3D; MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());  </span><br><span class="line">MonthDay today &#x3D; MonthDay.from(LocalDate.of(2016, 10, 12));  </span><br><span class="line">System.out.println(today.equals(birthdayMd));  </span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">true  </span><br></pre></td></tr></table></figure>
<h2 id="获取当前的时间"><a href="#获取当前的时间" class="headerlink" title="获取当前的时间"></a>获取当前的时间</h2><p>日期主要是使用LocalTime，该类不包含日期，只有时间信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前的时间</span><br><span class="line">LocalTime nowTime &#x3D; LocalTime.now(); &#x2F;&#x2F;结果14:29:40.558</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果不想显示毫秒</span><br><span class="line">LocalTime nowTime2 &#x3D; LocalTime.now().withNano(0); &#x2F;&#x2F;14:43:14</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定时间</span><br><span class="line">LocalTime time &#x3D; LocalTime.of(14, 10, 21); &#x2F;&#x2F;14:10:21  </span><br><span class="line">LocalTime time2 &#x3D; LocalTime.parse(&quot;12:00:01&quot;); &#x2F;&#x2F; 12:00:01</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前时间增加2小时</span><br><span class="line">LocalTime nowTimePlus2Hour &#x3D; nowTime.plusHours(2); &#x2F;&#x2F;16:47:23.144  </span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">LocalTime nowTimePlus2Hour2 &#x3D; nowTime.plus(2, ChronoUnit.HOURS);  </span><br></pre></td></tr></table></figure>
<h2 id="日期前后比较"><a href="#日期前后比较" class="headerlink" title="日期前后比较"></a>日期前后比较</h2><p>比较2个日期哪个在前，哪个在后，java8 LocalDate提供了2个方法，<code>isAfter()</code>,<code>isBefore</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate today &#x3D; LocalDate.now();  </span><br><span class="line">LocalDate specifyDate &#x3D; LocalDate.of(2015, 10, 20);  </span><br><span class="line">System.out.println(today.isAfter(specifyDate)); &#x2F;&#x2F;true  </span><br></pre></td></tr></table></figure>
<h2 id="处理不同时区的时间"><a href="#处理不同时区的时间" class="headerlink" title="处理不同时区的时间"></a>处理不同时区的时间</h2><p>java8中，将日期，时间，时区都很好的进行了分离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查看当前的时区</span><br><span class="line">ZoneId defaultZone &#x3D; ZoneId.systemDefault();  </span><br><span class="line">System.out.println(defaultZone); &#x2F;&#x2F;Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看美国纽约当前的时间</span><br><span class="line">ZoneId america &#x3D; ZoneId.of(&quot;America&#x2F;New_York&quot;);  </span><br><span class="line">LocalDateTime shanghaiTime &#x3D; LocalDateTime.now();  </span><br><span class="line">LocalDateTime americaDateTime &#x3D; LocalDateTime.now(america);  </span><br><span class="line">System.out.println(shanghaiTime); &#x2F;&#x2F;2016-11-06T15:20:27.996  </span><br><span class="line">System.out.println(americaDateTime); &#x2F;&#x2F;2016-11-06T02:20:27.996 ，可以看到美国与北京时间差了13小时</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带有时区的时间</span><br><span class="line">ZonedDateTime americaZoneDateTime &#x3D; ZonedDateTime.now(america);  </span><br><span class="line">System.out.println(americaZoneDateTime); &#x2F;&#x2F;2016-11-06T02:23:44.863-05:00[America&#x2F;New_York]  </span><br></pre></td></tr></table></figure>
<h2 id="比较两个日期之前时间差"><a href="#比较两个日期之前时间差" class="headerlink" title="比较两个日期之前时间差"></a>比较两个日期之前时间差</h2><p>在项目中，经常需要比较两个日期之间相差几天，或者相隔几个月，我们可以使用java8的Period来进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate today &#x3D; LocalDate.now();  </span><br><span class="line">LocalDate specifyDate &#x3D; LocalDate.of(2015, 10, 2);  </span><br><span class="line">Period period &#x3D; Period.between(specifyDate, today);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getDays());  &#x2F;&#x2F;4  </span><br><span class="line">System.out.println(period.getMonths()); &#x2F;&#x2F;1  </span><br><span class="line">System.out.println(specifyDate.until(today, ChronoUnit.DAYS)); &#x2F;&#x2F;401  </span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">4  </span><br><span class="line">1  </span><br><span class="line">401  </span><br></pre></td></tr></table></figure>
<p>我们可以看到，我们使用<code>Period</code>类比较天数，比较奇怪，他返回的值，并不是2个日期之间总共的天数差，而是一个相对天数差，比如，5月1日，和10月2日，他比较的是仅仅2个天之间的差，那1号和2号，相差1天，而实际上，因为中间相差了好几个月，所以真正的天数差肯定不是1天，所以我们可以使用<code>until</code>，并指明精度单位是<code>days</code>，就可以计算真正的天数差了。</p>
<h2 id="日期时间格式解析、格式化"><a href="#日期时间格式解析、格式化" class="headerlink" title="日期时间格式解析、格式化"></a>日期时间格式解析、格式化</h2><p>在java8之前，我们进行时间格式化主要是使用<code>SimpleDateFormat</code>，而在java8中，主要是使用<code>DateTimeFormatter</code>,java8中，预定义了一些标准的时间格式，我们可以直接将时间转换为标准的时间格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String specifyDate &#x3D; &quot;20151011&quot;;  </span><br><span class="line">DateTimeFormatter formatter &#x3D; DateTimeFormatter.BASIC_ISO_DATE;  </span><br><span class="line">LocalDate formatted &#x3D; LocalDate.parse(specifyDate,formatter);  </span><br><span class="line">System.out.println(formatted);  </span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">2015-10-11  </span><br><span class="line">当然，很多时间标准的时间格式可能也不满足我们的要求，我们需要转为自定义的时间格式</span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter2 &#x3D; DateTimeFormatter.ofPattern(&quot;YYYY MM dd&quot;);  </span><br><span class="line">System.out.println(formatter2.format(LocalDate.now()));  </span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">2015 10 11  </span><br></pre></td></tr></table></figure>
<h2 id="java8-时间类与Date类的相互转化"><a href="#java8-时间类与Date类的相互转化" class="headerlink" title="java8 时间类与Date类的相互转化"></a>java8 时间类与Date类的相互转化</h2><p>在转换中，我们需要注意，因为java8之前<code>Date</code>是包含日期和时间的，而<code>LocalDate</code>只包含日期，<code>LocalTime</code>只包含时间，所以与<code>Date</code>在互转中，势必会丢失日期或者时间，或者会使用起始时间。如果转<code>LocalDateTime</code>，那么就不存在信息误差。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Date与Instant的相互转化</span><br><span class="line">Instant instant  &#x3D; Instant.now();  </span><br><span class="line">Date date &#x3D; Date.from(instant);  </span><br><span class="line">Instant instant2 &#x3D; date.toInstant();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Date转为LocalDateTime</span><br><span class="line">Date date2 &#x3D; new Date();  </span><br><span class="line">LocalDateTime localDateTime2 &#x3D; LocalDateTime.ofInstant(date2.toInstant(), ZoneId.systemDefault());</span><br><span class="line">&#x2F;&#x2F;Date转为LocalDate</span><br><span class="line">LocalDate localDate &#x3D; date2.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LocalDateTime转Date</span><br><span class="line">LocalDateTime localDateTime3 &#x3D; LocalDateTime.now();  </span><br><span class="line">Instant instant3 &#x3D; localDateTime3.atZone(ZoneId.systemDefault()).toInstant();  </span><br><span class="line">Date date3 &#x3D; Date.from(instant);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LocalDate转Date</span><br><span class="line">&#x2F;&#x2F;因为LocalDate不包含时间，所以转Date时，会默认转为当天的起始时间，00:00:00</span><br><span class="line">LocalDate localDate4 &#x3D; LocalDate.now();  </span><br><span class="line">Instant instant4 &#x3D; localDate4.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant();  </span><br><span class="line">Date date4 &#x3D; Date.from(instant); </span><br></pre></td></tr></table></figure>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的try，如何开启新姿势？</title>
    <url>/p/44518.html</url>
    <content><![CDATA[<blockquote>
<p>时间紧迫，长话短说，今天，小明给大家同步一个知识点，使用<strong>try-with-resources</strong>来优雅地关闭资源。</p>
</blockquote>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>其实，在JDK 7就已经引入了对<strong>try-with-resources</strong>的支持，它的主要作用就是解放小明和小明小伙伴们的双手，帮助我们自动释放使用过的资源（比如输入、输出流）。</p>
<a id="more"></a>
<h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h2><p>如何才能使用这个自动关闭资源的骚操作呢？我们只需要在try内声明和初始化资源即可，如下所示：</p>
<p><img src="https://img.mynamecoder.com/20200413002129.png"></p>
<p>这样，当我们写入文件时，只需要将心思放在输入的内容就行啦。</p>
<h2 id="3-使用try-with-resources的好处"><a href="#3-使用try-with-resources的好处" class="headerlink" title="3.使用try-with-resources的好处"></a>3.使用try-with-resources的好处</h2><p>在很久很久以前，你是不是和小明一样每每操作输入流、输出流的时候，用的都是<strong>try-catch-finally</strong>代码块？</p>
<p>现在，答应我好嘛，作为小明的小伙伴，看完这篇文章后，再写代码时，不要再将就，务必使用<strong>try-with-resources</strong>会更小明（优雅）一些。</p>
<p>接下来，我们简单地做个比较：</p>
<h4 id="之前的小明"><a href="#之前的小明" class="headerlink" title="之前的小明"></a>之前的小明</h4><p><img src="https://img.mynamecoder.com/20200413002209.png"></p>
<h5 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h5><p>整体感觉很传统，很冗长。</p>
<h4 id="现在的小明"><a href="#现在的小明" class="headerlink" title="现在的小明"></a>现在的小明</h4><p><img src="https://img.mynamecoder.com/20200413002247.png"></p>
<h5 id="点评-1"><a href="#点评-1" class="headerlink" title="点评"></a>点评</h5><p>整体感觉很轻巧，很优雅。</p>
<h2 id="4-还可以控制多个资源哦"><a href="#4-还可以控制多个资源哦" class="headerlink" title="4. 还可以控制多个资源哦"></a>4. 还可以控制多个资源哦</h2><p>如果我们想一边控制输入、一边控制输出怎么办？</p>
<p>通通放进去！如图所示</p>
<p><img src="https://img.mynamecoder.com/20200413002320.png"></p>
<h2 id="5-幕后功臣：Closeable"><a href="#5-幕后功臣：Closeable" class="headerlink" title="5.幕后功臣：Closeable"></a>5.幕后功臣：Closeable</h2><p>为什么把资源放进<strong>try-with-resources</strong>，我们就可以束手旁观，高枕无忧呢？原来，要想合法进去<strong>try-with-resources</strong>，不被报警，是需要门票的：实现<strong>Closeable</strong>或<strong>AutoCloseable</strong>接口，并重写<strong>close</strong>方法。就像这样：</p>
<p><img src="https://img.mynamecoder.com/20200413002404.png"></p>
<h2 id="6-多个资源的情况下如何顺序关闭呢？"><a href="#6-多个资源的情况下如何顺序关闭呢？" class="headerlink" title="6.多个资源的情况下如何顺序关闭呢？"></a>6.多个资源的情况下如何顺序关闭呢？</h2><blockquote>
<p>剧透：先创建的资源，最后关闭。</p>
</blockquote>
<p>这个故事是这样讲的：小明和小红一起打王者荣耀……</p>
<h5 id="小明"><a href="#小明" class="headerlink" title="小明:"></a>小明:</h5><p><img src="https://img.mynamecoder.com/20200413002436.png"></p>
<h5 id="小红"><a href="#小红" class="headerlink" title="小红:"></a>小红:</h5><p><img src="https://img.mynamecoder.com/codeimg-facebook-shared-image.jpeg"></p>
<h5 id="全军出击"><a href="#全军出击" class="headerlink" title="全军出击:"></a>全军出击:</h5><p><img src="https://img.mynamecoder.com/20200413002515.png"></p>
<h5 id="故事纵览"><a href="#故事纵览" class="headerlink" title="故事纵览:"></a>故事纵览:</h5><p><img src="https://img.mynamecoder.com/20200413002554.png"></p>
<p>提问：结局是不是和剧透一致？</p>
<h2 id="7-补充"><a href="#7-补充" class="headerlink" title="7. 补充"></a>7. 补充</h2><p>我们使用<strong>try-with-resources</strong>的时候不仅可以优雅地释放资源，而且还可以传统一些，照常使用<strong>catch</strong>和<strong>finally</strong>哦。</p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>经过小明这么一番生动的讲解：</p>
<p>你是否知道了什么是<strong>try-with-resources</strong>？</p>
<p>你是否知道了如何用<strong>try-with-resources</strong>替换<strong>try-catch-finally</strong>？</p>
<p>你是否知道了<strong>AutoCloseable</strong>构建自定义资源以及关闭资源的顺序？</p>
<blockquote>
<p>附Github源码地址:<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming" >https://github.com/WhenCoding/coder-xiaoming<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac使用iTerm2 一键免密登录</title>
    <url>/p/4298.html</url>
    <content><![CDATA[<blockquote>
<p>iTerm是mac平台很好用的ssh管理工具，今天给大家介绍一种使用iTerm一键登陆服务器优雅的方式，这样就不需要每次连接服务器时都需要输入端口号、用户名、ip地址、密码（为了安全，服务器密码都好长好长）。</p>
</blockquote>
<a id="more"></a>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>我们先准备一个脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;expect</span><br><span class="line"></span><br><span class="line">set timeout 30</span><br><span class="line">spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]</span><br><span class="line">expect &#123;</span><br><span class="line">        &quot;(yes&#x2F;no)?&quot;</span><br><span class="line">        &#123;send &quot;yes\n&quot;;exp_continue&#125;</span><br><span class="line">        &quot;password:&quot;</span><br><span class="line">        &#123;send &quot;[lindex $argv 3]\n&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>
<p>这个脚本需要传入服务器的四个参数：端口号、服务器用户名、服务器地址 、对应用户名的密码 。</p>
<blockquote>
<p>当我们看懂这个脚本后，其实就可以简化一下，比如服务器ssh端口号默认为22，因此有时候不需要指定端口的情况下，就可以在脚本中删除<code>-p [lindex $argv 0]</code>,同时记得修改后面argv的索引，比如argv1 改为 argv0，以此类推，不过为了保证脚本的通用性，不推荐大家这样做，因为为了服务器安全，避免被暴力破解，服务器是不使用默认的22端口号的。</p>
</blockquote>
<p>接下来我们把这个脚本放到<code>$PATH</code> 下，这样就可以直接使用这个脚本（不用通过文件路径就可以直接使用，像<code>/usr/local/bin/</code>、<code>/usr/bin</code>下面的命令），因此小明建议直接放<code>/usr/local/bin</code>下面，也可以通过命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>
<p>查看一下你自己的<strong>PATH</strong>路径，小明的<strong>PATH</strong>路径如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin</span><br></pre></td></tr></table></figure>
<p>然后我们使用<code>chmod</code>让文件变成可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod +x login.exp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：最新Mac os 可能对这些目录权限限制比较严格，因此需要sudo 才能成功</p>
</blockquote>
<h2 id="配置iTerm2"><a href="#配置iTerm2" class="headerlink" title="配置iTerm2"></a>配置iTerm2</h2><p>我们打开iTerm2-&gt;菜单Profiles-&gt;Open Profiles-&gt;Edit Profiles，如下所示：</p>
<p><img src="https://s2.ax1x.com/2019/11/26/MzRGr9.png" alt="配置profile"></p>
<p>红色标注的命令就是我们要连接服务器的配置信息，按着顺序输入即可。下次我们就可以在<strong>Profiles</strong>下面一键连接自己的服务器啦。另外，我们可以使用<strong>Tags</strong>标注该服务器，在服务器比较多的场景下（小明公司的服务器就比较多）就能很快找到自己想要的服务器。今天的Mac 使用 iTerm2文章就分享到这里啦，小伙伴们有什么问题都可以在下方留言！</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title>Linux服务器的晴雨表——top命令</title>
    <url>/p/35755.html</url>
    <content><![CDATA[<blockquote>
<p> 虽然之前一直在使用top命令，但是并没有像今天这样认真细致总结每条数据代表的含义。</p>
</blockquote>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Liunx系统下输入下面这条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>日常开发中熟悉的视图再次映入眼底：<br><img src="https://img.mynamecoder.com/20200807152926.png"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>视图前五行是当前系统情况整体的统计信息区。</p>
<h3 id="统计信息区"><a href="#统计信息区" class="headerlink" title="统计信息区"></a>统计信息区</h3><p><img src="https://img.mynamecoder.com/20200807152503.png" alt="统计信息区"></p>
<h4 id="第一行-任务队列信息"><a href="#第一行-任务队列信息" class="headerlink" title="第一行: 任务队列信息"></a>第一行: 任务队列信息</h4><p>同<code>uptime</code> 命令的执行结果相同，具体参数说明情况如下：</p>
<ul>
<li><p><strong>14:04:16</strong> — 当前系统时间</p>
</li>
<li><p><strong>up 145 days</strong>, 14:24 — 系统已经运行了145天14小时24分钟（在这期间系统没有重启过）</p>
</li>
<li><p><strong>1 user</strong> — 当前有1个用户登录系统</p>
</li>
<li><p><strong>load average: 1.15, 1.42, 1.44</strong> — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
</li>
<li><p><strong>load average</strong>数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
</li>
</ul>
<h4 id="第二行-Tasks-—-任务（进程）"><a href="#第二行-Tasks-—-任务（进程）" class="headerlink" title="第二行: Tasks — 任务（进程）"></a>第二行: Tasks — 任务（进程）</h4><p>系统现在共有447个进程，其中处于运行中的有1个，445个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有1个。</p>
<h4 id="第三行-cpu状态信息"><a href="#第三行-cpu状态信息" class="headerlink" title="第三行: cpu状态信息"></a>第三行: cpu状态信息</h4><ul>
<li>*<em>40.1%us **— 用户空间占用CPU的百分比（</em>user cpu time*）。</li>
<li><strong>9.7% sy</strong> — 内核空间占用CPU的百分比（<em>system cpu time</em>）。</li>
<li><strong>0.0% ni</strong> — 改变过优先级的进程占用CPU的百分比（<em>user nice cpu time</em>）</li>
<li><strong>48.9% id</strong> — 空闲CPU百分比（<em>idle cpu time</em>）</li>
<li><strong>0.2% wa</strong> — IO等待占用CPU的百分比（<em>io wait cpu time</em>）</li>
<li><strong>0.0% hi</strong> — 硬中断占用CPU的百分比（<em>hardware irq</em>）</li>
<li><strong>1.0% si</strong> — 软中断占用CPU的百分比（<em>software irq</em>）</li>
<li><strong>0.0% st</strong> — “窃取时间”仅与虚拟化环境相关。它表示真正的CPU对当前虚拟机不可用的时间-虚拟机管理程序从该VM“偷走”了该CPU（用于运行另一个VM，或用于其自身需求）（<em>steal time</em>）<blockquote>
<p> 备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p>
</blockquote>
</li>
</ul>
<h4 id="第四行-内存状态"><a href="#第四行-内存状态" class="headerlink" title="第四行: 内存状态"></a>第四行: 内存状态</h4><ul>
<li><p><strong>13175904+ total</strong> — 物理内存总量（130GB）</p>
</li>
<li><p><strong>52304008 free</strong> — 空闲内存总量（52GB）</p>
</li>
<li><p><strong>78647840 used</strong> — 使用中的内存总量（78GB）</p>
</li>
<li><p><strong>807188 buffer/cache</strong> — 缓存的内存量 （807M）</p>
<h4 id="第五行-swap交换分区信息"><a href="#第五行-swap交换分区信息" class="headerlink" title="第五行: swap交换分区信息"></a>第五行: swap交换分区信息</h4><blockquote>
<p> 在Linux中，内存一共分为两块：物理内存 和 交换区。物理内存是真正的内存，而内存资源毕竟有限，因此当物理内存不够的时候，根据LRU置换算法，那些很长时间没被使用的数据将会被存入交换区。交换区其实是硬盘，并非内存。当交换区存在数据时说明物理内存不够了。</p>
</blockquote>
</li>
<li><p><strong>10485756 total</strong> — 交换区总量（10GB）</p>
</li>
<li><p><strong>6848920 free</strong> — 空闲交换区总量（6GB）</p>
</li>
<li><p><strong>3636836 used</strong> — 使用的交换区总量（3GB）</p>
</li>
<li><p><strong>52299332k avail Mem</strong> — 虚拟内存总量（3.6GB）</p>
</li>
</ul>
<p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。<br>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的avail Mem，按这个公式此台服务器的可用内存。<br>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>
<h3 id="进程状态监控"><a href="#进程状态监控" class="headerlink" title="进程状态监控"></a>进程状态监控</h3><p><img src="https://img.mynamecoder.com/20200807164905.png"></p>
<ul>
<li><strong>PID</strong> — 进程id</li>
<li><strong>USER</strong> — 进程所有者</li>
<li><strong>PR</strong> — 进程优先级</li>
<li><strong>NI</strong> — nice值。负值表示高优先级，正值表示低优先级</li>
<li><strong>VIRT</strong> — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li>
<li><strong>RES</strong> — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li>
<li><strong>SHR</strong> — 共享内存大小，单位kb</li>
<li><strong>S</strong> — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li>
<li><strong>%CPU</strong> — 上次更新到现在的CPU时间占用百分比</li>
<li><strong>%MEM</strong> — 进程使用的物理内存百分比</li>
<li><strong>TIME+</strong> — 进程使用的CPU时间总计，单位1/100秒</li>
<li><strong>COMMAND</strong> — 进程名称（命令名/命令行）<h3 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h3><h4 id="多U多核CPU监控"><a href="#多U多核CPU监控" class="headerlink" title="多U多核CPU监控"></a>多U多核CPU监控</h4></li>
<li>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况。再按数字键1，就会返回到top基本视图界面。<br><img src="https://img.mynamecoder.com/20200807172205.png"><br>可以看到，服务器有40个逻辑CPU，但实际上是2个物理cpu。我们通过如下命令查看物理CPU个数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep &quot;physical id&quot; | sort | uniq</span><br></pre></td></tr></table></figure>
<img src="https://img.mynamecoder.com/20200807172539.png"><br>有几个不一样的<strong>physical id</strong>就代表有几个物理cpu。<h4 id="显示完整命令"><a href="#显示完整命令" class="headerlink" title="显示完整命令"></a>显示完整命令</h4>使用如下命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure>
即可显示命令名称和完整命令行<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>可以看出，<strong>top</strong>虽然简短（容易记住），却“神通广大”，可以帮助我们迅速掌握当前Linux系统运行状况，是一个不可多得的命令，大家日常开发中可以将其作为随身利器乘风破浪，披荆斩棘。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装Homebrew的那些事儿</title>
    <url>/p/75a0.html</url>
    <content><![CDATA[<blockquote>
<p>最近小明刚换置了一个 Mac 本，想搭建一个属于自己的博客网站，需要用到 Node.js 环境，而Node.js 在 MacOS 中是由 Homebrew 进行安装管理的……因此，便有了Homebrew的安装历程。</p>
</blockquote>
<h2 id="什么是Homebrew"><a href="#什么是Homebrew" class="headerlink" title="什么是Homebrew?"></a>什么是Homebrew?</h2><p>简而言之，Homebrew是Mac Os的包管理工具，相当于Redhat Linux(Centos/RHEL/Fedora)的<code>yum</code>或者Debian Linux(Debian/Ubuntu)的<code>apt-get</code>。</p>
<h2 id="如何安装Homebrew？"><a href="#如何安装Homebrew？" class="headerlink" title="如何安装Homebrew？"></a>如何安装Homebrew？</h2><p>我们使用官网提供的统一安装方法，只需执行下面的命令即可</p>
<blockquote>
<p>因为这个链接随时可能会更新，所以还是建议去<a class="link"   href="https://brew.sh/index_zh-cn" >官网首页<i class="fas fa-external-link-alt"></i></a>确认一下这个命令，如果显示超时，可以尝试将脚本下载到本地，再执行命令。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>Ruby</em> 是一种开源的面向对象程序设计的服务器端脚本语言，Mac上默认已经给我们安装好了。一段漫长的时间过后，当出现**Installation successful!**提示时就表示已经安装成功。</p>
<p>如果文章到此结束，那这篇文章的价值也太低了吧。接下来给大家扩展一下。</p>
<h2 id="安装时可能遇到的问题"><a href="#安装时可能遇到的问题" class="headerlink" title="安装时可能遇到的问题"></a>安装时可能遇到的问题</h2><h3 id="读写权限不够"><a href="#读写权限不够" class="headerlink" title="读写权限不够"></a>读写权限不够</h3><p>小明安装的时候遇到一个问题就是出现如下的提示，表明当前用户权限不够：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch: &#x2F;Users&#x2F;xiaoming&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;.cleaned: Permission denied</span><br></pre></td></tr></table></figure>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>需要超级管理员（root）赋予权限，执行以下的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R $&#123;USER&#125; &#x2F;Users&#x2F;xiaoming&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;</span><br></pre></td></tr></table></figure>
<p>根据提示输入密码即可。</p>
<blockquote>
<p><code>chown</code>指令是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。表示使用root用户赋予当前用户对该目录的操作权限。</p>
</blockquote>
<h2 id="如何提高brew安装软件的速度？"><a href="#如何提高brew安装软件的速度？" class="headerlink" title="如何提高brew安装软件的速度？"></a>如何提高brew安装软件的速度？</h2><p>当我们一路披荆斩棘或者顺风顺水安装成功brew过后，即可执行自己为所欲为安装自己想要的软件，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<p>但是好像有点不妙，执行命令过后，下载安装的速度怎么这么感人？发现问题是一个很好的开始，有强迫症的小明第一时间就在网上搜集各种资料，一边享受着互联网时代的福祉，一边自己不停的踩坑，经历过数次<strong>下载-安装-卸载</strong>过后终于从坑里成功爬出。</p>
<h3 id="更换Bottles源"><a href="#更换Bottles源" class="headerlink" title="更换Bottles源"></a>更换Bottles源</h3><p>Homebrew 安装的软件默认都在以下目录中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Cellar</strong>意为酒窖、地窖，⽽Homebrew官⽅预先编译好的⼀个软件叫做⼀个 Bottle(酒瓶⼦)，Bottles就是很多酒瓶⼦(即软件)，Homebrew把安装⼀个软件叫做把⼀个酒瓶⼦放到酒窖(地窖)⾥（不过其实是pour，即倒到酒窖⾥）。</p>
</blockquote>
<p>Homebrew官⽅的软件（即Bottles）是放在 <a class="link"   href="https://bintray.com/" >bintray<i class="fas fa-external-link-alt"></i></a>⽹站中的，因为是国外⽹站及众所周知的原因，如果直接从这⾥下载是⾮常慢的，所以我们还是要把它换成国内的源（由中科⼤提供）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;export HOMEBREW_BOTTLE_DOMAIN&#x3D;https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;homebrew-bottles&#39; &gt;&gt; ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
<p>该命令执行过后，我们就可以体验一下飞一般的速度了～嗖嗖嗖～</p>
<p>等一下（尔康表情包），顺便再提一嘴，明哥经常用到的几个命令吧。</p>
<h2 id="brew几个基本使用命令"><a href="#brew几个基本使用命令" class="headerlink" title="brew几个基本使用命令"></a>brew几个基本使用命令</h2><ul>
<li><p>查询软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew search 软件名</span><br></pre></td></tr></table></figure></li>
<li><p>安装软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install 软件名</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>启动|停止|重启软件</p>
<p>对于需要在后台运行的软件，大部分可用以下方式启动|停止|重启（它的原理是用launchctl+plist，用这种方式启动的软件重启电脑后也会自动启动）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start|stop|restart 软件名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于brew services的原理及详细用法，大家可以查看：Mac服务管理 – launchd、launchctl、LaunchAgent、LaunchDaemon、brew services详解。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>卸载软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall 软件名</span><br></pre></td></tr></table></figure></li>
<li><p>查看软件的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info 软件名</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>查看安装了哪些软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew list 软件名</span><br></pre></td></tr></table></figure></li>
<li><p>查看安装了哪些软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew list 软件名</span><br></pre></td></tr></table></figure></li>
<li><p>查看帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew help</span><br></pre></td></tr></table></figure>
<p>以上就是brew常用的几个命令，最后的最后再说一下，再多提一嘴，如何和优雅地和brew说分手。</p>
</li>
</ul>
<h2 id="我用brew干什么"><a href="#我用brew干什么" class="headerlink" title="我用brew干什么"></a>我用brew干什么</h2><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>mac解压zip毫无压力，但是总是有些同事会发给你一些rar文件，我们就可以通过使用<strong>urar</strong>这个工具解压文件</p>
<h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install unrar</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>打开终端，cd到要解压文件的目录下，然后在终端输入下列命令即可，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unrar x 压缩文件.rar</span><br></pre></td></tr></table></figure>
<p>此时 .rar 文件与 解压的文件夹在同一目录下（解压出来的文件所在目录和命令行执行目录一致）。</p>
<h2 id="卸载brew"><a href="#卸载brew" class="headerlink" title="卸载brew"></a>卸载brew</h2><p>因为一开始我们使用的是官方安装方式，因此好聚好散，我们还是使用官方的卸载方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;homebrew&#x2F;brew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;  </span><br></pre></td></tr></table></figure>
<p>执行过后，一切宛如初见～</p>
<p>各位，祝好。有什么问题记得留言哈。</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装破解Navicat</title>
    <url>/p/2246.html</url>
    <content><![CDATA[<blockquote>
<p>本文目的如题，navicat 优点不再赘述。如有侵权，请联系我立即删除。</p>
</blockquote>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>Mac版 Navicat Premium 12 v12.0.23.0 官网下载地址：</p>
<p>英文64位 <a class="link"   href="http://download.navicat.com/download/navicat120_premium_en.dmg" >http://download.navicat.com/download/navicat120_premium_en.dmg<i class="fas fa-external-link-alt"></i></a><br>中文简体64位 <a class="link"   href="http://download.navicat.com/download/navicat120_premium_cs.dmg" >http://download.navicat.com/download/navicat120_premium_cs.dmg<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p><strong>注意</strong>：我没有下载最新版本的navicat，因为上面那个版本比较稳定，而且我用起来挺舒服的。当然最主要的原因是：本文的破解方式也只是针对该版本，并不支持最新版本（后续待更新）。</p>
</blockquote>
<h2 id="生成自己的RSA公钥私钥对"><a href="#生成自己的RSA公钥私钥对" class="headerlink" title="生成自己的RSA公钥私钥对"></a>生成自己的RSA公钥私钥对</h2><p>为了节省时间，大家可以使用我提供的一对密钥。</p>
<h3 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBITANBgkqhkiG9w0BAQEFAAOCAQ4AMIIBCQKCAQB8vXG0ImYhLHvHhpi5FS3g</span><br><span class="line">d2QhxSQiU6dQ04F1OHB0yRRQ3NXF5py2NNDw962i4WP1zpUOHh94&#x2F;mg&#x2F;KA8KHNJX</span><br><span class="line">HtQVLXMRms+chomsQCwkDi2jbgUa4jRFN&#x2F;6N3QejJ42jHasY3MJfALcnHCY3KDEF</span><br><span class="line">h0N89FV4yGLyDLr+TLqpRecg9pkPnOp++UTSsxz&#x2F;e0ONlPYrra&#x2F;DiaBjsleAESZS</span><br><span class="line">I69sPD9xZRt+EciXVQfybI&#x2F;2SYeAdXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd</span><br><span class="line">+03NU3wvEmLBvGOmNGudocWIF&#x2F;y3VOqyW1byXFLeZxl7s+Y&#x2F;SthxOYXzu3mF+2&#x2F;p</span><br><span class="line">AgMBAAE&#x3D;</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
<h3 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIEogIBAAKCAQB8vXG0ImYhLHvHhpi5FS3gd2QhxSQiU6dQ04F1OHB0yRRQ3NXF</span><br><span class="line">5py2NNDw962i4WP1zpUOHh94&#x2F;mg&#x2F;KA8KHNJXHtQVLXMRms+chomsQCwkDi2jbgUa</span><br><span class="line">4jRFN&#x2F;6N3QejJ42jHasY3MJfALcnHCY3KDEFh0N89FV4yGLyDLr+TLqpRecg9pkP</span><br><span class="line">nOp++UTSsxz&#x2F;e0ONlPYrra&#x2F;DiaBjsleAESZSI69sPD9xZRt+EciXVQfybI&#x2F;2SYeA</span><br><span class="line">dXMm1B7tHCcFlOxeUgqYV03VEqiC0jVMwRCd+03NU3wvEmLBvGOmNGudocWIF&#x2F;y3</span><br><span class="line">VOqyW1byXFLeZxl7s+Y&#x2F;SthxOYXzu3mF+2&#x2F;pAgMBAAECggEAK5qZbYt8wenn1uZg</span><br><span class="line">6onRwJ5bfUaJjApL+YAFx&#x2F;ETtm83z9ByVbx4WWT7CNC7fK1nINy20&#x2F;mJrOTZkgIx</span><br><span class="line">x6otiNC4+DIsACJqol+RLoo8I9pk77Ucybn65ZteOz7hVZIU+8j6LzW0KDt6yowX</span><br><span class="line">e75r7G&#x2F;NEpfibNc3Zz81+oDd2x+bHyGbzc9QcePIVuEzkof6jgpbWrQZU14itx9l</span><br><span class="line">VxEgj&#x2F;fbMccvBx8brR&#x2F;l9ClmDZd9Y6TWsF1rfJpF3+DPeqFkKCiD7PGz3bs4O&#x2F;Zd</span><br><span class="line">ZrfV21ZNVusBW49G6bU63gQVKsOf1qGo3efbAW1HVxgTQ&#x2F;lExVdcMvdenZm+ADKp</span><br><span class="line">L4&#x2F;wUQKBgQDOfBjn3OC2IerUFu18EgCS7pSjTSibXw+TeX3D5zwszLC091G2rGlT</span><br><span class="line">5DihBUhMfesNdpoZynrs4YB6Sz9C3wSGAB8AM&#x2F;tNvPhtSVtbMHmrdT2DEEKCvLkO</span><br><span class="line">RNBnt+8aTu2hGRanw9aL1189gzwrmXK5ZuuURfgLrB9ihrvjo4VznQKBgQCapx13</span><br><span class="line">dEA1MwapBiIa3k8hVBCoGPsEPWqM33RBdUqUsP33f9&#x2F;PCx00j&#x2F;akwmjgQNnBlAJo</span><br><span class="line">Y7LOqPCyiwOkEf40T4IlHdzYntWQQvHhfBwqSgdkTE9tKj43Ddr7JVFRL6yMSbW3</span><br><span class="line">9qAp5UX&#x2F;+VzOLGAlfzJ8CBnkXwGrnKPCVbnZvQKBgQCd+iof80jlcCu3GteVrjxM</span><br><span class="line">LkcAbb8cqG1FWpVTNe4&#x2F;JFgqDHKzPVPUgG6nG2CGTWxxv4UFKHpGE&#x2F;11E28SHYjb</span><br><span class="line">cOpHAH5LqsGy84X2za649JkcVmtclUFMXm&#x2F;Ietxvl2WNdKF1t4rFMQFIEckOXnd8</span><br><span class="line">y&#x2F;Z&#x2F;Wcz+OTFF82l7L5ehrQKBgFXl9m7v6e3ijpN5LZ5A1jDL0Yicf2fmePUP9DGb</span><br><span class="line">ZTZbbGR46SXFpY4ZXEQ9GyVbv9dOT1wN7DXvDeoNXpNVzxzdAIt&#x2F;H7hN2I8NL+4v</span><br><span class="line">EjHG9n4WCJO4v9+yWWvfWWA&#x2F;m5Y8JqusV1+N0iiQJ6T4btrE4JSVp1P6FSJtmWOK</span><br><span class="line">W&#x2F;T9AoGAcMhPMCL+N+AvWcYt4Y4mhelvDG8e&#x2F;Jj4U+lwS3g7YmuQuYx7h5tjrS33</span><br><span class="line">w4o20g&#x2F;3XudPMJHhA3z+d8b3GaVM3ZtcRM3+Rvk+zSOcGSwn3yDy4NYlv9bdUj&#x2F;4</span><br><span class="line">H+aU1Qu1ZYojFM1Gmbe4HeYDOzRsJ5BhNrrV12h27JWkiRJ4F&#x2F;Q&#x3D;</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<h2 id="安装程序，并替换应用包内容目录中rpk文件的公钥"><a href="#安装程序，并替换应用包内容目录中rpk文件的公钥" class="headerlink" title="安装程序，并替换应用包内容目录中rpk文件的公钥"></a>安装程序，并替换应用包内容目录中rpk文件的公钥</h2><p>安装完毕后打开finder，找到应用程序，右键显示包内容，打开目录 /Contents/Resources，编辑<strong>rpk</strong>文件，将<strong>公钥</strong>替换并保存。</p>
<h2 id="解密请求码，生成激活码"><a href="#解密请求码，生成激活码" class="headerlink" title="解密请求码，生成激活码"></a>解密请求码，生成激活码</h2><ol>
<li><p>打开应用，<strong>断网</strong>，点击注册，输入密钥 <code>NAVH-T4PX-WT8W-QBL5</code>，然后选择手动激活。</p>
</li>
<li><p>复制请求码，根据私钥解密请求码（弹框显示），得到激活码明文<br>注意必须自己解密，因为解密后得到的“DI”是不同的<br>激活码明文示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;K&quot; : &quot;NAVHT4PXWT8WQBL5&quot;,</span><br><span class="line">  &quot;P&quot; : &quot;Mac 10.13&quot;,</span><br><span class="line">  &quot;DI&quot; : &quot;ODQ2Yjg2ZDBjMTEzMjhh&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附上在线RSA私钥解密网址：<a class="link"   href="http://tool.chacuo.net/cryptrsaprikey" >http://tool.chacuo.net/cryptrsaprikey<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>将得到的激活码明文进行修改，修改后格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;K&quot;:&quot;NAVHT4PXWT8WQBL5&quot;, &quot;N&quot;:&quot;xiaoming&quot;, &quot;O&quot;:&quot;xiaoming&quot;, &quot;DI&quot;:&quot;ODQ2Yjg2ZDBjMTEzMjhh&quot;, &quot;T&quot;:1516939200&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：上面的<code>&quot;P&quot;</code>没有了，激活码明文格式最好复制我的，改变 ” ” 内的字符即可，在同一行哦，不要换行，否则激活失败！！！ <code>“K”</code> <code>“DI”</code> 都替换成自己机器解密的信息，<code>”N”</code> <code>“O”</code> 可以自己定义（比如，小明为了表明是自己整理的，就填上了xiaoming）。<code>&quot;T&quot;</code> 这个Unix时间戳一定要使用当天的。比如你激活那一天是2018/08/19，你就需要去生成一个2018/08/19 00:00:00（时分秒无所谓）的时间戳，替换那个<code>&quot;T&quot;</code>之后，再去加密，即可顺利激活。</p>
<p>附上转换时间戳的的地址：<a class="link"   href="http://tool.chinaz.com/Tools/unixtime.aspx" >http://tool.chinaz.com/Tools/unixtime.aspx<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>加密激活码明文，使用私钥加密激活码明文。</p>
<p>再次附上在线RSA私钥解密网址：<a class="link"   href="http://tool.chacuo.net/cryptrsaprikey" >http://tool.chacuo.net/cryptrsaprikey<i class="fas fa-external-link-alt"></i></a></p>
<p>复制加密后激活码信息到程序激活窗口，点击激活，即可成功激活！</p>
</li>
</ol>
<p>   <strong>大家有什么问题都可以随时留言哈～</strong></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置upstream实现负载均衡</title>
    <url>/p/bf32.html</url>
    <content><![CDATA[<blockquote>
<p>今天小明试了一把运维的活，通过配置nginx upstream模块，实现访问不同的域名地址指向不同端口（不用对外报漏应用程序的端口号）。具体操作如下：<br>Nginx能够配置代理多台服务器。当一台服务器宕机之后。仍能保持系统可用。详细配置步骤如下：</p>
</blockquote>
<ul>
<li>在http节点下，加入upstream节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream direct_server &#123; </span><br><span class="line">      server 10.0.6.108:7080; # 可以指向本地服务器或者远程服务器</span><br><span class="line">      server 10.0.0.85:8980;  # 配置多个可以实现负载均衡</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将server节点下的location节点中的proxy_pass配置为：http:// + upstream名称，即“<a class="link"   href="http://direct_server”/" >http://direct_server”<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.mynamecoder.com; # 根据你的访问域名设置</span><br><span class="line">    location &#x2F; &#123; </span><br><span class="line">            root  html; </span><br><span class="line">            index  index.html index.htm; </span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;direct_server; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如今负载均衡初步完毕了。upstream依照轮询（默认）方式进行负载，每一个请求按时间顺序逐一分配到不同的后端服务器。假设后端服务器down掉。能自己主动剔除。尽管这样的方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。适用于图片服务器集群和纯静态页面服务器集群。</p>
<p>除此之外，upstream还有其他的分配策略，分别例如以下：</p>
<ul>
<li>weight（权重）<br>指定轮询几率，weight和訪问比率成正比，用于后端服务器性能不均的情况。例如以下所看到的。10.0.0.88的訪问比率要比10.0.0.77的訪问比率高一倍。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream direct_server&#123; </span><br><span class="line">      server 10.0.0.77 weight&#x3D;5; </span><br><span class="line">      server 10.0.0.88 weight&#x3D;10; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ip_hash（访问ip）</li>
</ul>
<p>每一个请求按访问ip的hash结果分配。这样每一个訪客固定訪问一个后端服务器，能够解决session的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream favresin&#123; </span><br><span class="line">      ip_hash; </span><br><span class="line">      server 10.0.0.10:8080; </span><br><span class="line">      server 10.0.0.11:8080; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fair（第三方）</li>
</ul>
<p>按后端服务器的响应时间来分配请求。响应时间短的优先分配。</p>
<p>与weight分配策略相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream favresin&#123;      </span><br><span class="line">      server 10.0.0.10:8080; </span><br><span class="line">      server 10.0.0.11:8080; </span><br><span class="line">      fair; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>url_hash（第三方）</li>
</ul>
<p>按訪问url的hash结果来分配请求，使每一个url定向到同一个后端服务器。后端服务器为缓存时比較有效。</p>
<p>注意：在upstream中加入hash语句。server语句中不能写入weight等其他的參数，hash_method是使用的hash算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream resinserver&#123; </span><br><span class="line">      server 10.0.0.10:7777; </span><br><span class="line">      server 10.0.0.11:8888; </span><br><span class="line">      hash $request_uri; </span><br><span class="line">      hash_method crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为每一个设备设置状态值"><a href="#为每一个设备设置状态值" class="headerlink" title="为每一个设备设置状态值"></a>为每一个设备设置状态值</h2><p>这些状态值的含义分别例如以下：</p>
<ul>
<li><p>down 表示单前的server临时不參与负载.</p>
</li>
<li><p>weight 默觉得1.weight越大，负载的权重就越大。</p>
</li>
<li><p>max_fails ：同意请求失败的次数默觉得1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</p>
</li>
<li><p>fail_timeout : max_fails次失败后。暂停的时间。</p>
</li>
<li><p>backup： 其他全部的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream bakend&#123; #定义负载均衡设备的Ip及设备状态 </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 10.0.0.11:9090 down; </span><br><span class="line">    server 10.0.0.11:8080 weight&#x3D;2; </span><br><span class="line">    server 10.0.0.11:6060; </span><br><span class="line">    server 10.0.0.11:7070 backup; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是小明配置负载均衡时遇到的一点小总结，和大家一块分享一下，希望可以帮助到大家。</p>
<h2 id="关注微信公众号，获取更多资源"><a href="#关注微信公众号，获取更多资源" class="headerlink" title="关注微信公众号，获取更多资源"></a>关注微信公众号，获取更多资源</h2><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="关注公众号"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot:如何优雅地处理全局异常？</title>
    <url>/p/de65.html</url>
    <content><![CDATA[<blockquote>
<p>之前用springboot的时候，只知道捕获异常使用try{}catch，一个接口一个try{}catch，这也是大多数开发人员异常处理的常用方式，虽然屡试不爽，但会造成一个问题，就是一个Controller下面，满屏幕的try{}catch，看着一点都不优雅，一点都不符合小明的气质，憋了这么久，小明今天终于决定对所有异常实施统一处理的方案。</p>
</blockquote>
<h3 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h3><p>JDK8、正常的springboot项目</p>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><h4 id="通用异常处理"><a href="#通用异常处理" class="headerlink" title="通用异常处理"></a>通用异常处理</h4><p>其实Spring系列的项目全局异常处理方式早已存在，只不过我们一直忙于搬砖，很少停下脚步去审视这个日夜与我们相伴的朋友。为了贴合主题，本次主要针对SpringBoot全局异常处理进行举例说明。</p>
<p>SpringBoot中有一个<code>@ControllerAdvice</code>的注解，使用该注解即表示开启全局异常捕获，接下来我们只需在自定义的方法上使用<code>@ExceptionHandler</code>注解，并定义捕获异常的类型，对这种类型的异常进行统一的处理。</p>
<p><strong>举个例子:</strong></p>
<p>假如我们需要针对NullException（空指针异常，是Java程序员最痛恨的异常，没有之一）进行全局处理（如下所示）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">		&#x2F;**</span><br><span class="line">     * 处理空指针的异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D;NullPointerException.class)</span><br><span class="line">    public BaseResponseFacade exceptionHandler(HttpServletRequest req, NullPointerException e)&#123;</span><br><span class="line">        log.error(&quot;发生空指针异常！原因是:&quot;,e);</span><br><span class="line">        return ResponseUtil.error(ResponseCode.ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讷，就这么简单。其他可能发生的异常，都可以以这种方式处理快速处理。此处大家应该表现的十分兴奋，但请不要高兴太早，因为接下来，有更令激动人心的事情。</p>
<h4 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h4><h5 id="自定义一个异常"><a href="#自定义一个异常" class="headerlink" title="自定义一个异常"></a>自定义一个异常</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Description 自定义异常</span><br><span class="line"> * @Date 2019-08-05 15:49</span><br><span class="line"> * @Created by 程序员小明</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Accessors(chain &#x3D; true)</span><br><span class="line">public class BizException extends RuntimeException &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 错误码</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Integer errorCode;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 错误信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected String errorMsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见，这个异常继承了<code>RuntimeException</code>，属于运行时异常。细心的朋友已经发现，我使用了Lombok插件，非常契合今天的主题，给大家简单介绍一下：</p>
<blockquote>
<p>lombok是一个可以帮助我们简化java代码编写的工具类，尤其是简化javabean的编写，即通过采用注解的方式，消除代码中的构造方法，getter/setter等代码，使我们写的类更加简洁（如果使用的IDE是idea，需要安装插件哈）。</p>
</blockquote>
<p>定义过之后，我们就可以和之前处理NullException方式一样处理我们自定义的异常。包括处理其他异常，都是这种方式。直接贴代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理自定义的业务异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D; BizException.class)</span><br><span class="line">    public BaseResponseFacade bizExceptionHandler(HttpServletRequest req, BizException e)&#123;</span><br><span class="line">        log.error(&quot;发生业务异常！原因是：&#123;&#125;&quot;,e.getErrorMsg());</span><br><span class="line">        return ResponseUtil.error(e.getErrorCode(),e.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理空指针的异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D;NullPointerException.class)</span><br><span class="line">    public BaseResponseFacade exceptionHandler(HttpServletRequest req, NullPointerException e)&#123;</span><br><span class="line">        log.error(&quot;发生空指针异常！原因是:&quot;,e);</span><br><span class="line">        return ResponseUtil.error(ResponseCode.ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理其他异常</span><br><span class="line">     * @param req</span><br><span class="line">     * @param e</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @ExceptionHandler(value &#x3D;Exception.class)</span><br><span class="line">    public BaseResponseFacade exceptionHandler(HttpServletRequest req, Exception e)&#123;</span><br><span class="line">        log.error(&quot;未知异常！原因是:&quot;,e);</span><br><span class="line">        return ResponseUtil.error(ResponseCode.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整个全局异常处理方式核心就是以上介绍这些。下面用一个Demo给大家举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">public BaseResponseFacade test()&#123;</span><br><span class="line">  if(true)&#123;</span><br><span class="line">  	throw new BizException(1,&quot;error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return ResponseUtil.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>地址栏请求，进入这个方法后，会抛出异常，此时全局异常生效，就会返回异常处理过后的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errorCode&quot;:1,&quot;errorMsg&quot;:&quot;error&quot;,&quot;data&quot;:null&#125;</span><br></pre></td></tr></table></figure>
<p>到此整个流程都然跑通了。当然，好多地方都可以根据我们自身实际业务情况以此为基础进一步丰富，比如返回数据可以改成跳转某一个具体的页面。这样的出场方式是不是都很优雅？大家有什么问题，期待各位留言。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>@NotNull</title>
    <url>/p/bf38.html</url>
    <content><![CDATA[<blockquote>
<p>摘自 <a class="link"   href="https://zaizai2013.iteye.com/blog/2352683"  title="Java中的注解 - @NotNull">mhtbbx：”Java中的注解 - @NotNull”<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>比如说，你写了一个后台系统，接收用户的请求，经过运算后返回结果，很通用的一个实现方案。假定所有的方法都需要校验参数是否为空，不然就可能有NullPointerException，如果系统有N个接口，每个接口参数有M个，你需要写N * M个if判断语句。如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (StringUtils.isBlank(request.getA())) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;A is blank&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么写下来，肯定代码是很丑的。那怎么办呢？记得我们之前说过的编码理念，<em>Don’t repeat yourself</em>，就派上用场了。</p>
<h2 id="简单校验"><a href="#简单校验" class="headerlink" title="简单校验"></a>简单校验</h2><h3 id="编写需要校验的bean"><a href="#编写需要校验的bean" class="headerlink" title="编写需要校验的bean"></a>编写需要校验的bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NotNull(message&#x3D;&quot;名字不能为空&quot;)</span><br><span class="line">private String userName;</span><br><span class="line">@Max(value&#x3D;120,message&#x3D;&quot;年龄最大不能查过120&quot;)</span><br><span class="line">private int age;</span><br><span class="line">@Email(message&#x3D;&quot;邮箱格式错误&quot;)</span><br><span class="line">private String email;</span><br></pre></td></tr></table></figure>
<h3 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">public String testValid(@Valid User user, BindingResult result)&#123;</span><br><span class="line">    if (result.hasErrors())&#123;</span><br><span class="line">        List&lt;ObjectError&gt; errorList &#x3D; result.getAllErrors();</span><br><span class="line">        for(ObjectError error : errorList)&#123;</span><br><span class="line">            System.out.println(error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    return &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>备注：这里一个@Valid的参数后必须紧挨着一个BindingResult 参数，否则spring会在校验不通过时直接抛出异常</strong></p>
<h2 id="级联校验"><a href="#级联校验" class="headerlink" title="级联校验"></a>级联校验</h2><h3 id="编写相关的bean"><a href="#编写相关的bean" class="headerlink" title="编写相关的bean"></a>编写相关的bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReportVO &#123;  </span><br><span class="line">  </span><br><span class="line">    @NotNull(message &#x3D; &quot;举报内容不能为空&quot;)  </span><br><span class="line">    @Valid</span><br><span class="line">    private ReportContent content;  </span><br><span class="line">  </span><br><span class="line">    @NotNull(message &#x3D; &quot;举报信息不能为空&quot;)  </span><br><span class="line">    @Valid  </span><br><span class="line">    private ReportInfo info;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReportInfo extends BaseTenantDomain&lt;String&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    private String reportContentId;  </span><br><span class="line">  </span><br><span class="line">    @NotBlank(message &#x3D; &quot;举报人id不能为空&quot;)  </span><br><span class="line">    private String reportorId;  </span><br><span class="line">  </span><br><span class="line">    @NotNull(message &#x3D; &quot;举报类型不能为空&quot;)  </span><br><span class="line">    private ReportType reportType;  </span><br><span class="line">  </span><br><span class="line">    @NotBlank(message &#x3D; &quot;举报详细描述不能为空&quot;)  </span><br><span class="line">    @Size(max&#x3D;100, message &#x3D; &quot;举报详细描述不能超过100&quot;)  </span><br><span class="line">    private String desc;  </span><br><span class="line">  </span><br><span class="line">    private Date reportTime; &#x2F;&#x2F; 举报时间  </span><br><span class="line">    private Date dealTime; &#x2F;&#x2F; 处理时间  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="校验方法-1"><a href="#校验方法-1" class="headerlink" title="校验方法"></a>校验方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void report(@RequestBody @Valid ReportVO reportVo,BindingResult result) &#123;  </span><br><span class="line">    contentService.report(reportVo.getContent(), reportVo.getInfo());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot日志配置-sl4j</title>
    <url>/p/d0da.html</url>
    <content><![CDATA[<blockquote>
<p>本文主要给大家介绍SpringBoot中如何通过sl4j日志组件优雅地记录日志。其实，我们入门 <strong>JAVA</strong> 的第一行代码就是一行日志，那你现在还在使用<code>System.out.println(&quot;Hello,小明!&quot;)</code>记录日志吗？</p>
</blockquote>
<h2 id="我经历过的日志组件"><a href="#我经历过的日志组件" class="headerlink" title="我经历过的日志组件"></a>我经历过的日志组件</h2><p>我最开始接触的日志组件是<strong>Log4j</strong></p>
<blockquote>
<p><strong>Log4j</strong> 作为Apache的一个开放源代码的项目，通过使用<strong>Log4j</strong>，我们可以控制日志信息输送的目的地是控制台、文件等我们期望它输出到的地方；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p>
</blockquote>
<p>我们可以通过一个配置文件来灵活地进行上面的配置，而不需要修改应用的代码。<strong>Log4j</strong>作为当时作为最先比较流行的日志框架，给我们在应用开发和维护带来了很大的便捷。</p>
<p>但是，如今还是慢慢的走下“神坛”呢，逐渐被<strong>Logback</strong>替代，众里寻她千百度，原来<strong>Logback</strong>是<strong>升级版</strong>，相对<strong>Log4j</strong>而言有了更多的改进，而且开发人员竟然是同班人马（其实就是一个人写的）！</p>
<h2 id="新星Logback"><a href="#新星Logback" class="headerlink" title="新星Logback"></a>新星Logback</h2><p><strong>Logback</strong>主要有下面的特性：</p>
<ol>
<li>更快的执行速度：基于我们先前在<strong>Log4j</strong>上的工作，<strong>Logback</strong> 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证<strong>Logback</strong>的组件更加快速的同时，同时所需的内存更加少；</li>
<li>充分的测试：<strong>Logback</strong> 历经了几年，数不清小时数的测试。尽管<strong>Log4j</strong>也是测试过的，但是<strong>Logback</strong>的测试更加充分，跟<strong>Log4j</strong>不在同一个级别。我们认为，这正是人们选择<strong>Logback</strong>而不是<strong>Log4j</strong>的最重要的原因。谁不希望即使在恶劣的条件下，你的日志框架依然稳定而可靠呢？</li>
</ol>
<ul>
<li>由三个模块组成<ul>
<li>logback-core</li>
<li>logback-classic</li>
<li>logback-access</li>
</ul>
</li>
</ul>
<p><code>logback-core</code>是其它模块的基础设施，其它模块基于它构建，显然，<code>logback-core</code>提供了一些关键的通用机制。<code>logback-classic</code>的地位和作用等同于 <code>Log4J</code>，它也被认为是 <code>Log4J</code>的一个改进版，并且它实现了简单日志门面 <code>SLF4J</code>；而 <code>logback-access</code>主要作为一个与 <code>Servlet</code>容器交互的模块，比如说<code>tomcat</code>或者 <code>jetty</code>，提供一些与 <code>HTTP</code>访问相关的功能。</p>
<h2 id="那Sl4J又是什么？"><a href="#那Sl4J又是什么？" class="headerlink" title="那Sl4J又是什么？"></a>那Sl4J又是什么？</h2><blockquote>
<p><strong>slf4j</strong>:The Simple Logging Facade for Java 即java的简单日志门面</p>
</blockquote>
<p>简答的讲就是<strong>slf4j</strong>是一系列的日志接口，<strong>slf4j</strong>是作为一个日志的抽象行为存在的，但是并没有提供真正的实现。</p>
<p><strong>slf4j</strong>为各种日志框架提供了一个统一的界面，使用户可以用统一的接口记录日志，动态地决定要使用的实现框架，比如<strong>Logback</strong>，<strong>Log4j</strong>，<strong>common-logging</strong>等框架都实现了这些接口。</p>
<h2 id="我是如何配置日志的？"><a href="#我是如何配置日志的？" class="headerlink" title="我是如何配置日志的？"></a>我是如何配置日志的？</h2><p>路人皆知，<strong>Springboot</strong>默认使用的日志框架是<strong>Logback</strong>。顺势而为，在项目中，我们使用<strong>Logback</strong>，其实只需增加一个配置文件（自定义你的配置）即可。</p>
<h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><p>配置文件精简结构如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;60 seconds&quot; debug&#x3D;&quot;false&quot;&gt;  </span><br><span class="line">		 &lt;!-- 属性文件:在properties&#x2F;yml文件中找到对应的配置项 --&gt;</span><br><span class="line">    &lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;logging.path&quot; source&#x3D;&quot;logging.path&quot;&#x2F;&gt;</span><br><span class="line">    &lt;contextName&gt;程序员小明&lt;&#x2F;contextName&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;appender&gt;</span><br><span class="line">        &#x2F;&#x2F;xxxx</span><br><span class="line">    &lt;&#x2F;appender&gt;   </span><br><span class="line">    </span><br><span class="line">    &lt;logger&gt;</span><br><span class="line">        &#x2F;&#x2F;xxxx</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;root&gt;             </span><br><span class="line">       &#x2F;&#x2F;xxxx</span><br><span class="line">    &lt;&#x2F;root&gt;  </span><br><span class="line">&lt;&#x2F;configuration&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个文件在springboot中默认叫做<strong>logback-spring.xml</strong>，我们只要新建一个同名文件放在<strong>resources</strong>下面， 配置即可生效。</p>
<p>每个配置的解释如下所示：</p>
<h4 id="contextName"><a href="#contextName" class="headerlink" title="contextName"></a>contextName</h4><p>每个<code>logger</code>都关联到<code>logger</code>上下文，默认上下文名称为<code>“default”</code>。但可以使用<code>contextName</code>标签设置成其他名字，用于区分不同应用程序的记录</p>
<h4 id="property"><a href="#property" class="headerlink" title="property"></a>property</h4><p>用来定义变量值的标签，<code>property</code>标签有两个属性，<code>name</code>和<code>value</code>；其中<code>name</code>的值是变量的名称，<code>value</code>的值时变量定义的值。通过<code>property</code>定义的值会被插入到<code>logger</code>上下文中。定义变量后，可以使“${name}”来使用变量。如上面的<code>xml</code>所示。</p>
<h4 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h4><p>用来设置某一个包或者具体的某一个类的日志打印级别以及指定<code>appender</code>。</p>
<h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p>根logger，也是一种logger，且只有一个level属性</p>
<h4 id="appender"><a href="#appender" class="headerlink" title="appender"></a>appender</h4><p>负责写日志的组件</p>
<h5 id="appender-的种类"><a href="#appender-的种类" class="headerlink" title="appender 的种类"></a>appender 的种类</h5><ul>
<li>ConsoleAppender：把日志添加到控制台</li>
<li>FileAppender：把日志添加到文件</li>
<li>RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。它是FileAppender的子类</li>
</ul>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter其实是appender里面的子元素。它作为过滤器存在，执行一个过滤器会有返回DENY，NEUTRAL，ACCEPT三个枚举值中的一个。</p>
<ul>
<li><p>DENY：日志将立即被抛弃不再经过其他过滤器</p>
</li>
<li><p>NEUTRAL：有序列表里的下个过滤器过接着处理日志</p>
</li>
<li><p>ACCEPT：日志会被立即处理，不再经过剩余过滤器</p>
<p>有以下几种过滤器</p>
<h5 id="ThresholdFilter"><a href="#ThresholdFilter" class="headerlink" title="ThresholdFilter"></a>ThresholdFilter</h5><p>临界值过滤器，过滤掉低于指定临界值的日志。当日志级别等于或高于临界值时，过滤器返回<code>NEUTRAL</code>；当日志级别低于临界值时，日志会被拒绝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">    &lt;level&gt;INFO&lt;&#x2F;level&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br></pre></td></tr></table></figure>
<h5 id="LevelFilter"><a href="#LevelFilter" class="headerlink" title="LevelFilter"></a>LevelFilter</h5><p>级别过滤器，根据日志级别进行过滤。如果日志级别等于配置级别，过滤器会根据<code>onMath</code>(用于配置符合过滤条件的操作) 和 <code>onMismatch</code>(用于配置不符合过滤条件的操作)接收或拒绝日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;   </span><br><span class="line">  &lt;level&gt;INFO&lt;&#x2F;level&gt;   </span><br><span class="line">  &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;   </span><br><span class="line">  &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;   </span><br><span class="line">&lt;&#x2F;filter&gt; </span><br></pre></td></tr></table></figure>
<h2 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h2></li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>一个简单正常的Springboot项目</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><p>有关日志的简单配置，我们可以直接在<code>application.yml</code>中进行简单的配置，比如指明日志的打印级别和日志的输出位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">  path: .&#x2F;logs</span><br></pre></td></tr></table></figure>
<p>也可以根据分环境配置指明使用的配置文件，缺省为<strong>logback-spring.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">  path: .&#x2F;logs</span><br><span class="line">  config: classpath:&#x2F;logback-dev.xml</span><br></pre></td></tr></table></figure>


<h4 id="logback-spring-xml"><a href="#logback-spring-xml" class="headerlink" title="logback-spring.xml"></a>logback-spring.xml</h4><p>在<strong>resources</strong>目录下新建<strong>logback-spring.xml</strong>文件，举例一个简单的需求，如果在项目中我们如果需要指定日志的输出格式以及根据日志级别输出到不同的文件，可以配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 属性文件:在properties文件中找到对应的配置项 --&gt;</span><br><span class="line">    &lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;logging.path&quot; source&#x3D;&quot;logging.path&quot;&#x2F;&gt;</span><br><span class="line">    &lt;contextName&gt;xiaoming&lt;&#x2F;contextName&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;consoleLog&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出（配色）：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span><br><span class="line">            &lt;pattern&gt;%yellow(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %red([%thread]) %highlight(%-5level) %cyan(%logger&#123;50&#125;) - %magenta(%msg) %n</span><br><span class="line">            &lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--根据日志级别分离日志，分别输出到不同的文件--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;fileInfoLog&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;&#x2F;level&gt;</span><br><span class="line">            &lt;onMatch&gt;DENY&lt;&#x2F;onMatch&gt;</span><br><span class="line">            &lt;onMismatch&gt;ACCEPT&lt;&#x2F;onMismatch&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            &lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--滚动策略--&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--按时间保存日志 修改格式可以按小时、按天、月来保存--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;logging.path&#125;&#x2F;xiaoming.info.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;!--保存时长--&gt;</span><br><span class="line">            &lt;MaxHistory&gt;90&lt;&#x2F;MaxHistory&gt;</span><br><span class="line">            &lt;!--文件大小--&gt;</span><br><span class="line">            &lt;totalSizeCap&gt;1GB&lt;&#x2F;totalSizeCap&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;appender name&#x3D;&quot;fileErrorLog&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;&#x2F;level&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;</span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">            &lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;!--滚动策略--&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--路径--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;logging.path&#125;&#x2F;xiaoming.error.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;MaxHistory&gt;90&lt;&#x2F;MaxHistory&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line">    &lt;root level&#x3D;&quot;info&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;consoleLog&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;fileInfoLog&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;fileErrorLog&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>再比如如果粒度再细一些，根据不同的模块，输出到不同的文件，可以如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--特殊功能单独appender 例如调度类的日志--&gt;</span><br><span class="line">   &lt;appender name&#x3D;&quot;CLASS-APPENDER&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">       &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">           &lt;level&gt;INFO&lt;&#x2F;level&gt;</span><br><span class="line">       &lt;&#x2F;filter&gt;</span><br><span class="line">       &lt;encoder&gt;</span><br><span class="line">           &lt;pattern&gt;</span><br><span class="line">               %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line">           &lt;&#x2F;pattern&gt;</span><br><span class="line">       &lt;&#x2F;encoder&gt;</span><br><span class="line">       &lt;!--滚动策略--&gt;</span><br><span class="line">       &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">           &lt;!--路径--&gt;</span><br><span class="line">           &lt;fileNamePattern&gt;$&#123;logging.path&#125;&#x2F;mkc.class.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">           &lt;MaxHistory&gt;90&lt;&#x2F;MaxHistory&gt;</span><br><span class="line">       &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">   &lt;&#x2F;appender&gt;</span><br><span class="line">   &lt;!--这里的name和业务类中的getLogger中的字符串是一样的--&gt;</span><br><span class="line">   &lt;logger name&#x3D;&quot;xiaoming&quot; level&#x3D;&quot;INFO&quot; additivity&#x3D;&quot;true&quot;&gt;</span><br><span class="line">       &lt;appender-ref ref&#x3D;&quot;CLASS-APPENDER&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;logger&gt;</span><br></pre></td></tr></table></figure>
<p>正常情况下<strong>xiaoming</strong>是指的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Logger xiaoming &#x3D; LoggerFactory.getLogger(&quot;xiaoming&quot;);</span><br></pre></td></tr></table></figure>
<p>如果我们使用的是<strong>lomok</strong>插件，则<strong>xiaoming</strong>指的是<strong>topic</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j(topic &#x3D; &quot;xiaoming&quot;)</span><br><span class="line">public class XiaoMingTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>小明目前用到的就这么多啦，更多的日志配置场景，大家可以访问：<a class="link"   href="https://juejin.im/post/5b51f85c5188251af91a7525" >看完这个不会配置 logback ，请你吃瓜！<i class="fas fa-external-link-alt"></i></a></p>
<p>有什么问题，欢迎大家留言～</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的bug总结，快来看一下你有没有遇到</title>
    <url>/p/b1fe.html</url>
    <content><![CDATA[<h2 id="接口请求-Status-blocked-other"><a href="#接口请求-Status-blocked-other" class="headerlink" title="接口请求:Status(blocked:other)"></a>接口请求:Status(blocked:other)</h2><p>有一次在前端请求后台提供的接口时，突然发现自己的浏览器不能请求</p>
<p><img src="http://img.mynamecoder.com/FrHqA_C7J80ifxtGHoPjlF1emCU3"></p>
<p>倒腾了很久，才发现是被浏览器插件（如我使用的是AdBlock插件）当作广告拦截了，当你在一个广告业务的公司工作，尤其要注意一哈。</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ol>
<li>停用你的广告拦截器</li>
<li>在当前网站停用广告拦截插件（比如AdBlock）</li>
</ol>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
  </entry>
  <entry>
    <title>这就是CDN回源原理和CDN多级缓存啊！</title>
    <url>/p/ead7.html</url>
    <content><![CDATA[<blockquote>
<p>小明对项目中的cdn缓存一直不是太明白……</p>
</blockquote>
<h2 id="CDN回源"><a href="#CDN回源" class="headerlink" title="CDN回源"></a>CDN回源</h2><h3 id="回源原理"><a href="#回源原理" class="headerlink" title="回源原理"></a>回源原理</h3><ul>
<li><p>回源是指浏览器在发送请求报文时，响应该请求报文的是源站点的服务器，而不是各节点上的缓存服务器（比如nginx开启缓存），那么这个过程相对于通过各节点上的缓存服务器来响应的话就称作为回源。回源的请求或流量太多的话，有可能会让源站点的服务器承载着过大的访问压力，进而影响服务的正常访问。</p>
</li>
<li><p>回源域名一般是cdn领域的专业术语，通常情况下，是直接用ip进行回源的，但是如果客户源站有多个ip，并且ip地址会经常变化，对于cdn厂商来说，为了避免经常更改配置（回源ip），会采用回源域名方式进行回源，这样即使源站的ip变化了，也不影响原有的配置。</p>
</li>
<li><p>常规的CDN都是回源的。即：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么CDN节点不会主动去源站拿的。</p>
</li>
<li><p>源站内容有更新的时候，源站可以主动把内容推送到CDN节点。参考阿里云url预热<a class="link"   href="https://help.aliyun.com/knowledge_detail/40106.html?spm=a2c4e.11153987.0.0.419f6ec5UvPSJ1" >https://help.aliyun.com/knowledge_detail/40106.html?spm=a2c4e.11153987.0.0.419f6ec5UvPSJ1<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>CDN本来是给我们的网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。</p>
</li>
</ul>
<h2 id="CDN回源率计算方法"><a href="#CDN回源率计算方法" class="headerlink" title="CDN回源率计算方法"></a>CDN回源率计算方法</h2><p>回源比分为回源请求数比例及回源流量比例两种：</p>
<h3 id="回源请求数比"><a href="#回源请求数比" class="headerlink" title="回源请求数比"></a>回源请求数比</h3><p>统计数据来自所有边缘节点上的请求记录，其中，对于没有缓存或缓存过期（可缓存）的请求以及不可缓存的请求，均计入回源请求中，其他直接命中缓存的，则为命中请求。</p>
<h3 id="回源流量比"><a href="#回源流量比" class="headerlink" title="回源流量比"></a>回源流量比</h3><p>回源流量是回源请求文件大小产生的流量和请求本身产生的流量   回源流量比=回源流量/回源流量+用户请求访问的流量</p>
<h2 id="CDN常见多级缓存"><a href="#CDN常见多级缓存" class="headerlink" title="CDN常见多级缓存"></a>CDN常见多级缓存</h2><h3 id="CDN概念"><a href="#CDN概念" class="headerlink" title="CDN概念"></a>CDN概念</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h3 id="CDN工作方法"><a href="#CDN工作方法" class="headerlink" title="CDN工作方法"></a>CDN工作方法</h3><p>客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求（back to the source request）,来拉取最新的数据。CDN的典型拓扑图如下：</p>
<p><img src="https://i.ibb.co/x1SX6SH/cdn.png" alt="CDN的典型拓扑图"></p>
<h3 id="CDN层级划分："><a href="#CDN层级划分：" class="headerlink" title="CDN层级划分："></a>CDN层级划分：</h3><ul>
<li><p>CDN系统中，直接面向用户，负责给用户提供内容服务的的Cache设备都部署在整个 CDN网络的边缘位置，所以将这一层称为边缘层。</p>
</li>
<li><p>CDN系统中，中心层负责全局的管理和控制，同时也保存了最多的内容Cache。在边缘层设备未能命中Cache时，需要向中心层设备请求；而中心层未能命中时，则需要向源站请求。不同的CDN系统设计存在差异，中心层可能具备用户服务的能力，也可能只会向下一层提供服务。</p>
</li>
<li><p>如果CDN系统比较庞大，边缘层向中心层请求内容太多，会造成中心层负载压力太大。此时，需要在中心层和边缘层之间部署一个区域层，负责一个区域的管理和控制，也可以提供一些内容Cache供边缘层访问。</p>
</li>
</ul>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求。类似浏览器缓存，CDN边缘节点也存在着一套缓存机制。</p>
<h3 id="CDN缓存的缺点"><a href="#CDN缓存的缺点" class="headerlink" title="CDN缓存的缺点"></a>CDN缓存的缺点</h3><p>CDN的分流作用不仅减少了用户的访问延时，也减少的源站的负载。但其缺点也很明显：当网站更新时，如果CDN节点上数据没有及时更新，即便用户再浏览器使用Ctrl +F5的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。</p>
<h3 id="CDN缓存策略"><a href="#CDN缓存策略" class="headerlink" title="CDN缓存策略"></a>CDN缓存策略</h3><ul>
<li><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的Cache-control: max-age的字段来设置CDN边缘节点数据缓存时间。</p>
</li>
<li><p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p>
</li>
<li><p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
</li>
<li><p>CDN缓存时间会对“回源率”产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p>
</li>
</ul>
<h3 id="CDN缓存刷新"><a href="#CDN缓存刷新" class="headerlink" title="CDN缓存刷新"></a>CDN缓存刷新</h3><p>CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><p><a class="link"   href="https://blog.csdn.net/mountains2001/article/details/52766431" >https://blog.csdn.net/mountains2001/article/details/52766431<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://blog.csdn.net/wangxin1982314/article/details/51050206/" >https://blog.csdn.net/wangxin1982314/article/details/51050206/<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://blog.csdn.net/songchunmin_/article/details/69942991" >https://blog.csdn.net/songchunmin_/article/details/69942991<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.jianshu.com/p/7b749b49201a" >https://www.jianshu.com/p/7b749b49201a<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h2 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h2><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title>git小技巧--如何从其他分支merge个别文件或文件夹</title>
    <url>/p/8834.html</url>
    <content><![CDATA[<blockquote>
<p>小明发现在实际项目开发过程中，总会遇到各种各样的情况，比如一个大型的项目或版本迭代可能不是一次上线，可能会分好几次上线，这时候就会涉及创建多个分支，分别开发。</p>
</blockquote>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>产品经理：我们本次开发三个功能，列表页功能、详情页功能、系统消息功能，分两次上线，先上列表功能，再上详情页和系统消息。</p>
<p>小明：好的吧。</p>
<p>紧接着，小明就将本次需求分为2个分支，分别为A、B。</p>
<ul>
<li>A：开发列表页功能</li>
<li>B：开发详情页功能、系统消息功能</li>
</ul>
<p><strong>原计划</strong>：产品经理说先上列表功能，那小明就先开发A分支，列表功能很快开发完成（厉害吧）。</p>
<p><strong>计划有变</strong>：风云变幻，第二天小明按照计划开发B分支，开发到一半，产品经理突然说目前的系统消息功能（位于B分支）比较紧急，需要和列表功能（位于A分支）一起上线，当时小明就懵逼了。赶紧暂停开发详情页（位于B分支，虽然已经开发了一部分），转战系统消息功能的开发。当系统消息功能开发完成之后，就需要考虑将系统消息功能（位于B分支）和列表功能（位于A分支）放在一个分支上提测（开发一部分的详情页功能暂先不需要合并）的问题，这时候<strong>分支合并</strong>就要派上用场了。</p>
<h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>说起<strong>分支合并</strong>，大家第一个想到的命令肯定是<code>git merge</code> ，因为这是<strong>分支合并</strong>的常用命令。</p>
<p>使用<code>git merge</code> 合并分支会将两个分支的<strong>所有内容</strong>进行比较合并，因此我们如果想合并两个分支中的<strong>一部分</strong>，显然直接使用这个命令是行不通的。</p>
<p>So what happens next ? 嘿嘿，有两种方案可供我们选择：</p>
<h2 id="强制合并"><a href="#强制合并" class="headerlink" title="强制合并"></a>强制合并</h2><p>从其他分支<code>merge</code>指定文件到当前分支，<code>git checkout</code>是个合适的工具。</p>
<p>语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout source_branch &lt;path&gt;...</span><br></pre></td></tr></table></figure>
<p>我们使用git checkout 将B分支上的系统消息功能添加到A分支上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  * A  </span><br><span class="line">    B</span><br><span class="line">    </span><br><span class="line">$ git checkout B message.html message.css message.js other.js</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"># On branch A</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#    new file:   message.css</span><br><span class="line">#    new file:   message.html</span><br><span class="line">#    new file:   message.js</span><br><span class="line">#    modified:   other.js</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>合并完成</p>
<p>但是……</p>
<p><strong>注意：在使用git checkout某文件到当前分支时，会将当前分支的对应文件强行覆盖</strong></p>
<p>因此，合并A分支上没有存在的文件没问题，但是如果合并A分支上原先就存在的文件（比如两个分支上都对<strong>other.js</strong>进行过修改），位于分支A上的文件<strong>other.js</strong>就会被<strong>checkout</strong>（分支B）过来的<strong>other.js</strong>覆盖，导致分支A上之前开发的<strong>列表功能</strong>付之东流，这样做肯定是优雅的！</p>
<p>那如何避免同一个文件不强制覆盖，有没有更好的解决方案呢（调一下味口）？我们一起来看一下第二种方案。</p>
<h2 id="智能合并"><a href="#智能合并" class="headerlink" title="智能合并"></a>智能合并</h2><p><strong>思路</strong>：曲线救国，我们通过<strong>git merge</strong> 强大的分支合并功能来完成此次无缝合并。</p>
<ol>
<li>首先使用<code>git checkout</code>根据A分支创建一个A_temp分支(避免影响A分支)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b A_temp</span><br><span class="line">Switched to a new branch &#39;A_temp&#39;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后将B分支合并到A_temp分支，此时两个都经修改过的文件会跑出冲突，我们只需解决冲突即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge B</span><br><span class="line">Updating 1f73596..04627b5</span><br><span class="line">Fast-forward</span><br><span class="line"> message.css                     | 0</span><br><span class="line"> message.html                    | 0</span><br><span class="line"> message.js                      | 0</span><br><span class="line"> other.js                        | 1 +</span><br><span class="line"> 4 files changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 message.css</span><br><span class="line"> create mode 100644 message.html</span><br><span class="line"> create mode 100644 message.js</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>再次切换到A分支，并使用<strong>git checkout</strong> 将A_temp分支上的系统消息功能相关文件或文件夹覆盖到A分支，此时可以大胆的覆盖！因为我们已经在第二步处理过冲突问题。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ git checkout A</span><br><span class="line">Switched to branch &#39;A&#39;</span><br><span class="line"></span><br><span class="line">$ git checkout A_temp message.html message.css message.js other.js</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"># On branch A</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#    new file:   message.css</span><br><span class="line">#    new file:   message.html</span><br><span class="line">#    new file:   message.js</span><br><span class="line">#    modified:   other.js</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p>最后，有强迫症的患者可以卸磨杀驴，把刚刚根据分支A创建的A_temp删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d A_temp</span><br></pre></td></tr></table></figure>
<p>OK，到此分支合并就完结了，现在我们就可以自信地召唤产品经理（我们公司产品兼测试）测试这两个功能。</p>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>另外给大家介绍一下<code>git merge</code> 使用的小技巧</p>
<p>举例：要把<code>master</code>分支合并到<code>dev</code>分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev &#x2F;&#x2F; 切换到dev分支</span><br><span class="line">git merge master --no-ff &#x2F;&#x2F; 使用--no-ff</span><br></pre></td></tr></table></figure>
<p>默认使用<code>merge</code>命令是<code>ff</code>，即 <code>fast-forward</code>，这种方式从Git 合并历史中是无法查看到是哪几个提交对象在一起实现了一个功能。</p>
<p>而<code>--no-ff</code> 标记会在分支合并的时候，创建一个新的提交对象，可以避免丢失<code>master</code>分支的历史信息，并且把所有的功能叠加在一起提交上去。两者的区别如下图所示，大家可以自己体验一下两者的区别。</p>
<p><img src="https://s2.ax1x.com/2019/09/18/nHeDPS.png" alt="两者的区别"></p>
<p>以上就是小明工作中使用git合并总结的经验，希望能帮助到大家，仅供参考，有错误请指出，谢谢！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo忽略编译某些文件</title>
    <url>/p/d2c.html</url>
    <content><![CDATA[<p>我们需要自己定义一些页面，比如：404.html，需要在<code>source</code>目录下填加一个<code>demo</code>目录放一些示例文件，hexo默认会编译<code>source</code>目录下的所有文件。但demo目录并不需要编译，<code>_config.yml</code>有提供一个配置项<code>skip_render</code>, 官网说明：</p>
<blockquote>
<p>skip_render：跳过指定文件的渲染，您可使用<a class="link"   href="https://github.com/isaacs/minimatch" >glob表达式<i class="fas fa-external-link-alt"></i></a>来匹配路径。</p>
</blockquote>
<p>glob表达式链接的是<code>minimatch</code>，说明路径匹配用的应该是<code>minimatch</code>这个npm模块包来完成的。需要指出的是这里面配置的路径都是相对<code>source</code>目录的。</p>
<ol>
<li><p>如何需要跳过<code>source</code>目录下文件的编译:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 跳过单个文件</span><br><span class="line">skip_render: test.html</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 跳过所有的html的文件</span><br><span class="line">skip_render: &#39;*.html&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>跳过某一目录下的所有文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render: test&#x2F;*</span><br></pre></td></tr></table></figure></li>
<li><p>需要跳过某一目录下的所有文件和子目录时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render: test&#x2F;**</span><br></pre></td></tr></table></figure></li>
<li><p>跳过多个目录，或者多个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 最新版本的hexo，用这个好使</span><br><span class="line">skip_render: [&#39;*.html&#39;, demo&#x2F;**, test&#x2F;*]</span><br></pre></td></tr></table></figure>
<p>看见有人是说是这样，反正我试不管事，可能的版本的原因：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 我试了试，不管事啊。</span><br><span class="line">skip_render:</span><br><span class="line">    - test1&#x2F;*.html</span><br><span class="line">    - test2&#x2F;**</span><br></pre></td></tr></table></figure>
<p>ps：</p>
<ol>
<li><p>如果设置<code>skip_render</code>不起作用，可以先执行<code>hexo clean</code>清除一下缓存。</p>
</li>
<li><p>如果跳过多个目录编译失败，请尝试更新<code>hexo</code>, 在<code>source</code>同级目录中执行<code>npm update hexo</code></p>
</li>
<li><p>如果需要查看是否成功跳过编译，可以在编译的时候加上<code>--debug</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate --debug</span><br></pre></td></tr></table></figure>
<p>关注打印出来的<code>Rendering xxxx</code> 中的东西。</p>
</li>
</ol>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo推荐插件</title>
    <url>/p/17116.html</url>
    <content><![CDATA[<h3 id="1、缩短生成的静态页面名"><a href="#1、缩短生成的静态页面名" class="headerlink" title="1、缩短生成的静态页面名"></a>1、缩短生成的静态页面名</h3><p>每次从博客分享文章给别人都很苦恼，Hexo 默认生成的链接太长了，而且一旦文章名字改变，链接也跟着改变。有没有什么方法让地址尽量短小精悍，同时永久化呢？</p>
<p>感谢 <code>rozbo/hexo-abbrlink</code>，完美解决此痛点。</p>
<p>使用方法也很简单：</p>
<p>在 Hexo 博客根目录，执行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>在 _config.yml 配置文件写入</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc16</span> <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment">#support dec(default) and hex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处为更改 permalink的值</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">p/:abbrlink.html</span> </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo用自己的服务器搭建博客</title>
    <url>/p/35e7.html</url>
    <content><![CDATA[<blockquote>
<p>最近小明介绍过自己用hexo+git搭建个人博客之后，大家好像更关心的是域名<strong>mynamecoder.com</strong>，不是应该关注技术嘛，让小明哭笑不得😂，今天继续给大家讲一下如果觉得这两个代码托管平台打开加载太慢，我们可以考虑部署到自己的ECS服务器（小明在腾讯云搞活动够买的99元一年的服务器，邀请链接在文末）。</p>
</blockquote>
<h3 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h3><p>Hexo(<a class="link"   href="https://hexo.io/zh-cn/" >https://hexo.io/zh-cn/<i class="fas fa-external-link-alt"></i></a>) 是一个快速，简单和强大的博客框架，基于 Node.js。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>在一台 CentOS 7.2 的 ECS 云服务器上快速部署基于 Hexo 的博客站点</li>
<li>可以在本地简洁快速发布一篇博文到个人云服务器上, 用于个人站点展示</li>
</ul>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ul>
<li>hexo环境搭建</li>
<li>git钩子自动部署</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>你能操作的个人电脑PC * 1台</li>
<li>自己能控制的服务器Sever * 1台</li>
</ul>
<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><blockquote>
<p>默认 ROOT 权限登录</p>
</blockquote>
<ul>
<li><p><strong>安装 Git Nginx</strong><br>升级 CentOS 所有包，包括系统版本内核升级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br><span class="line">yum install -y git nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Nginx 配置</strong><br>创建文件目录, 用于博客站点文件存放, 并更改目录读写权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;data&#x2F;www&#x2F;hexo</span><br><span class="line">chmod -R 755 &#x2F;data&#x2F;www&#x2F;hexo</span><br></pre></td></tr></table></figure>
<p>添加 index.html 用于检测配置 Nginx 是否成功</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;data&#x2F;www&#x2F;hexo&#x2F;index.html</span><br></pre></td></tr></table></figure>
<p>添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Nginx running&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>配置 Nginx 服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line"># vim 查找: &#x2F;listen 80</span><br></pre></td></tr></table></figure>
<p>通过 vim 查找功能找到如下代码, 并修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">server &#123;</span><br><span class="line">      listen       80 default_server;</span><br><span class="line">      listen       [::]:80 default_server;</span><br><span class="line">      server_name  www.mynamcoder.com; # 填写个人域名</span><br><span class="line">      root         &#x2F;data&#x2F;www&#x2F;hexo;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>访问服务器 IP 或者域名显示</p>
<blockquote>
<p>Nginx running</p>
</blockquote>
<p>Nginx 配置成功</p>
<ul>
<li><strong>Git 配置</strong><br>创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. mkdir &#x2F;data&#x2F;GitLibrary</span><br><span class="line">2. chmod -R 755 &#x2F;data&#x2F;GitLibrary</span><br></pre></td></tr></table></figure>
<p>Git 初始化裸库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;GitLibrary</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure>
<p>创建 Git 钩子(hook)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;data&#x2F;GitLibrary&#x2F;hexo.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure>
<p>用于指定 Git 的源代码 和 Git 配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">git --work-tree&#x3D;&#x2F;data&#x2F;www&#x2F;hexo --git-dir&#x3D;&#x2F;data&#x2F;GitLibrary&#x2F;hexo.git checkout -f</span><br></pre></td></tr></table></figure>
<p>保存并退出后, 给该文件添加可执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;data&#x2F;GitLibrary&#x2F;hexo.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>小明使用的是mac，下面主要讲一下在 MacOS 上安装 node.js、 Git、 Hexo</p>
<blockquote>
<p>Windows &amp; Linux 搜索对应平台软件安装即可</p>
</blockquote>
<ul>
<li><p><strong>安装 Git</strong><br>在 Terminal.app(终端) 中输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>按照提示完成安装, 最后在 Terminal 中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git -v</span><br></pre></td></tr></table></figure>
<p>如下显示, 表示 Git 安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git version 2.11.0 (Apple Git-81)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装 Node.js 和 Npm</strong><br>Node.js 安装在 MacOS 中需要用到 Homebrew 进行安装管理</p>
<blockquote>
<p>Homebrew 在 MacOS 里类似于 CentOS 的 yum</p>
</blockquote>
<p>在 Terminal 输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>
<p>使用 Homebrew 安装 Node.js</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<p>  在 Terminal 中键入类似的命令, 如下显示, 表示 Node 和 Npm 安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">v7.10.0</span><br><span class="line">npm -v</span><br><span class="line">4.2.0</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>安装 Hexo 及相关插件</strong><br>全局安装 hexo-cli 和 hexo-server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli hexo-server hexo-deployer-git -g</span><br></pre></td></tr></table></figure>
<p>安装完成后, 在本地初始化博客站点搭建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init ~&#x2F;myBlog</span><br><span class="line"></span><br><span class="line"># ~&#x2F;myBlog 即本地存放路径</span><br></pre></td></tr></table></figure>
<p>完成安装, 便可以在本地路径查看项目</p>
</li>
<li><p><strong>本地 Hexo 配置</strong><br>进入~/myBlog 目录, 修改 Hexo 博客站点配置文件 <em>_config.yml</em>，如下修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 程序员小明     &#x2F;&#x2F;页面标题</span><br><span class="line">subtitle: 一个不加班的程序员     &#x2F;&#x2F;小标题</span><br><span class="line">description: 不忘初心，牢记使命     &#x2F;&#x2F;描述</span><br><span class="line">author: 小明       &#x2F;&#x2F;作者</span><br><span class="line">language: zh-CN     &#x2F;&#x2F;语言</span><br><span class="line">timezone:       &#x2F;&#x2F;时区，可以为空</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">### If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;www.mynamecoder.com      &#x2F;&#x2F;个人域名</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"># 一个是服务器</span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: root@94.191.25.157:&#x2F;root&#x2F;hexo.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3></li>
</ul>
<p>将本地部署到服务器</p>
<ul>
<li><p>清除缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li>
<li><p>生成静态页面:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></li>
<li><p>将本地静态页面目录部署到云服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>完成 Hexo 个人博客网站搭建, 通过服务器 IP 或者域名即可访问</p>
</li>
</ul>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>以上就是我个人采用Hexo+云服务器搭建个人博客的全部流程，较为完整地介绍了 Hexo 博客的安装及简单配置，服务端如何配置通过 Git 部署 Nginx 及 Linux 简单应用。<br>在云服务器上创建私有 Git 仓库, 通过 Git 钩子，将 Hexo 生成的博客静态页面文件，推送到 Nginx 服务的托管目录, 完成部署。</p>
<p>如有疑问, 可留言或者搜索引擎解决哈。</p>
<h3 id="购买服务器邀请链接"><a href="#购买服务器邀请链接" class="headerlink" title="购买服务器邀请链接"></a>购买服务器邀请链接</h3><p>【新用户限量秒杀】热门云产品限量秒杀，云服务器1核1G 首年99元<br><a class="link"   href="http://1t.click/a75v" >http://1t.click/a75v<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>还没有自己的网站？ICP备案了解一下！</title>
    <url>/p/54c3.html</url>
    <content><![CDATA[<blockquote>
<p>小明近期计划发誓要搭建属于自己的网站!</p>
</blockquote>
<h2 id="关于ICP-Internet-Content-Provider-即网络内容提供商"><a href="#关于ICP-Internet-Content-Provider-即网络内容提供商" class="headerlink" title="关于ICP(Internet Content Provider)即网络内容提供商"></a>关于ICP(Internet Content Provider)即网络内容提供商</h2><p>ICP可以理解为经过国家主管部门批准的正式企业或部门，向用户提供互联网业务和服务的运营商,比如：阿里云、腾讯云、华为等众多服务商……那ICP备案就是域名的备案，域名就是网站访问的链接地址。举个例子，百度的访问地址：<a class="link"   href="http://www.baidu.com./" >www.baidu.com。<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="那我们为什么要通过ICP备案呢？"><a href="#那我们为什么要通过ICP备案呢？" class="headerlink" title="那我们为什么要通过ICP备案呢？"></a>那我们为什么要通过ICP备案呢？</h2><p>根据工信部《互联网信息服务管理办法》，<strong>网站在未完成备案之前，不能指向大陆境内服务器开通访问</strong>。当今庞大的互联网世界里，需要一个良好的环境，那么国家就需要对所有企业和个人建立的网站进行统一登记和管理，就像我们每个人出生后，父母都要为我们上户口一样，我们企业或个人，在购买域名建立一个网站时，都需要完成相应的登记才行。没有登记的就是不合法的，也就是没有备案的网站，都是不允许面向用户，不许提供服务上线的。</p>
<h2 id="准备备案所需基本资料"><a href="#准备备案所需基本资料" class="headerlink" title="准备备案所需基本资料"></a>准备备案所需基本资料</h2><ul>
<li>购买/拥有一个域名 </li>
<li>购买/拥有一个轻量级云服务器（3个月以上）,<strong><a class="link"   href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=1qsydng8" >阿里云服务器购买链接<i class="fas fa-external-link-alt"></i></a></strong></li>
<li>准备备案材料,<strong><a class="link"   href="https://help.aliyun.com/knowledge_detail/36890.html" >详细介绍<i class="fas fa-external-link-alt"></i></a></strong></li>
</ul>
<h2 id="备案流程"><a href="#备案流程" class="headerlink" title="备案流程"></a>备案流程</h2><p>以上准备工作好了以后，<a class="link"   href="https://beian.aliyun.com/" >访问<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://beian.aliyun.com/" >https://beian.aliyun.com/<i class="fas fa-external-link-alt"></i></a> 开始备案流程<br><img src="https://i.ibb.co/4TFLJY1/2019-05-09-4-10-32.png" alt="备案流程图">，上传资料后等待阿里客服审核资料</p>
<p>1个工作日左右，阿里客服MM会电话与你联系，确认信息，后边的流程根据提示做即可！</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>系统运维</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8 Optional 的正确使用姿势</title>
    <url>/p/d6b5.html</url>
    <content><![CDATA[<p>我们知道 Java 8 增加了一些很有用的 API, 其中一个就是 <code>Optional</code>. 如果对它不稍假探索, 只是轻描淡写的认为它可以优雅的解决 <code>NullPointException</code> 的问题, 于是代码就开始这么写了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; user &#x3D; ……</span><br><span class="line">if (user.isPresent()) &#123;</span><br><span class="line">return user.getOrders();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么不得不说我们的思维仍然是在原地踏步, 只是本能的认为它不过是 User 实例的包装, 这与我们之前写成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; …..</span><br><span class="line">if (user !&#x3D; null) &#123;</span><br><span class="line">return user.getOrders();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实质上是没有任何分别. 这就是我们将要讲到的使用好 Java 8 <code>Optional</code> 类型的正确姿势.</p>
<p>在里约奥运之时, 新闻一再提起五星红旗有问题, 可是我怎么看都看不出来有什么问题, 后来才道是小星星膜拜中央的姿势不对. 因此我们千万也别对自己习以为常的事情觉得理所当然, 丝毫不会觉得有何不妥, 换句话说也就是当我们切换到 Java 8 的 <code>Optional</code> 时, 不能继承性的对待过往 <code>null</code> 时的那种思维, 应该掌握好新的, 正确的使用 Java 8 <code>Optional</code> 的正确姿势.</p>
<p>直白的讲, 当我们还在以如下几种方式使用 <code>Optional</code> 时, 就得开始检视自己了</p>
<ul>
<li>调用 <code>isPresent()</code> 方法时</li>
<li>调用 <code>get()</code> 方法时</li>
<li><code>Optional</code> 类型作为类/实例属性时</li>
<li><code>Optional</code> 类型作为方法参数时</li>
</ul>
<p><code>Optional</code> 中我们真正可依赖的应该是除了 <code>isPresent()</code> 和 <code>get() </code>的其他方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</span><br><span class="line">public T orElse(T other)</span><br><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; other)</span><br><span class="line">public void ifPresent(Consumer&lt;? super T&gt; consumer)</span><br><span class="line">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br><span class="line">public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</span><br><span class="line">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</span><br></pre></td></tr></table></figure>
<p>我略有自信的按照它们大概使用频度对上面的方法排了一下序。先又不得不提一下 Optional 的三种构造方式: Optional.of(obj),  <code>Optional.ofNullable(obj)</code> 和明确的 <code>Optional.empty()</code>;</p>
<ul>
<li><code>Optional.of(obj)</code>: 它要求传入的 <code>obj</code> 不能是 <code>null</code> 值的, 否则还没开始进入角色就倒在了 <code>NullPointerException</code> 异常上了.</li>
</ul>
<p><code>Optional.ofNullable(obj)</code>: 它以一种智能的, 宽容的方式来构造一个 <code>Optional</code> 实例. 来者不拒, 传 <code>null</code> 进到就得到 <code>Optional.empty()</code>, 非 <code>null</code> 就调用 <code>Optional.of(obj)</code>.</p>
<p>那是不是我们只要用 <code>Optional.ofNullable(obj)</code> 一劳永逸, 以不变应二变的方式来构造 <code>Optional</code> 实例就行了呢? 那也未必, 否则 <code>Optional.of(obj)</code> 何必如此暴露呢, 私有则可?</p>
<p>我本人的观点是:  </p>
<ol>
<li>当我们非常非常的明确将要传给 <code>Optional.of(obj)</code> 的 <code>obj</code> 参数不可能为 <code>null</code> 时, 比如它是一个刚 <code>new</code> 出来的对象<code>(Optional.of(new User(...)))</code>, 或者是一个非 <code>null</code> 常量时;  </li>
<li>当想为 <code>obj</code> 断言不为 <code>null</code> 时, 即我们想在万一 <code>obj</code> 为 <code>null</code> 立即报告 <code>NullPointException</code> 异常, 立即修改, 而不是隐藏空指针异常时, 我们就应该果断的用 <code>Optional.of(obj)</code> 来构造 <code>Optional</code> 实例, 而不让任何不可预计的 <code>null</code> 值有可乘之机隐身于 <code>Optional</code> 中.</li>
</ol>
<p>现在才开始怎么去使用一个已有的 Optional 实例, 假定我们有一个实例 <code>Optional&lt;User&gt; user</code>, 下面是几个普遍的, 应避免 <code>if(user.isPresent()) &#123; ... &#125; else &#123; ... &#125; </code>几中应用方式.</p>
<h2 id="存在即返回-无则提供默认值"><a href="#存在即返回-无则提供默认值" class="headerlink" title="存在即返回, 无则提供默认值"></a>存在即返回, 无则提供默认值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return user.orElse(null);  &#x2F;&#x2F;而不是 return user.isPresent() ? user.get() : null;</span><br><span class="line">return user.orElse(UNKNOWN_USER);</span><br></pre></td></tr></table></figure>
<h2 id="存在即返回-无则由函数来产生"><a href="#存在即返回-无则由函数来产生" class="headerlink" title="存在即返回, 无则由函数来产生"></a>存在即返回, 无则由函数来产生</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return user.orElseGet(() -&gt; fetchAUserFromDatabase()); &#x2F;&#x2F;而不要 return user.isPresent() ? user: fetchAUserFromDatabase();</span><br></pre></td></tr></table></figure>
<h2 id="存在才对它做点什么"><a href="#存在才对它做点什么" class="headerlink" title="存在才对它做点什么"></a>存在才对它做点什么</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user.ifPresent(System.out::println); &#x2F;&#x2F;传入一个Consumer&lt;? super T&gt; consumer</span><br><span class="line">&#x2F;&#x2F;而不要下边那样</span><br><span class="line">if (user.isPresent()) &#123;</span><br><span class="line">  System.out.println(user.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map-函数隆重登场"><a href="#map-函数隆重登场" class="headerlink" title="map 函数隆重登场"></a>map 函数隆重登场</h2><p>当 <code>user.isPresent()</code> 为真, 获得它关联的 <code>orders</code>, 为假则返回一个空集合时, 我们用上面的 <code>orElse</code>, <code>orElseGet</code> 方法都乏力时, 那原本就是 <code>map</code> 函数的责任, 我们可以这样一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return user.map(u -&gt; u.getOrders()).orElse(Collections.emptyList())</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;上面避免了我们类似 Java 8 之前的做法</span><br><span class="line">if(user.isPresent()) &#123;</span><br><span class="line">  return user.get().getOrders();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map  是可能无限级联的, 比如再深一层, 获得用户名的大写形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return user.map(u -&gt; u.getUsername())</span><br><span class="line">           .map(name -&gt; name.toUpperCase())</span><br><span class="line">           .orElse(null);</span><br></pre></td></tr></table></figure>
<p>这要搁在以前, 每一级调用的展开都需要放一个 null 值的判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; .....</span><br><span class="line">if(user !&#x3D; null) &#123;</span><br><span class="line">  String name &#x3D; user.getUsername();</span><br><span class="line">  if(name !&#x3D; null) &#123;</span><br><span class="line">    return name.toUpperCase();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对这方面 Groovy 提供了一种安全的属性/方法访问操作符 ?.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user?.getUsername()?.toUpperCase();</span><br></pre></td></tr></table></figure>
<p>Swift 也有类似的语法, 只作用在  Optional 的类型上.</p>
<p>用了 <code>isPresent()</code> 处理 <code>NullPointerException</code> 不叫优雅, 有了  <code>orElse</code>, <code>orElseGet</code> 等, 特别是 <code>map</code> 方法才叫优雅.</p>
<p>其他几个, <code>filter()</code> 把不符合条件的值变为 <code>empty()</code>,  <code>flatMap()</code> 总是与 <code>map()</code> 方法成对的,  <code>orElseThrow()</code> 在有值时直接返回, 无值时抛出想要的异常.</p>
<p>一句话小结: 使用 <code>Optional</code> 时尽量不直接调用 <code>Optional.get()</code> 方法, <code>Optional.isPresent()</code> 更应该被视为一个私有方法, 应依赖于其他像 <code>Optional.orElse()</code>, <code>Optional.orElseGet()</code>, <code>Optional.map()</code> 等这样的方法.</p>
<p>最后, 最好的理解 Java 8 <code>Optional</code> 的方法莫过于看它的源代码 <code>java.util.Optional</code>, 阅读了源代码才能真真正正的让你解释起来最有底气, <code>Optional</code> 的方法中基本都是内部调用  <code>isPresent() </code>判断, 真时处理值, 假时什么也不做.</p>
<p>参考链接:</p>
<p><a class="link"   href="http://blog.jhades.org/java-8-how-to-use-optional/" >Java 8 Optional: How to Use it<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" >Tired of Null Pointer Exceptions? Consider Using Java SE 8′s Optional!<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins自动化部署入门（一）</title>
    <url>/p/db00.html</url>
    <content><![CDATA[<h1 id="开始使用-Jenkins"><a href="#开始使用-Jenkins" class="headerlink" title="开始使用 Jenkins"></a>开始使用 Jenkins</h1><blockquote>
<p>这一段时间，技术总监为了减少测试环境每次提交新增接口都要部署项目的时间，搞了一个jenkins持续集成github、docker，这样只要每次push代码都会自动部署，确实节省了部署的时间（不加班指日可待）。</p>
</blockquote>
<p>今天主要给大家介绍使用 Jenkins 的基本知识，顺便提一嘴jdk环境和docker如何像5G飞一般的速度安装。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>第一次使用 Jenkins，您需要：</p>
<ul>
<li><p>机器要求：</p>
<ul>
<li>256 MB 内存，建议大于 512 MB</li>
<li>10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）<br>ps: 小明使用的是linux内核centos7版本服务器,1G内存1核50G硬盘的腾讯云服务器，最近腾讯云搞活动99元一年，实在太便宜了没忍住搞了一台，后台做的和阿里云如出一辙，不愧为腾讯，大家有需要的可以点击链接了解一下，<a class="link"   href="http://sina.lt/gget%E3%80%82" >http://sina.lt/gget。<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li><p>需要安装以下软件：</p>
<ul>
<li>Java 8 ( JRE 或者 JDK 都可以<a class="link"   href="https://blog.mynamecoder.com/2019/06/13/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85jdk8/" >点击查看linux如何快速安装jdk<i class="fas fa-external-link-alt"></i></a>)</li>
<li>Docker （<a class="link"   href="https://blog.mynamecoder.com/2019/06/14/linux-centos%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker/" >查看centos版本如何安装docker<i class="fas fa-external-link-alt"></i></a>）</li>
</ul>
</li>
</ul>
<h1 id="下载并运行-Jenkins"><a href="#下载并运行-Jenkins" class="headerlink" title="下载并运行 Jenkins"></a>下载并运行 Jenkins</h1><ol>
<li>下载 Jenkins(linux 中执行<code>wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war</code>).</li>
<li>打开终端进入到下载目录.</li>
<li>运行命令 java -jar jenkins.war –httpPort=8080.</li>
<li>打开浏览器进入链接 <a class="link"   href="http://localhost:8080/" >http://localhost:8080<i class="fas fa-external-link-alt"></i></a>.</li>
<li>稍等片刻，输入控制台输出的密码，按照推荐的配置完成安装.</li>
</ol>
<p>安装完成后，您可以开始使用 Jenkins！</p>
<h1 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h1><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>left join on &amp; where</title>
    <url>/p/e319.html</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>用 <code>where</code> 是先连接然后再筛选   </li>
<li>用 <code>on</code> 是先筛选再连接</li>
<li>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。在使用<code>left jion</code>时，<code>on</code>和<code>where</code>条件的区别如下：<ul>
<li><code>on</code>条件是在生成临时表时使用的条件，它不管<code>on</code>中的条件是否为真，都会返回左边表中的记录。</li>
</ul>
<ul>
<li><code>where</code>条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有<code>left join</code>的含义（<strong>必须返回左边表的记录</strong>）了，条件不为真的就全部过滤掉。<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="假设有两张表："><a href="#假设有两张表：" class="headerlink" title="假设有两张表："></a>假设有两张表：</h3></li>
</ul>
</li>
<li>tab1:</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
</tr>
</tbody></table>
<ul>
<li>tab2:</li>
</ul>
<table>
<thead>
<tr>
<th>size</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>20</td>
<td>BBB</td>
</tr>
<tr>
<td>20</td>
<td>CCC</td>
</tr>
</tbody></table>
<h3 id="两条SQL"><a href="#两条SQL" class="headerlink" title="两条SQL:"></a>两条SQL:</h3><ol>
<li>select * form tab1 left join tab2 on (tab1.size = tab2.size) where tab2.name=’AAA’</li>
<li>select * form tab1 left join tab2 on (tab1.size = tab2.size and tab2.name=’AAA’)<h3 id="第一条SQL的过程："><a href="#第一条SQL的过程：" class="headerlink" title="第一条SQL的过程："></a>第一条SQL的过程：</h3></li>
<li>中间表<br>on条件:<br>tab1.size = tab2.size</li>
</ol>
<table>
<thead>
<tr>
<th><code>tab1.id</code></th>
<th><code>tab1.size</code></th>
<th><code>tab2.size</code></th>
<th><code>tab2.name</code></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>20</td>
<td>BBB</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>20</td>
<td>CCC</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
<td>(null)</td>
<td>(null)</td>
</tr>
<tr>
<td>2. 再对中间表进行过滤</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>where条件:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>tab2.name</code> = ’AAA’</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>tab1.id</code></th>
<th><code>tab1.size</code></th>
<th><code>tab2.size</code></th>
<th><code>tab2.name</code></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
</tbody></table>
<h3 id="第二条SQL的过程："><a href="#第二条SQL的过程：" class="headerlink" title="第二条SQL的过程："></a>第二条SQL的过程：</h3><ol>
<li>中间表<br>on条件:<br>tab1.size = tab2.size and tab2.name=’AAA’<br>(<em>条件不为真也会返回左表中的记录</em>)</li>
</ol>
<table>
<thead>
<tr>
<th><code>tab1.id</code></th>
<th><code>tab1.size</code></th>
<th><code>tab2.size</code></th>
<th><code>tab2.name</code></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>(null)</td>
<td>(null)</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
<td>(null)</td>
<td>(null)</td>
</tr>
</tbody></table>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>其实以上结果的关键原因就是left join,right join,full join的特殊性，<strong>不管on上的条件是否为真都会返回left或right表中的记录</strong>，full则具有left和right的特性的并集。 而inner jion没这个特殊性，则条件放在on中和where中，返回的结果集是相同的。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>linux centos如何安装docker</title>
    <url>/p/4169.html</url>
    <content><![CDATA[<h1 id="CentOS-Docker-安装"><a href="#CentOS-Docker-安装" class="headerlink" title="CentOS Docker 安装"></a>CentOS Docker 安装</h1><p>Docker支持以下的CentOS版本：</p>
<ul>
<li>CentOS 7 (64-bit)</li>
<li>CentOS 6.5 (64-bit) 或更高的版本<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</li>
</ul>
<h2 id="使用-yum-安装（CentOS-7下）"><a href="#使用-yum-安装（CentOS-7下）" class="headerlink" title="使用 yum 安装（CentOS 7下）"></a>使用 yum 安装（CentOS 7下）</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p>
<p>通过 <code>uname -r </code>命令查看你当前的内核版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@VM_0_9_centos ~]# uname -r</span><br><span class="line">3.10.0-514.26.2.el7.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。<br>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。<br>本文介绍 Docker CE 的安装使用。</p>
<p>移除旧的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>安装一些必要的系统工具：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>添加软件源信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>更新 yum 缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>安装 Docker-ce：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure>
<p>启动 Docker 后台服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>测试运行 hello-world</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@coderxm ~]# docker run hello-world</span><br></pre></td></tr></table></figure>
<p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。</p>
<h2 id="使用脚本安装-Docker"><a href="#使用脚本安装-Docker" class="headerlink" title="使用脚本安装 Docker"></a>使用脚本安装 Docker</h2><ol>
<li>使用 sudo 或 root 权限登录 Centos。</li>
<li>确保 yum 包更新到最新。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li>
<li>执行 Docker 安装脚本。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>
<p>执行这个脚本会添加 docker.repo 源并安装 Docker。</p>
<ol start="4">
<li>启动 Docker 进程。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li>验证 docker 是否安装成功并在容器中执行一个测试的镜像。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
可以看出来控制台有输出“Hello from Docker!“等字样，到此，Docker 在 CentOS 系统的安装完成。</li>
</ol>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a class="link"   href="http://hub-mirror.c.163.com./" >http://hub-mirror.c.163.com。<i class="fas fa-external-link-alt"></i></a></p>
<p>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。</p>
<p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除-Docker-CE"><a href="#删除-Docker-CE" class="headerlink" title="删除 Docker CE"></a>删除 Docker CE</h2><p>执行以下命令来删除 Docker CE：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce</span><br><span class="line">sudo rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令（持续更新）</title>
    <url>/p/c01e.html</url>
    <content><![CDATA[<h2 id="查看系统磁盘空间"><a href="#查看系统磁盘空间" class="headerlink" title="查看系统磁盘空间"></a>查看系统磁盘空间</h2><h3 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h </span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.9G     0  7.9G   0% &#x2F;dev</span><br><span class="line">tmpfs           1.6G  3.6M  1.6G   1% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;vda1        99G   61G   33G  65% &#x2F;</span><br><span class="line">tmpfs           7.9G  2.6G  5.3G  33% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vdb1       493G   57G  411G  13% &#x2F;media</span><br><span class="line">tmpfs           1.6G     0  1.6G   0% &#x2F;run&#x2F;user&#x2F;1000</span><br></pre></td></tr></table></figure>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table>
<thead>
<tr>
<th>Filesystem</th>
<th>Size</th>
<th>Used</th>
<th>Avail</th>
<th>use</th>
<th>Mounted on</th>
</tr>
</thead>
<tbody><tr>
<td>文件系统</td>
<td>分区大小</td>
<td>已使用容量</td>
<td>还可以使用容量</td>
<td>已用百分比</td>
<td>挂载点</td>
</tr>
</tbody></table>
<h3 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h3><p>*<em>“df”**可以理解为：</em>disk filesystem*，意为”磁盘文件系统”，我们就是为了查看磁盘占用情况；</p>
<p>**”-h”**我们通过<code>df --help</code>会发现，这个参数表示查询磁盘占用空间会以K，M，G为单位，提高信息的可读性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)</span><br></pre></td></tr></table></figure>
<h2 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h2><h3 id="推荐使用-1"><a href="#推荐使用-1" class="headerlink" title="推荐使用"></a>推荐使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure>
<p>进入到你想查看的文件夹下，运行即可</p>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28M	.</span><br></pre></td></tr></table></figure>
<h3 id="命令解释-1"><a href="#命令解释-1" class="headerlink" title="命令解释"></a>命令解释</h3><p><strong>du</strong> 的英文原义为 <strong>disk usage</strong>，含义为显示磁盘空间的使用情况，用于查看当前目录的总大小。</p>
<p>运行<strong>du –help</strong> 查看解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-s, --summarize       display only a total for each argument</span><br><span class="line">-h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)</span><br></pre></td></tr></table></figure>
<p><strong>-s</strong>表示展示总数</p>
<p><strong>-h</strong>同样是提高信息的可读性</p>
<h3 id="未完，待续……"><a href="#未完，待续……" class="headerlink" title="未完，待续……"></a>未完，待续……</h3><h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>快速优雅的在linux服务器上安装jdk8</title>
    <url>/p/5a53.html</url>
    <content><![CDATA[<blockquote>
<p>对于开发者来说，安装jdk按理说是非常简单的事，但在linux下安装着实费了我这个一直玩windows的小白不少劲。这里简单把步骤梳理下，希望能帮助像我这样的纯小白人士少踩点坑。</p>
</blockquote>
<p>这里介绍两种安装方式：</p>
<ul>
<li>yum安装（力荐）</li>
<li>从官网下载包安装</li>
</ul>
<h1 id="获得一台linux服务器"><a href="#获得一台linux服务器" class="headerlink" title="获得一台linux服务器"></a>获得一台linux服务器</h1><p>要在linux下安装jdk，首先你得先有一台linux服务器，作为小白，手头的机器肯定都是windows的，搞个虚拟机安装对我这种小白简直是折磨人；这里使用最简单的方式获得一台linux服务器，就是从阿里云或者腾讯云上租一台。镜像选择CentOS7.3 64位。</p>
<p><img src="https://s2.ax1x.com/2019/06/13/VhECpn.png"></p>
<h1 id="yum安装jdk"><a href="#yum安装jdk" class="headerlink" title="yum安装jdk"></a>yum安装jdk</h1><p>在linux上使用yum安装是非常粗暴无脑的，但仍然有需要注意的点，不然会掉坑里。这里说一下步骤。</p>
<ul>
<li>执行命令<code>yum -y list java*</code>查看可安装java版本。执行成功后可以看见如下的结果</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/06/13/VhAzkQ.png"></p>
<ul>
<li><p>选择一个java版本进行安装，这里我们希望安装java1.8，因为我们的机器是64位的，所以选择安装<strong>java-1.8.0-openjdk-devel.x86_64</strong>。<br>这里有个地方要注意，上图中我用红框圈起来的两个java版本，要选择-devel的安装，因为这个安装的是jdk，而那个不带-devel的安装完了其实是jre。</p>
</li>
<li><p>执行命令<code>yum install -y java-1.8.0-openjdk-devel.x86_64</code>。执行完后会看见控制台刷出很多输出。<br>耐心等待至自动安装完成</p>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/06/13/VhAvTg.png"></p>
<ul>
<li>输入<code>java -version</code>查看已安装的jdk版本，当出现如下输出表示安装成功。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/06/13/VhAj0S.png"></p>
<ul>
<li>你可能好奇，yum安装的jdk，被安装到哪里去了？可以执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ql java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>
<p>获取安装目录，你发现在<code>/usr/lib/jvm</code>目录下可以找到他们。</p>
<p><img src="https://s2.ax1x.com/2019/06/13/VhAXm8.png"></p>
<p>至此，yum安装jdk完成。</p>
<h1 id="从官网下载包安装jdk"><a href="#从官网下载包安装jdk" class="headerlink" title="从官网下载包安装jdk"></a>从官网下载包安装jdk</h1><p>如果你不喜欢yum安装的方式，想要使用官方提供的安装包进行传统方式的安装，可以使用如下步骤。</p>
<ul>
<li>执行命令<code>useradd java</code>，新建用户java</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/06/13/VhEpfs.png"></p>
<ul>
<li><p>执行命令<code>passwd java</code>，设置java用户密码<br><img src="https://s2.ax1x.com/2019/06/13/VhMEFK.png"></p>
</li>
<li><p>进入oracle官网，java8下载页面<a class="link"   href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html%E3%80%82" >http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html。<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/06/13/VhESYj.png"></p>
<ul>
<li><p>选择<strong>Accept License Agreement</strong>，点击<strong>jdk-8u131-linux-x64.tar.gz</strong>，获取到下载链接。注意，获取到的下载链接有时效（具体有效多久不清楚，反正隔天肯定不能用），请尽快复制到linux上进行下载。</p>
</li>
<li><p>进入到<code>/home/java</code>目录下，输入wget +地址，即可开始下载<br><img src="https://s2.ax1x.com/2019/06/13/VhEE0U.png"></p>
</li>
</ul>
<ul>
<li>等待下载成功<br><img src="https://s2.ax1x.com/2019/06/13/VhEPlq.png"></li>
</ul>
<ul>
<li>查看文件，发现下载后的文件名有奇怪的后缀，重命名下载文件</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/06/13/VhEi60.png"></p>
<ul>
<li>输入命令<code>tar zxvf jdk-8u131-linux-x64.tar.gz</code>解压安装包<br>如果提示没有<code>tar</code>命令，输入<code>yum install -y tar</code>先安装tar。<br><img src="https://s2.ax1x.com/2019/06/13/VhEV7F.png"></li>
</ul>
<ul>
<li>输入命令<code>vim /etc/profile</code>，打开环境变量配置文件<br>在文件底部输入以下信息，并保存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;home&#x2F;java&#x2F;jdk1.8.0_131</span><br><span class="line">JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export JRE_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure>
<ul>
<li>输入命令<code>source /etc/profile</code>，刷新环境变量配置文件使其立刻生效；输入<code>java -version</code>查看已安装的jdk版本</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/06/13/VhEAmT.png"></p>
<p>你要以为这就完成了，那就掉坑里了。虽然大部分时候这就够了，但还有一步操作最好做一下。建一个<code>/usr/bin/java</code>的java的超链接。<br><code>ln -s /home/java/jdk1.8.0_131/bin/java /usr/bin/java</code></p>
<p>为什么要建这个超链接，因为一些自己注册的linux服务（如springboot的jar注册的服务），默认情况下从<code>/usr/bin/java</code>路径使用java，yum安装的时候，这个超链接会自动创建，如果你自己下载包安装的话，这个超链接就需要你手动创建了。<br>至此，从官网下载包安装jdk完成。</p>
<h2 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h2><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>牢记maven的scope属性</title>
    <url>/p/2bdc.html</url>
    <content><![CDATA[<blockquote>
<p>小明今天带大家回顾一下maven依赖的作用域</p>
</blockquote>
<p>在POM4中，<code>&lt;dependency&gt;</code>引入了<code>&lt;scope&gt;</code>，它主要管理依赖的部署。目前<code>&lt;scope&gt;</code>可以使用5个值： </p>
<ul>
<li>compile，缺省值，适用于所有阶段，会随着项目一起发布。 </li>
<li>provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 </li>
<li>runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 </li>
<li>test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 </li>
<li>system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</li>
</ul>
<p>依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围：</p>
<h2 id="compile-（编译范围）"><a href="#compile-（编译范围）" class="headerlink" title="compile （编译范围）"></a>compile （编译范围）</h2><p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。</p>
<h2 id="provided-（已提供范围）"><a href="#provided-（已提供范围）" class="headerlink" title="provided （已提供范围）"></a>provided （已提供范围）</h2><p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。</p>
<h2 id="runtime-（运行时范围）"><a href="#runtime-（运行时范围）" class="headerlink" title="runtime （运行时范围）"></a>runtime （运行时范围）</h2><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC<br>驱动实现。</p>
<h2 id="test-（测试范围）"><a href="#test-（测试范围）" class="headerlink" title="test （测试范围）"></a>test （测试范围）</h2><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p>
<h2 id="system-（系统范围）"><a href="#system-（系统范围）" class="headerlink" title="system （系统范围）"></a>system （系统范围）</h2><p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis常用总结</title>
    <url>/p/1b5.html</url>
    <content><![CDATA[<h1 id="foreach之前对list进行判空"><a href="#foreach之前对list进行判空" class="headerlink" title="foreach之前对list进行判空"></a>foreach之前对list进行判空</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;if test&#x3D;&quot;list !&#x3D; null and list.size() &gt; 0&quot;&gt;</span><br><span class="line">  _claimreview.id in</span><br><span class="line">  &lt;foreach item&#x3D;&quot;item&quot; index&#x3D;&quot;index&quot; collection&#x3D;&quot;list&quot; open&#x3D;&quot;(&quot; separator&#x3D;&quot;,&quot; close&#x3D;&quot;)&quot;&gt;  </span><br><span class="line">    #&#123;item&#125;</span><br><span class="line">  &lt;&#x2F;foreach&gt;</span><br><span class="line">&lt;&#x2F;if&gt;</span><br></pre></td></tr></table></figure>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql误删一张表</title>
    <url>/p/6ca7.html</url>
    <content><![CDATA[<blockquote>
<p>大家开发过程中，难免会存在误删数据库表的情况，可见，数据库的备份机制需要引起大家的重视，本文主要介绍一下，拥有备份文件（.frm 和 .ibd）的情况下，如何快速恢复该表。</p>
</blockquote>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>作者使用的正式数据库是阿里云的rds，一天午后，使用navicat工具误操作删除了一张日志表，但幸运的是，设置了阿里云的备份机制。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li>首先从阿里云备份记录中下载最新的备份tar或者zip文件，然后解压会得到数据库中的文件，找到该日志表对应的.frm和.ibd。<br><a name="back"></a></li>
<li>查看被删除数据库版本和恢复至的数据库版本是否一致，如果一致请继续，如果不一致，请<a href='#fn1b'>查看下面</a>的版本不一致问题如何解决；</li>
<li>新建一个数据库（名称任意），在该数据库中新建一张表（名称与你要恢复的表名称相同），最好结构也有，数据无所谓，引擎必须是innode，然后删除新建的表空间: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除该表的.idb</span><br><span class="line">ALTER TABLE table_name DISCARD TABLESPACE;</span><br></pre></td></tr></table></figure></li>
<li>再将该表对应的 .ibd 备份文件替换新表的.ibd文件（/var/lib/mysql/test  这是test数据库的文件目录），执行如下命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 修改权限</span><br><span class="line">chown mysql:mysql tablename.ibd</span><br></pre></td></tr></table></figure></li>
<li>重新导入表空间  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table &lt;table name&gt; import tablespace;</span><br></pre></td></tr></table></figure>
<a name='fn1b'></a><br>这一步可能出现版本问题，因为之前版本的数据库是5.6，新的数据库是5.7<ul>
<li>版本的解决办法<br><img src="/images/mysql/version_wrong.png" alt="pic"><br>究其原因是从MySQL5.7版本中innodb_file_format参数（该参数表示innodb文件格式）的默认值发生了变化，在MySQL5.7以前innodb_file_format参数默认是Antelope，而默认的行格式是（ROW_FORMAT）是COMPACT，从MySQL5.7以后版本innodb_file_format默认值为Barracuda，默认的行格式是（ROW_FORMAT）是DYNAMIC，所以需要在创建表结构时指定row_format=compact<br>因此我们需要重新建一张表</li>
</ul>
</li>
</ul>
<ol>
<li>在新库中删除对应的表，并删除新库中存在的数据文件（/var/lib/mysql/test）；</li>
<li>创建新的表结构并指定行格式为compact。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;tablename&#96; (</span><br><span class="line">  ...</span><br><span class="line">) ROW_FORMAT&#x3D;COMPACT</span><br></pre></td></tr></table></figure>
之后的步骤<a href="#back">继续执行上面的步骤</a></li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql函数之FIND_IN_SET()</title>
    <url>/p/f887.html</url>
    <content><![CDATA[<blockquote>
<p><a class="link"   href="https://www.fujieace.com/mysql/functions/find_in_set.html" >详情链接<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>FIND_IN_SET(str,strlist)</p>
<p>第一个参数str是要查找的字符串。<br>第二个参数strlist是要搜索的<strong>逗号分隔</strong>的字符串列表。</p>
<p>假如字符串str 在由N 子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。一个字符串列表就是一个由一些被‘,’符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则 FIND_IN_SET() 函数被优化，使用比特计算。如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。<em>这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</em></p>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>现在有一张users表，如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>user_name</th>
<th>emails</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小张</td>
<td><a class="link"   href="mailto:&#97;&#64;&#x66;&#x75;&#x6a;&#105;&#x65;&#x61;&#99;&#101;&#46;&#99;&#111;&#x6d;" >&#97;&#64;&#x66;&#x75;&#x6a;&#105;&#x65;&#x61;&#99;&#101;&#46;&#99;&#111;&#x6d;<i class="fas fa-external-link-alt"></i></a>,b@fujieace.com,<a class="link"   href="mailto:&#x63;&#64;&#x66;&#x75;&#x6a;&#x69;&#101;&#x61;&#99;&#101;&#46;&#99;&#111;&#x6d;" >&#x63;&#64;&#x66;&#x75;&#x6a;&#x69;&#101;&#x61;&#99;&#101;&#46;&#99;&#111;&#x6d;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>2</td>
<td>小王</td>
<td><a class="link"   href="mailto:&#x61;&#97;&#x40;&#x66;&#117;&#x6a;&#105;&#101;&#97;&#99;&#x65;&#x2e;&#99;&#111;&#x6d;" >&#x61;&#97;&#x40;&#x66;&#117;&#x6a;&#105;&#101;&#97;&#99;&#x65;&#x2e;&#99;&#111;&#x6d;<i class="fas fa-external-link-alt"></i></a>,bb@fujieace.com,<a class="link"   href="mailto:&#99;&#99;&#x40;&#102;&#x75;&#106;&#x69;&#101;&#97;&#99;&#x65;&#46;&#x63;&#111;&#109;" >&#99;&#99;&#x40;&#102;&#x75;&#106;&#x69;&#101;&#97;&#99;&#x65;&#46;&#x63;&#111;&#109;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>3</td>
<td>李四</td>
<td><a class="link"   href="mailto:&#97;&#x61;&#x40;&#102;&#x75;&#106;&#x69;&#x65;&#97;&#x63;&#x65;&#x2e;&#x63;&#x6f;&#x6d;" >&#97;&#x61;&#x40;&#102;&#x75;&#106;&#x69;&#x65;&#97;&#x63;&#x65;&#x2e;&#x63;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a>,b@fujieace.com,<a class="link"   href="mailto:&#x64;&#x40;&#102;&#117;&#106;&#x69;&#x65;&#x61;&#99;&#x65;&#x2e;&#x63;&#x6f;&#109;" >&#x64;&#x40;&#102;&#117;&#106;&#x69;&#x65;&#x61;&#99;&#x65;&#x2e;&#x63;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>4</td>
<td>王五</td>
<td><a class="link"   href="mailto:&#97;&#97;&#64;&#102;&#117;&#x6a;&#105;&#x65;&#x61;&#x63;&#101;&#x2e;&#99;&#111;&#x6d;" >&#97;&#97;&#64;&#102;&#117;&#x6a;&#105;&#x65;&#x61;&#x63;&#101;&#x2e;&#99;&#111;&#x6d;<i class="fas fa-external-link-alt"></i></a>,e@fujieace.com,<a class="link"   href="mailto:&#102;&#x40;&#102;&#117;&#x6a;&#x69;&#x65;&#97;&#99;&#x65;&#x2e;&#x63;&#x6f;&#x6d;" >&#102;&#x40;&#102;&#117;&#x6a;&#x69;&#x65;&#97;&#99;&#x65;&#x2e;&#x63;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a></td>
</tr>
</tbody></table>
<p>问：我们如何用sql查找所有“emails”字段中有“<a class="link"   href="mailto:&#97;&#97;&#64;&#x66;&#117;&#106;&#105;&#101;&#97;&#99;&#101;&#x2e;&#x63;&#x6f;&#x6d;" >&#97;&#97;&#64;&#x66;&#117;&#106;&#105;&#101;&#97;&#99;&#101;&#x2e;&#x63;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a>”的用户？</p>
<p>答：用以下sql即可实现；</p>
<p>select * from users where FIND_IN_SET(‘aa@fujieace.com’,emails);</p>
<h2 id="拓展知识："><a href="#拓展知识：" class="headerlink" title="拓展知识："></a>拓展知识：</h2><p>mysql&gt; SELECT FIND_IN_SET(‘b’,’a,b,c,d’);<br>-&gt; 2<br>因为：b 在strlist集合中放在2的位置，计算从1开始，不是从0开始；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select FIND_IN_SET(&#39;1&#39;,&#39;1&#39;);</span><br></pre></td></tr></table></figure>
<p>返回值：就是1；<br>这时候的strlist集合有点特殊，只有一个字符串，其实就是要求前一个字符串一定要在后一个字符串集合中才返回 大于0的数；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select FIND_IN_SET(&#39;2&#39;,&#39;1，2&#39;);返回2</span><br><span class="line">select FIND_IN_SET(&#39;6&#39;,&#39;1&#39;); 返回0</span><br></pre></td></tr></table></figure>


<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>select * from fujieace where FIND_IN_SET(id,’1,2,3,4,5’);<br>使用find_in_set函数一次返回多条记录,id 是一个表的字段 然后每条记录分别是id等于1，2，3，4，5的时候,有点类似in （集合）,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from fujieace where id in (1,2,3,4,5);</span><br></pre></td></tr></table></figure>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote>
<p>详情：<a class="link"   href="https://www.cnblogs.com/xiaoxi/p/5942805.html" >根据父id递归查询子列表<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DEFINER&#x3D;&#96;用户名&#96;@&#96;%&#96; FUNCTION &#96;方法名&#96;(rootId INT) RETURNS varchar(1000) CHARSET utf8</span><br><span class="line">BEGIN </span><br><span class="line">        DECLARE sTemp VARCHAR(1000); </span><br><span class="line">        DECLARE sTempChd VARCHAR(1000); </span><br><span class="line"></span><br><span class="line">        SET sTemp &#x3D; &#39;^&#39;; </span><br><span class="line">        SET sTempChd &#x3D;cast(rootId as CHAR); </span><br><span class="line"> </span><br><span class="line">        WHILE sTempChd is not null DO </span><br><span class="line">            SET sTemp &#x3D; concat(sTemp,&#39;,&#39;,sTempChd); </span><br><span class="line">            SELECT group_concat(id) INTO sTempChd FROM goods_category c where FIND_IN_SET(c.parent_id,sTempChd)&gt;0; </span><br><span class="line">        END WHILE; </span><br><span class="line">        RETURN sTemp; </span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://blog.csdn.net/dream_broken/article/details/69554303" >问题：组合递归函数数据不全<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用操作</title>
    <url>/p/72bf.html</url>
    <content><![CDATA[<h2 id="查询数据库所有的表"><a href="#查询数据库所有的表" class="headerlink" title="查询数据库所有的表"></a>查询数据库所有的表</h2><p>（用逗号隔开）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT GROUP_CONCAt( table_name ) FROM information_schema.TABLES WHERE table_schema &#x3D; &#39;数据库名&#39; AND table_type &#x3D; &#39;base table&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="查询数据库中某张表所有的字段"><a href="#查询数据库中某张表所有的字段" class="headerlink" title="查询数据库中某张表所有的字段"></a>查询数据库中某张表所有的字段</h2><p>（用逗号隔开）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT GROUP_CONCAT( column_name ) FROM information_schema.COLUMNS WHERE table_name &#x3D; &#39;表名&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="计算两个经纬度之间的距离-lon经度，lat纬度"><a href="#计算两个经纬度之间的距离-lon经度，lat纬度" class="headerlink" title="计算两个经纬度之间的距离,lon经度，lat纬度"></a>计算两个经纬度之间的距离,lon经度，lat纬度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DEFINER&#x3D;&#96;lkhd&#96;@&#96;%&#96; FUNCTION &#96;func_distance&#96;( </span><br><span class="line">lon1 DOUBLE, </span><br><span class="line">lat1 DOUBLE, </span><br><span class="line">lon2 DOUBLE, </span><br><span class="line">lat2 DOUBLE </span><br><span class="line">) RETURNS double</span><br><span class="line">RETURN 6371 * acos( </span><br><span class="line">cos(radians(lat1)) * cos(radians(lat2)) * cos( </span><br><span class="line">radians(lon2) - radians(lon1) </span><br><span class="line">) + sin(radians(lat1)) * sin(radians(lat2)) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql日期相关</title>
    <url>/p/3816.html</url>
    <content><![CDATA[<h2 id="DATE-ADD-date-expr-type"><a href="#DATE-ADD-date-expr-type" class="headerlink" title="DATE_ADD(date,expr,type)"></a>DATE_ADD(date,expr,type)</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><p>函数向日期添加指定的时间间隔</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>date 参数是合法的日期表达式。expr 参数是您希望添加的时间间隔。<br>type 参数可以常用下列值：</p>
<table>
<thead>
<tr>
<th>Type值</th>
</tr>
</thead>
<tbody><tr>
<td>SECOND</td>
</tr>
<tr>
<td>MINUTE</td>
</tr>
<tr>
<td>HOUR</td>
</tr>
<tr>
<td>DAY</td>
</tr>
<tr>
<td>WEEK</td>
</tr>
<tr>
<td>MONTH</td>
</tr>
<tr>
<td>QUARTER</td>
</tr>
<tr>
<td>YEAR</td>
</tr>
</tbody></table>
<h2 id="TIMESTAMPDIFF-interval-datetime-expr1-datetime-expr2"><a href="#TIMESTAMPDIFF-interval-datetime-expr1-datetime-expr2" class="headerlink" title="TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2)"></a>TIMESTAMPDIFF(interval,datetime_expr1,datetime_expr2)</h2><h3 id="定义和用法-1"><a href="#定义和用法-1" class="headerlink" title="定义和用法"></a>定义和用法</h3><p>Mysql计算两个日期的时间差函数</p>
<p>其结果的单位由<code>interval</code> 参数给出,该参数必须是以下值的其中一个： <code>FRAC_SECOND</code>、<code>SECOND</code>、 <code>MINUTE</code>、 <code>HOUR</code>、 <code>DAY</code>、 <code>WEEK</code>、 <code>MONTH</code>、 <code>QUARTER</code>或 <code>YEAR</code>。</p>
<h2 id="查询当天、本周，本月，上一个月的数据"><a href="#查询当天、本周，本月，上一个月的数据" class="headerlink" title="查询当天、本周，本月，上一个月的数据"></a>查询当天、本周，本月，上一个月的数据</h2><ul>
<li>今天<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from 表名 where to_days(时间字段名) &#x3D; to_days(now());</span><br></pre></td></tr></table></figure></li>
<li>昨天<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) &lt;&#x3D; 1</span><br></pre></td></tr></table></figure></li>
<li>近7天<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;&#x3D; date(时间字段名)</span><br></pre></td></tr></table></figure></li>
<li>近30天<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;&#x3D; date(时间字段名)</span><br></pre></td></tr></table></figure></li>
<li>本月<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, &#39;%Y%m&#39; ) &#x3D; DATE_FORMAT( CURDATE( ) , &#39;%Y%m&#39; )</span><br></pre></td></tr></table></figure></li>
<li>上一月<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , &#39;%Y%m&#39; ) , date_format( 时间字段名, &#39;%Y%m&#39; ) ) &#x3D;1</span><br></pre></td></tr></table></figure></li>
<li>查询本季度数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from &#96;ht_invoice_information&#96; where QUARTER(create_date)&#x3D;QUARTER(now());</span><br></pre></td></tr></table></figure></li>
<li>查询上季度数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from &#96;ht_invoice_information&#96; where QUARTER(create_date)&#x3D;QUARTER(DATE_SUB(now(),interval 1 QUARTER));</span><br></pre></td></tr></table></figure></li>
<li>查询本年数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from &#96;ht_invoice_information&#96; where YEAR(create_date)&#x3D;YEAR(NOW());</span><br></pre></td></tr></table></figure></li>
<li>查询上年数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from &#96;ht_invoice_information&#96; where year(create_date)&#x3D;year(date_sub(now(),interval 1 year));</span><br></pre></td></tr></table></figure></li>
<li>查询当前这周的数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,&#39;%Y-%m-%d&#39;)) &#x3D; YEARWEEK(now());</span><br></pre></td></tr></table></figure></li>
<li>查询上周的数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,&#39;%Y-%m-%d&#39;)) &#x3D; YEARWEEK(now())-1;</span><br></pre></td></tr></table></figure></li>
<li>查询上个月的数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,submittime from enterprise where date_format(submittime,&#39;%Y-%m&#39;)&#x3D;date_format(DATE_SUB(curdate(), INTERVAL 1 MONTH),&#39;%Y-%m&#39;)</span><br><span class="line"></span><br><span class="line">select * from user where DATE_FORMAT(pudate,&#39;%Y%m&#39;) &#x3D; DATE_FORMAT(CURDATE(),&#39;%Y%m&#39;) ; </span><br><span class="line"></span><br><span class="line">select * from user where WEEKOFYEAR(FROM_UNIXTIME(pudate,&#39;%y-%m-%d&#39;)) &#x3D; WEEKOFYEAR(now()) </span><br><span class="line"></span><br><span class="line">select * from user where MONTH(FROM_UNIXTIME(pudate,&#39;%y-%m-%d&#39;)) &#x3D; MONTH(now()) </span><br><span class="line"></span><br><span class="line">select * from user where YEAR(FROM_UNIXTIME(pudate,&#39;%y-%m-%d&#39;)) &#x3D; YEAR(now()) and MONTH(FROM_UNIXTIME(pudate,&#39;%y-%m-%d&#39;)) &#x3D; MONTH(now()) </span><br><span class="line"></span><br><span class="line">select * from user where pudate between  上月最后一天  and 下月第一天 </span><br></pre></td></tr></table></figure></li>
<li>查询当前月份的数据 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,submittime from enterprise   where date_format(submittime,&#39;%Y-%m&#39;)&#x3D;date_format(now(),&#39;%Y-%m&#39;)</span><br></pre></td></tr></table></figure></li>
<li>查询距离当前现在6个月的数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,submittime from enterprise where submittime between date_sub(now(),interval 6 month) and now();</span><br></pre></td></tr></table></figure>
关注微信公众号，获取更多资源<br><img src="https://i.ibb.co/hZ4TbWB/coderxm-qr.jpg" alt="公众号"></li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引优化初体验-了解索引</title>
    <url>/p/aab3.html</url>
    <content><![CDATA[<h1 id="Mysql的历史"><a href="#Mysql的历史" class="headerlink" title="Mysql的历史"></a>Mysql的历史</h1><p>简单回顾一下Mysql的历史，Mysql 是一个关系型数据库管理系统，由瑞典 Mysql AB 公司开发，目前属于 Oracle 公司。关系型数据库​将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<a id="more"></a>

<h1 id="Mysql的优势"><a href="#Mysql的优势" class="headerlink" title="Mysql的优势"></a>Mysql的优势</h1><ul>
<li>Mysql 是开源的，所以你不需要支付额外的费用。</li>
<li>Mysql 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>Mysql 使用标准的 SQL 数据语言形式。</li>
<li>Mysql 可以运行于多个系统上，并且支持多种语言。</li>
<li>Mysql 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 Mysql 系统。</li>
</ul>
<h1 id="索引的存储分类"><a href="#索引的存储分类" class="headerlink" title="索引的存储分类"></a>索引的存储分类</h1><p>索引是在MYSQL的存储引擎层中实现的，而不是在服务层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MYSQL目前提供了一下4种索引。</p>
<h2 id="Normal-普通索引"><a href="#Normal-普通索引" class="headerlink" title="Normal 普通索引"></a>Normal 普通索引</h2><p>基本的索引类型，大多数情况下都可以使用。</p>
<h2 id="Unique-唯一索引"><a href="#Unique-唯一索引" class="headerlink" title="Unique 唯一索引"></a>Unique 唯一索引</h2><p>表示唯一的，不允许重复的索引，如果该字段信息保证不会重复，例如身份证号用作索引时，可设置为unique。Unique和Primary Key为列或列集合提供了唯一性的保证，Primary Key是拥有自动定义的Unique约束，但是每个表中可以有多个Unique约束，但是只能有一个Primary Key约束。</p>
<h2 id="Full-Text-全文索引"><a href="#Full-Text-全文索引" class="headerlink" title="Full Text 全文索引"></a>Full Text 全文索引</h2><p>全文索引可以在varchar、char、text类型的列上创建。MyISAM支持全文索引，InnoDB在mysql5.6之后支持了全文索引。FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。</p>
<h2 id="SPATIAL-空间索引"><a href="#SPATIAL-空间索引" class="headerlink" title="SPATIAL 空间索引"></a>SPATIAL 空间索引</h2><p>空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY(几何)、POINT(点)、LINESTRING(线)、POLYGON(多边形)。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。</p>
<h1 id="我对索引的一些看法"><a href="#我对索引的一些看法" class="headerlink" title="我对索引的一些看法"></a>我对索引的一些看法</h1><ul>
<li>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</li>
<li>数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。</li>
<li>最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。</li>
<li>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</li>
<li>当你发现自己的查询速度慢的时候，最快解决问题的方法就是使用索引。索引的使用是影响查询速度的重要因素。在使用索引之前其他的优化查询的动作纯粹是浪费时间，只有合理地使用索引之后，才有必要考虑其他优化方式。</li>
</ul>
<p>索引相关的概念先到这里，后续会针对索引的实际应用和大家一起继续交流。</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引优化初体验-使用索引</title>
    <url>/p/3fc1.html</url>
    <content><![CDATA[<blockquote>
<p>上回介绍了几种常见的索引类型：normal、unique、fulltext、spatial，本次，主要讲解索引的工作原理及针对normal索引的创建、删除进行举例。</p>
</blockquote>
<h1 id="索引是如何工作的"><a href="#索引是如何工作的" class="headerlink" title="索引是如何工作的"></a>索引是如何工作的</h1><a id="more"></a>
<p>首先，我们先创建t_user_action_log表，方便下面进行演示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_user_action_log&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键id&#39;,</span><br><span class="line">  &#96;name&#96; VARCHAR(32) DEFAULT NULL COMMENT &#39;用户名&#39;,</span><br><span class="line">  &#96;ip_address&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;IP地址&#39;,</span><br><span class="line">  &#96;action&#96; INT4 DEFAULT NULL COMMENT &#39;操作：1-登录，2-登出，3-购物，4-退货，5-浏览&#39;,</span><br><span class="line">  &#96;create_time&#96; TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<p>假如我们要筛选 action为2的所有记录，SQL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id, name, ip_address FROM t_user_action_log WHERE &#96;action&#96;&#x3D;2;</span><br></pre></td></tr></table></figure>
<p>通过查询分析器explain分析这条查询语句(就在这个语句前面加上<strong>explain</strong>)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, name, ip_address FROM t_user_action_log WHERE &#96;action&#96;&#x3D;2;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user_action_log</td>
<td></td>
<td>ALL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>100.00</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>其中type为ALL表示要进行全表扫描。这样效率无疑是极慢的。</p>
<p>下面为action列添加索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user_action_log ADD INDEX (&#96;action&#96;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后再次执行查询分析，结果如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user_action_log</td>
<td></td>
<td>ref</td>
<td>action</td>
<td>action</td>
<td>5</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td></td>
</tr>
</tbody></table>
<p>我们看到这次查询就使用索引了。加索引前Extra的值是Using Where，type的值为ALL，加索引后Extra的值为空，type的值为ref，表示使用引用。</p>
<p>那么为什么索引会提高查询速度呢？原因是索引会根据索引值进行分类，这样就不用再进行全表扫描了。</p>
<p><img src="https://s2.ax1x.com/2019/07/04/ZaPAKI.png" alt="示意图"></p>
<p>比如上图，action值为2的索引值分类存储在了索引空间，可以快速地查询到索引值所对应的列。</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>下面介绍一下如何使用SQL创建、查看和删除索引。</p>
<p>创建索引的三种方式：</p>
<h2 id="使用CREATE-INDEX创建，语法如下："><a href="#使用CREATE-INDEX创建，语法如下：" class="headerlink" title="使用CREATE INDEX创建，语法如下："></a>使用CREATE INDEX创建，语法如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexName ON tableName (columnName(length));</span><br></pre></td></tr></table></figure>
<p>例如我们对ip_address这一列创建一个长度为16的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_ip_addr ON t_user_action_log (ip_address(16));</span><br></pre></td></tr></table></figure>
<h2 id="使用ALTER语句创建，语法如下："><a href="#使用ALTER语句创建，语法如下：" class="headerlink" title="使用ALTER语句创建，语法如下："></a>使用ALTER语句创建，语法如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName ADD INDEX indexName(columnName);</span><br></pre></td></tr></table></figure>
<p>ALTER语句创建索引前面已经有例子了。下面提供一个设置索引长度的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user_action_log ADD INDEX ip_address_idx (ip_address(16));</span><br></pre></td></tr></table></figure>

<h2 id="建表的时候创建索引："><a href="#建表的时候创建索引：" class="headerlink" title="建表的时候创建索引："></a>建表的时候创建索引：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tableName(  </span><br><span class="line">  id INT NOT NULL,   </span><br><span class="line">  columnName  columnType,</span><br><span class="line">  INDEX [indexName] (columnName(length))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><p>可以通过show语句查看索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM t_user_action_log;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Table</th>
<th>Non_unique</th>
<th>Key_name</th>
<th>Seq_in_index</th>
<th>Column_name</th>
<th>Collation</th>
<th>Cardinality</th>
<th>Sub_part</th>
<th>Packed</th>
<th>Null</th>
<th>Index_type</th>
<th>Comment</th>
<th>Index_comment</th>
</tr>
</thead>
<tbody><tr>
<td>t_user_action_log</td>
<td>0</td>
<td>PRIMARY</td>
<td>1</td>
<td>id</td>
<td>A</td>
<td>199,368</td>
<td></td>
<td></td>
<td></td>
<td>BTREE</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t_user_action_log</td>
<td>1</td>
<td>action</td>
<td>1</td>
<td>action</td>
<td>A</td>
<td>4</td>
<td></td>
<td></td>
<td>YES</td>
<td>BTREE</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t_user_action_log</td>
<td>1</td>
<td>index_ip_addr</td>
<td>1</td>
<td>ip_address</td>
<td>A</td>
<td>1</td>
<td>16</td>
<td></td>
<td>YES</td>
<td>BTREE</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>使用ALTER命令可以删除索引，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user_action_log DROP INDEX index_ip_addr;</span><br></pre></td></tr></table></figure>

<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>9 个你应该知道的支付系统开源项目</title>
    <url>/p/d6d4.html</url>
    <content><![CDATA[<blockquote>
<p>小明最近新开发项目，需求有支付功能，那如何避免从零开始，快速集成呢？现在给大家搜集了9个star数比较高的开源项目，能节省不少时间呢！</p>
</blockquote>
<h2 id="项目名称"><a href="#项目名称" class="headerlink" title="项目名称"></a>项目名称</h2><p>龙果支付系统 roncoo-pay</p>
<h3 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h3><p>龙果支付系统核心目标是汇聚所有主流支付渠道，打造一款轻量、便捷、易用，且集支付、资金对账、资金清结算于一体的支付系统，满足互联网业务系统的收款和业务资金管理需求。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li>具备支付系统通用的支付、对账、清算、资金账户管理、支付订单管理等功能;</li>
<li>目前已接通“支付宝即时到账”和“微信扫码支付”通道;</li>
<li>支持直连和间连两种支付模式，任君选择;</li>
<li>通过支付网关，业务系统可以轻松实现统一支付接入;</li>
<li>搭配运营后台，支付数据的监控和管理可以兼得;</li>
<li>配套完善的系统使用文档，可轻松嵌入任何需要支付的场景;<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3></li>
</ul>
<p><a class="link"   href="https://gitee.com/roncoocom/roncoo-pay" >https://gitee.com/roncoocom/roncoo-pay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称：聚合支付系统-XxPay"><a href="#项目名称：聚合支付系统-XxPay" class="headerlink" title="项目名称：聚合支付系统 XxPay"></a>项目名称：聚合支付系统 XxPay</h2><h3 id="项目简介-1"><a href="#项目简介-1" class="headerlink" title="项目简介"></a>项目简介</h3><p>XxPay 聚合支付使用 Java 开发，包括spring-cloud、dubbo、spring-boot三个架构版本，已接入微信、支付宝等主流支付渠道，可直接用于生产环境。目前已经接入支付渠道：微信(公众号支付、扫码支付、APP支付、H5支付)、支付宝(电脑网站支付、手机网站支付、APP支付、当面付)。</p>
<h3 id="项目地址-1"><a href="#项目地址-1" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/jmdhappy/xxpay-master" >https://gitee.com/jmdhappy/xxpay-master<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="项目名称-1"><a href="#项目名称-1" class="headerlink" title="项目名称"></a>项目名称</h3><p>常用支付接口 IJPay（目前小明使用的就是这个哦）</p>
<h3 id="项目简介-2"><a href="#项目简介-2" class="headerlink" title="项目简介"></a>项目简介</h3><p>IJPay 封装了微信支付、支付宝支付、银联支付常用的支付方式以及各种常用的接口。不依赖任何第三方 mvc 框架，仅仅作为 工具 使用简单快速完成支付模块的开发，可轻松嵌入到任何系统里。demo有springBoot版本的。</p>
<h3 id="项目地址-2"><a href="#项目地址-2" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/javen205/IJPay" >https://gitee.com/javen205/IJPay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-2"><a href="#项目名称-2" class="headerlink" title="项目名称"></a>项目名称</h2><p>基于 Java 的支付开发工具包</p>
<h3 id="项目简介-3"><a href="#项目简介-3" class="headerlink" title="项目简介"></a>项目简介</h3><p>优雅的轻量级支付模块，集成微信支付、支付宝、银联、友店、富友、跨境支付等。付与业务完全剥离，简单几行代码即可实现支付，简单快速完成支付模块的开发，可轻松嵌入到任何系统里。目前仅是一个开发工具包(即SDK)，只提供简单 Web 实现，建议使用 maven 或 gradle 引用本项目即可使用本 SDK 提供的各种支付相关的功能。</p>
<h3 id="项目地址-3"><a href="#项目地址-3" class="headerlink" title="项目地址"></a>项目地址</h3><p> <a class="link"   href="https://gitee.com/egzosn/pay-java-parent" >https://gitee.com/egzosn/pay-java-parent<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称：轻量级支付系统-Fastpay"><a href="#项目名称：轻量级支付系统-Fastpay" class="headerlink" title="项目名称：轻量级支付系统 Fastpay"></a>项目名称：轻量级支付系统 Fastpay</h2><h3 id="项目简介-4"><a href="#项目简介-4" class="headerlink" title="项目简介"></a>项目简介</h3><p>Fastpay 的目标是打造一款开源的、轻量级的、微服务化的、可共私有云部署的、可定制化的集成聚合支付和资金清结算于一体的统一支付系统，满足互联网企业业务系统的收款和资金处理等需求。在支付系统上实施微服务架构，使用最流行的Spring Cloud做服务化。</p>
<h3 id="项目特点"><a href="#项目特点" class="headerlink" title="项目特点"></a>项目特点</h3><ul>
<li><p>设计天生可伸缩的数据存储，直接使用分库分表。</p>
</li>
<li><p>使用缓存进行加速交易过程，提高用户体验。</p>
</li>
<li><p>将回调通知、入账等异步化，提高用户响应能力。</p>
</li>
<li><p>使用分布式定时任务系统将任务调度与交易隔离。</p>
</li>
<li><p>用当前最先进的单元化架构实现可水平伸缩。</p>
</li>
</ul>
<h3 id="项目地址-4"><a href="#项目地址-4" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/robertleepeak/fastpay" >https://gitee.com/robertleepeak/fastpay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-3"><a href="#项目名称-3" class="headerlink" title="项目名称"></a>项目名称</h2><p>支付 SDK 扩展包 easyPay</p>
<h3 id="项目简介-5"><a href="#项目简介-5" class="headerlink" title="项目简介"></a>项目简介</h3><p>本项目根据支付宝、微信最新 API 开发而成，高度抽象的类，免去各种拼 json 与 xml 的痛苦;符合 PSR 标准，你可以各种方便的与你的框架集成;文件结构清晰易理解，可以随心所欲添加本项目中没有的支付网关;方法使用更优雅，不必再去研究那些奇怪的的方法名或者类名是做啥用的。</p>
<h3 id="项目地址-5"><a href="#项目地址-5" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/yansongda/pay" >https://gitee.com/yansongda/pay<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="项目名称-4"><a href="#项目名称-4" class="headerlink" title="项目名称"></a>项目名称</h3><p>互联网金融支付系统 aaden-pay</p>
<h3 id="项目简介-6"><a href="#项目简介-6" class="headerlink" title="项目简介"></a>项目简介</h3><p>基于互联网金融理财环境下产生的支付系统，特点为：</p>
<ul>
<li><p>同卡进出，用户先实名绑定银行卡，后交易，不支持手机扫码交易。</p>
</li>
<li><p>提供统一的支付框架，只需少量代码就可快速接入新渠道，提供一个稳定的支付解决方法，节约 程序员 时间。</p>
</li>
</ul>
<h3 id="项目地址-6"><a href="#项目地址-6" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/aaden/aaden-pay" >https://gitee.com/aaden/aaden-pay<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-5"><a href="#项目名称-5" class="headerlink" title="项目名称"></a>项目名称</h2><p>基于 PHP 的支付 SDK</p>
<h3 id="项目简介-7"><a href="#项目简介-7" class="headerlink" title="项目简介"></a>项目简介</h3><p>Payment 是一个 PHP 版本的支付聚合第三方 SDK，集成了微信支付、支付宝支付、招商一网通支付。提供统一的调用接口，方便快速接入各种支付、查询、退款、转账能力。</p>
<h3 id="项目地址-7"><a href="#项目地址-7" class="headerlink" title="项目地址"></a>项目地址</h3><p> <a class="link"   href="https://gitee.com/helei112g/payment" >https://gitee.com/helei112g/payment<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="项目名称-6"><a href="#项目名称-6" class="headerlink" title="项目名称"></a>项目名称</h2><p>基于 .NET Core 的支付 SDK 集</p>
<h3 id="项目简介-8"><a href="#项目简介-8" class="headerlink" title="项目简介"></a>项目简介</h3><p>本项目是基于 .NET Core / ASP.NET Core 开发的跨平台支付 SDK 集，简化了 API 调用及相关通知的处理流程。</p>
<h3 id="项目特点-1"><a href="#项目特点-1" class="headerlink" title="项目特点"></a>项目特点</h3><p>目前支持：支付宝(Alipay)、微信支付(WeChatPay)、QQ钱包(QPay)、京东支付(JDPay)、连连支付(LianLianPay)、银联支付(UnionPay)。</p>
<h3 id="项目地址-8"><a href="#项目地址-8" class="headerlink" title="项目地址"></a>项目地址</h3><p><a class="link"   href="https://gitee.com/Essensoft/Payment" >https://gitee.com/Essensoft/Payment<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的几个消息组件</title>
    <url>/p/5d3b.html</url>
    <content><![CDATA[<h2 id="MQ背景-amp-选型"><a href="#MQ背景-amp-选型" class="headerlink" title="MQ背景&amp;选型"></a>MQ背景&amp;选型</h2><p>消息队列作为高并发系统的核心组件之一，能够帮助业务系统解构提升开发效率和系统稳定性。主要具有以下优势：</p>
<ul>
<li>削峰填谷（主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题）</li>
<li>系统解耦（解决不同重要程度、不同能力级别系统之间依赖导致一死全死）</li>
<li>提升性能（当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统）</li>
<li>蓄流压测（线上有些链路不好压测，可以通过堆积一定量消息再放开来压测）</li>
</ul>
<p>目前主流的MQ主要是Rocketmq、kafka、Rabbitmq，Rocketmq相比于Rabbitmq、kafka具有主要优势特性有：</p>
<ul>
<li>支持事务型消息（消息发送和DB操作保持两方的最终一致性，rabbitmq和kafka不支持）</li>
<li>支持结合rocketmq的多个系统之间数据最终一致性（多方事务，二方事务是前提）</li>
<li>支持18个级别的延迟消息（rabbitmq和kafka不支持）</li>
<li>支持指定次数和时间间隔的失败消息重发（kafka不支持，rabbitmq需要手动确认）</li>
<li>支持consumer端tag过滤，减少不必要的网络传输（rabbitmq和kafka不支持）</li>
<li>支持重复消费（rabbitmq不支持，kafka支持）<br>Rocketmq、kafka、Rabbitmq的详细对比，请参照下表格：<br><img src="https://i.ibb.co/n7mLmNY/12619159-ebd12b24d5ae33d9.png" alt="三个mq的对比"><h2 id="RocketMQ集群概述"><a href="#RocketMQ集群概述" class="headerlink" title="RocketMQ集群概述"></a>RocketMQ集群概述</h2><h3 id="RocketMQ集群部署结构"><a href="#RocketMQ集群部署结构" class="headerlink" title="RocketMQ集群部署结构"></a>RocketMQ集群部署结构</h3><img src="https://i.ibb.co/xfC6HKh/12619159-a858d38e0b38c406.png" alt="RocketMQ集群部署结构"></li>
</ul>
<h4 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h4><p>Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的Broker Name，不同的Broker Id来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。<br>每个Broker与Name Server集群中的所有节点建立长连接，定时(每隔30s)注册Topic信息到所有Name Server。Name Server定时(每隔10s)扫描所有存活broker的连接，如果Name Server超过2分钟没有收到心跳，则Name Server断开与Broker的连接。</p>
<h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>Producer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。<br>Producer每隔30s（由ClientConfig的pollNameServerInterval）从Name server获取所有topic队列的最新情况，这意味着如果Broker不可用，Producer最多30s能够感知，在此期间内发往Broker的所有消息都会失败。<br>Producer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s中扫描所有存活的连接，如果Broker在2分钟内没有收到心跳数据，则关闭与Producer的连接。</p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>Consumer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。<br>Consumer每隔30s从Name server获取topic的最新队列情况，这意味着Broker不可用时，Consumer最多最需要30s才能感知。<br>Consumer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s扫描所有存活的连接，若某个连接2分钟内没有发送心跳数据，则关闭连接；并向该Consumer Group的所有Consumer发出通知，Group内的Consumer重新分配队列，然后继续消费。<br>当Consumer得到master宕机通知后，转向slave消费，slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是一旦master恢复，未同步过去的消息会被最终消费掉。<br>消费者队列是消费者连接之后（或者之前有连接过）才创建的。我们将原生的消费者标识由 {IP}@{消费者group}扩展为 {IP}@{消费者group}{topic}{tag}，（例如xxx.xxx.xxx.xxx@mqtest_producer-group_2m2sTest_tag-zyk）。任何一个元素不同，都认为是不同的消费端，每个消费端会拥有一份自己消费队列（默认是broker队列数量*broker数量）。新挂载的消费者队列中拥有commitlog中的所有数据。<br>如果有需要，可以查看Rocketmq更多源码解析</p>
<h2 id="Rocketmq如何支持分布式事务消息"><a href="#Rocketmq如何支持分布式事务消息" class="headerlink" title="Rocketmq如何支持分布式事务消息"></a>Rocketmq如何支持分布式事务消息</h2><p><strong>场景</strong><br>A（存在DB操作）、B（存在DB操作）两方需要保证分布式事务一致性，通过引入中间层MQ，A和MQ保持事务一致性（异常情况下通过MQ反查A接口实现check），B和MQ保证事务一致（通过重试），从而达到最终事务一致性。<br>原理：大事务 = 小事务 + 异步</p>
<h3 id="MQ与DB一致性原理（两方事务）"><a href="#MQ与DB一致性原理（两方事务）" class="headerlink" title="MQ与DB一致性原理（两方事务）"></a>MQ与DB一致性原理（两方事务）</h3><p><strong>流程图</strong><br><img src="https://i.ibb.co/mHVYNLt/12619159-6f4f6754d6f02058.png" alt="流程图"><br>上图是RocketMQ提供的保证MQ消息、DB事务一致性的方案。<br>MQ消息、DB操作一致性方案：</p>
<ul>
<li>发送消息到MQ服务器，此时消息状态为SEND_OK。此消息为consumer不可见。</li>
<li>执行DB操作；DB执行成功Commit DB操作，DB执行失败Rollback DB操作。</li>
<li>如果DB执行成功，回复MQ服务器，将状态为COMMIT_MESSAGE；如果DB执行失败，回复MQ服务器，将状态改为ROLLBACK_MESSAGE。注意此过程有可能失败。</li>
<li>MQ内部提供一个名为“事务状态服务”的服务，此服务会检查事务消息的状态，如果发现消息未COMMIT，则通过Producer启动时注册的TransactionCheckListener来回调业务系统，业务系统在checkLocalTransactionState方法中检查DB事务状态，如果成功，则回复COMMIT_MESSAGE，否则回复ROLLBACK_MESSAGE。<br>说明：<br>上面以DB为例，其实此处可以是任何业务或者数据源。<br>以上SEND_OK、COMMIT_MESSAGE、ROLLBACK_MESSAGE均是client jar提供的状态，在MQ服务器内部是一个数字。</li>
</ul>
<p>TransactionCheckListener 是在消息的commit或者rollback消息丢失的情况下才会回调（上图中灰色部分）。这种消息丢失只存在于断网或者rocketmq集群挂了的情况下。当rocketmq集群挂了，如果采用异步刷盘，存在1s内数据丢失风险，异步刷盘场景下保障事务没有意义。所以如果要核心业务用Rocketmq解决分布式事务问题，建议选择同步刷盘模式。</p>
<h2 id="多系统之间数据一致性（多方事务）"><a href="#多系统之间数据一致性（多方事务）" class="headerlink" title="多系统之间数据一致性（多方事务）"></a>多系统之间数据一致性（多方事务）</h2><p><img src="https://i.ibb.co/KmFwTpZ/moreside.png" alt="多方事务"></p>
<p>当需要保证多方（超过2方）的分布式一致性，上面的两方事务一致性（通过Rocketmq的事务性消息解决）已经无法支持。这个时候需要引入TCC模式思想（Try-Confirm-Cancel，不清楚的自行百度）。<br>以上图交易系统为例：</p>
<ul>
<li>交易系统创建订单（往DB插入一条记录），同时发送订单创建消息。通过RocketMq事务性消息保证一致性</li>
<li>接着执行完成订单所需的同步核心RPC服务（非核心的系统通过监听MQ消息自行处理，处理结果不会影响交易状态）。执行成功更改订单状态，同时发送MQ消息。</li>
<li>交易系统接受自己发送的订单创建消息，通过定时调度系统创建延时回滚任务（或者使用RocketMq的重试功能，设置第二次发送时间为定时任务的延迟创建时间。在非消息堵塞的情况下，消息第一次到达延迟为1ms左右，这时可能RPC还未执行完，订单状态还未设置为完成，第二次消费时间可以指定）。延迟任务先通过查询订单状态判断订单是否完成，完成则不创建回滚任务，否则创建。 PS：多个RPC可以创建一个回滚任务，通过一个消费组接受一次消息就可以；也可以通过创建多个消费组，一个消息消费多次，每次消费创建一个RPC的回滚任务。  回滚任务失败，通过MQ的重发来重试。<br>以上是交易系统和其他系统之间保持最终一致性的解决方案。<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3></li>
</ul>
<h4 id="单机环境下的事务示意图"><a href="#单机环境下的事务示意图" class="headerlink" title="单机环境下的事务示意图"></a>单机环境下的事务示意图</h4><p>如下为A给B转账的例子。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>锁定B的账户</td>
</tr>
<tr>
<td>2</td>
<td>锁定B的账户</td>
</tr>
<tr>
<td>3</td>
<td>检查A账户是否有1元</td>
</tr>
<tr>
<td>4</td>
<td>A的账户扣减1元</td>
</tr>
<tr>
<td>5</td>
<td>给B的账户加1元</td>
</tr>
<tr>
<td>6</td>
<td>解锁B的账户</td>
</tr>
<tr>
<td>7</td>
<td>解锁A的账户</td>
</tr>
</tbody></table>
<p>以上过程在代码层面甚至可以简化到在一个事物中执行两条sql语句。</p>
<h4 id="分布式环境下事务"><a href="#分布式环境下事务" class="headerlink" title="分布式环境下事务"></a>分布式环境下事务</h4><p>和单机事务不同，A、B账户可能不在同一个DB中，此时无法像在单机情况下使用事物来实现。此时可以通过一下方式实现，将转账操作分成两个操作。</p>
<ul>
<li>A账户</li>
</ul>
<table>
<thead>
<tr>
<th>步骤</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>锁定A的账户</td>
</tr>
<tr>
<td>2</td>
<td>检查A账户是否有1元</td>
</tr>
<tr>
<td>3</td>
<td>A的账户扣减1元</td>
</tr>
<tr>
<td>4</td>
<td>解锁A的账户</td>
</tr>
</tbody></table>
<ul>
<li>MQ消息</li>
</ul>
<p>A账户数据发生变化时，发送MQ消息，MQ服务器将消息推送给转账系统，转账系统来给B账号加钱。</p>
<ul>
<li>B账户</li>
</ul>
<table>
<thead>
<tr>
<th>步骤</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>锁定B的账户</td>
</tr>
<tr>
<td>2</td>
<td>给B的账户加1元</td>
</tr>
<tr>
<td>3</td>
<td>解锁B的账户</td>
</tr>
</tbody></table>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><h3 id="顺序消息缺陷"><a href="#顺序消息缺陷" class="headerlink" title="顺序消息缺陷"></a>顺序消息缺陷</h3><p>发送顺序消息无法利用集群<code>Fail Over</code>特性消费，顺序消息的并行度依赖于队列数量，存在队列热点问题，个别队列由于哈希不均导致消息过多，消费速度跟不上，产生消息堆积问题遇到消息失败的消息，无法跳过，当前队列消费暂停。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>produce在发送消息的时候，把消息发到同一个队列（<code>queue</code>）中,消费者注册消息监听器为<code>MessageListenerOrderly</code>，这样就可以保证消费端只有一个线程去消费消息。<br>注意：把消息发到同一个队列（<code>queue</code>），不是同一个<code>topic</code>，默认情况下一个<code>topic</code>包括4个<code>queue</code></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>可以通过实现发送消息的队列选择器方法，实现部分顺序消息。<br>举例：比如一个数据库通过MQ来同步，只需要保证每个表的数据是同步的就可以。解析<code>binlog</code>，将表名作为队列选择器的参数，这样就可以保证每个表的数据到同一个队列里面，从而保证表数据的顺序消费。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="Producer-1"><a href="#Producer-1" class="headerlink" title="Producer"></a>Producer</h3><ul>
<li><p>  Topic<br>一个应用尽可能用一个<code>Topic</code>，消息子类型用tags来标识，tags可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用<code>tags</code> 在<code>broker</code>做消息过滤。</p>
</li>
<li><p>  key<br>每个消息在业务层面的唯一标识码，要设置到 <code>keys</code> 字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引(哈希索引)，应用可以通过 <code>topic</code>，key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证<code>key</code> 尽可能唯一，这样可以避免潜在的哈希冲突。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;订单Id</span><br><span class="line">String orderId&#x3D; &quot;20034568923546&quot;;</span><br><span class="line">message.setKeys(orderId);</span><br></pre></td></tr></table></figure></li>
<li><p>  日志<br>消息发送成功或者失败，要打印消息日志，务必要打印 <code>send result</code> 和<code>key</code> 字段。</p>
</li>
<li><p> <code>send</code><br><code>send</code>消息方法，只要不抛异常，就代表发送成功。但是发送成功会有多个状态，在<code>sendResult</code>里定义。<br><code>SEND_OK</code>：消息发送成功<br><code>FLUSH_DISK_TIMEOUT</code>：消息发送成功，但是服务器刷盘超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失<br><code>FLUSH_SLAVE_TIMEOUT</code>：消息发送成功，但是服务器同步到Slave时超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失<br><code>SLAVE_NOT_AVAILABLE</code>：消息发送成功，但是此时slave不可用，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</p>
<h3 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h3></li>
<li><p> 幂等<br>RocketMQ使用的消息原语是<code>At Least Once</code>，所以<code>consumer</code>可能多次收到同一个消息，此时务必做好幂等。</p>
</li>
<li><p>  日志<br>消费时记录日志，以便后续定位问题。</p>
</li>
<li><p>  批量消费<br>尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2></li>
<li><p> 博客<br>分布式开放消息系统(RocketMQ)的原理与实践<br><a class="link"   href="http://www.jianshu.com/p/453c6e7ff81c" >http://www.jianshu.com/p/453c6e7ff81c<i class="fas fa-external-link-alt"></i></a><br>RocketMQ事务消费和顺序消费详解<br><a class="link"   href="http://www.cnblogs.com/520playboy/p/6750023.html" >http://www.cnblogs.com/520playboy/p/6750023.html<i class="fas fa-external-link-alt"></i></a><br>ZeroCopy<br><a class="link"   href="http://www.linuxjournal.com/article/6345" >http://www.linuxjournal.com/article/6345<i class="fas fa-external-link-alt"></i></a><br>IO方式的性能数据<br><a class="link"   href="http://stblog.baidu-tech.com/?p=851" >http://stblog.baidu-tech.com/?p=851<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 2.x集成redis作为cache</title>
    <url>/p/3388.html</url>
    <content><![CDATA[<blockquote>
<p>参考自 <a class="link"   href="https://blog.csdn.net/sy793314598/article/details/80719224" >springbot2.x整合redis做缓存<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h1 id="redis的相关配置"><a href="#redis的相关配置" class="headerlink" title="redis的相关配置"></a>redis的相关配置</h1><h2 id="引入相关依赖"><a href="#引入相关依赖" class="headerlink" title="引入相关依赖"></a>引入相关依赖</h2><p>首先使用maven引入spring-redis相关的依赖，2.0中使用spring-boot-starter-data-redis代替了原来的spring-boot-starter-redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置redis数据库"><a href="#配置redis数据库" class="headerlink" title="配置redis数据库"></a>配置redis数据库</h2><p>在SpringBoot的application.yml配置文件中配置redis数据库的相关信息，这里改动主要有两点，其一是时间相关的属性，如spring.redis.timeout，在1.0中，时间相关的配置参数类型为int，默认单位为毫秒，配置中只需指定具体的数字即可，而在2.0中，时间相关的配置的参数类型都改为了jdk1.8的Duration，因此在配置文件中配置redis的连接超时时间timeout时，需要加入时间单位，如60s；其二是，在2.0中配置redis的连接池信息时，不再使用spring.redis.pool的属性，而是直接使用redis的lettuce或jedis客户端来配置，具体配置信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    password: gitlab</span><br><span class="line">    port: 6379</span><br><span class="line">    database: 10</span><br><span class="line">    timeout: 3s  # 数据库连接超时时间，2.0 中该参数的类型为Duration，这里在配置的时候需要指明单位</span><br><span class="line">    # 连接池配置，2.0中直接使用*jedis*或者lettuce配置连接池</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        # 最大空闲连接数</span><br><span class="line">        max-idle: 500</span><br><span class="line">        # 最小空闲连接数</span><br><span class="line">        min-idle: 50</span><br><span class="line">        # 等待可用连接的最大时间，负数为不限制</span><br><span class="line">        max-wait:  -1s</span><br><span class="line">        # 最大活跃连接数，负数为不限制</span><br><span class="line">        max-active: -1</span><br></pre></td></tr></table></figure>
<h2 id="配置CacheManager"><a href="#配置CacheManager" class="headerlink" title="配置CacheManager"></a>配置CacheManager</h2><p>通过配置Spring的CacheManager为redis，即可指定使用redis做缓存，具体的配置方式跟1.0也有所不同，在1.0中使用RedisTemplate即可实例化一个RedisCacheManager：RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);，在2.0中删除了这个构造器，同时也不可以通过之前的setDefaultExpiration方法设置默认的缓存过期时间等，在新版本中可以通过以下的两种方式构造一个RedisCacheManager：</p>
<h3 id="通过RedisCacheManager的静态方法create"><a href="#通过RedisCacheManager的静态方法create" class="headerlink" title="通过RedisCacheManager的静态方法create"></a>通过RedisCacheManager的静态方法create</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public CacheManager cacheManager(RedisConnectionFactory factory) &#123;</span><br><span class="line">    RedisCacheManager cacheManager &#x3D; RedisCacheManager.create(factory);</span><br><span class="line">    return cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样产生的cacheManager只是使用Spring提供的默认配置</p>
<h3 id="通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder-build-的方式生成cacheManager："><a href="#通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder-build-的方式生成cacheManager：" class="headerlink" title="通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder.build()的方式生成cacheManager："></a>通过Spring提供的RedisCacheConfiguration类，构造一个自己的redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder.build()的方式生成cacheManager：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @ClassName RedisConfig class</span><br><span class="line"> * @Author xin</span><br><span class="line"> * @Date 2019-03-27</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;</span><br><span class="line">        RedisCacheConfiguration config &#x3D; RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(60))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        return RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .transactionAware()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置RedisTemplate，进行简单的key、value相关操作"><a href="#配置RedisTemplate，进行简单的key、value相关操作" class="headerlink" title="配置RedisTemplate，进行简单的key、value相关操作"></a>配置RedisTemplate，进行简单的key、value相关操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public RedisTemplate redisTemplate(RedisConnectionFactory factory) &#123;</span><br><span class="line">        StringRedisTemplate template &#x3D; new StringRedisTemplate(factory);</span><br><span class="line"></span><br><span class="line">        RedisSerializer keySerializer &#x3D; new StringRedisSerializer(); &#x2F;&#x2F; 设置key序列化类，否则key前面会多了一些乱码</span><br><span class="line">        template.setKeySerializer(keySerializer);</span><br><span class="line">        setValueSerializer(template);&#x2F;&#x2F;设置value序列化</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        template.setEnableTransactionSupport(true);</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setValueSerializer(StringRedisTemplate template) &#123;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om &#x3D; new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/p/29d7.html</url>
    <content><![CDATA[<blockquote>
<p>摘自 <a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483678&idx=1&sn=461d8e3453031337c7599758dceaf675&chksm=ebf6d961dc81507743a0c0b4a830457156536da61508b56d6689ed75ff8242422df3ce4b36e2&scene=21#wechat_redirect"  title="点击查看!">纯洁的微笑<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。</p>
<hr>
<h1 id="使用spring-boot有什么好处"><a href="#使用spring-boot有什么好处" class="headerlink" title="使用spring boot有什么好处"></a>使用spring boot有什么好处</h1><p>其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？</p>
<ul>
<li>配置web.xml，加载spring和spring mvc</li>
<li>配置数据库连接、配置spring事务</li>
<li>配置加载配置文件的读取，开启注解</li>
<li>配置日志文件</li>
<li>…</li>
<li>配置完成之后部署tomcat调试</li>
<li>…</li>
</ul>
<p>现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍!<br>但是如果使用spring boot呢？<br>很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！</p>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="maven搭建项目"><a href="#maven搭建项目" class="headerlink" title="maven搭建项目"></a>maven搭建项目</h2><ul>
<li>访问 <a class="link"   href="http://start.spring.io/" >http://start.spring.io/<i class="fas fa-external-link-alt"></i></a></li>
<li>选择构建工具Maven Project、Spring Boot版本1.3.6以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.7</li>
<li>点击Generate Project下载项目压缩包</li>
<li>解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done!<h2 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h2></li>
</ul>
<p>&lt;Spring Boot的基础结构共三个文件:</p>
<ul>
<li>src/main/java  程序开发以及主程序入口</li>
<li>src/main/resources 配置文件</li>
<li>src/test/java  测试程序<br>另外，spingboot建议的目录结果如下：<br>root package结构：<code>com.example.myproject</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- domain</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- controller</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure></li>
<li>Application.java 建议放到跟目录下面,主要用于做一些框架配置</li>
<li>domain目录主要用于实体（Entity）与数据访问层（Repository）</li>
<li>service 层主要是业务类代码</li>
<li>controller 负责页面访问控制<br>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改<br>最后，启动Application main方法，至此一个java项目搭建好了！</li>
</ul>
<h2 id="引入web模块"><a href="#引入web模块" class="headerlink" title="引入web模块"></a>引入web模块</h2><h3 id="pom-xml中添加支持web的模块"><a href="#pom-xml中添加支持web的模块" class="headerlink" title="pom.xml中添加支持web的模块"></a>pom.xml中添加支持web的模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>pom.xml文件中默认有两个模块<br><code>spring-boot-starter</code> ：核心模块，包括自动配置支持、日志和YAML；<br><code>spring-boot-starter-test</code> ：测试模块，包括JUnit、Hamcrest、Mockito。</p>
<h3 id="编写controller内容"><a href="#编写controller内容" class="headerlink" title="编写controller内容"></a>编写controller内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloWorldController &#123;   </span><br><span class="line"> </span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)    </span><br><span class="line">    public String index() &#123; </span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@RestController</code> 的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！<br>启动主程序，打开浏览器访问<a class="link"   href="http://localhost:8080/hello%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%E4%BA%86%EF%BC%8C%E6%9C%89%E6%9C%A8%E6%9C%89%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%81" >http://localhost:8080/hello，就可以看到效果了，有木有很简单！<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h2><p>打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(classes &#x3D; MockServletContext.class)</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">public class HelloWorldControlerTests &#123;</span><br><span class="line">    private MockMvc mvc;</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        mvc &#x3D; MockMvcBuilders.standaloneSetup(new HelloWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception &#123;</span><br><span class="line">    mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;hello&quot;).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发环境的调试"><a href="#开发环境的调试" class="headerlink" title="开发环境的调试"></a>开发环境的调试</h2><p>热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目启重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>
<p>该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。</p>
<h1 id="springboot实战"><a href="#springboot实战" class="headerlink" title="springboot实战"></a>springboot实战</h1><h2 id="SpringBoot中获取spring-profiles-active的值（代码级别）"><a href="#SpringBoot中获取spring-profiles-active的值（代码级别）" class="headerlink" title="SpringBoot中获取spring.profiles.active的值（代码级别）"></a>SpringBoot中获取spring.profiles.active的值（代码级别）</h2><blockquote>
<p>源码分析参考链接<a class="link"   href="https://www.cnblogs.com/linzhanfly/p/9056722.html" >月下小魔王<i class="fas fa-external-link-alt"></i></a><br>应用场景：根据环境编写业务代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringContextUtil implements ApplicationContextAware &#123;</span><br><span class="line">    private static ApplicationContext context &#x3D; null;</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line">        this.context &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取当前环境</span><br><span class="line">    public static String getActiveProfile() &#123;</span><br><span class="line">        return context.getEnvironment().getActiveProfiles()[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于ApplicationContextAware接口的说明"><a href="#关于ApplicationContextAware接口的说明" class="headerlink" title="关于ApplicationContextAware接口的说明"></a>关于ApplicationContextAware接口的说明</h3><p>Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<p>使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。</p>
<p>文中所有的代码 <a class="link"   href="https://github.com/ityouknow/spring-boot-starter" >https://github.com/ityouknow/spring-boot-starter<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot发送邮件</title>
    <url>/p/3735.html</url>
    <content><![CDATA[<blockquote>
<p>在小明经历的多个项目开发中，总会遇到<strong>消息通知</strong>的场景，比如某个广告主提交一个表单，我们要通知提醒运营人员及时查看。</p>
</blockquote>
<p>消息通知的形式也有很多，比如：短信、邮件、app推送等，本文主要给大家描述一下<strong>邮件</strong>通知的形式，因为邮件相比较其他通知渠道更方便实用（免费），除了简单文本邮件（已经满足大多数情形），本文还会重点说一下集成<strong>Thymeleaf</strong>模版引擎，使用<strong>HTML</strong>的形式发送邮件，尽管<strong>HTML</strong>内容不是标准化的消息格式，但是许多邮件客户端至少支持标记语言的子集，这种方式相比较纯文本展现形式更加友好。 </p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>一个普通再也普通不了的SpringBoot项目</p>
<h2 id="简单文本发送"><a href="#简单文本发送" class="headerlink" title="简单文本发送"></a>简单文本发送</h2><p>还是那句老话，在SpringBoot看来一切都是这么便捷。它已经集成邮件发送所必需的库模块，我们只需将以下依赖添加到<code>pom.xml</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-mail --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="邮箱服务结构"><a href="#邮箱服务结构" class="headerlink" title="邮箱服务结构"></a><strong>邮箱服务结构</strong></h3><p>Spring框架中用于Java邮件支持的接口和类组织如下：</p>
<ol>
<li><p><strong>MailSender interface</strong>：发送简单基础电子邮件的顶级接口；</p>
</li>
<li><p><strong>JavaMailSender interface</strong>：是<code>MailSender</code>的子接口。它支持MIME消息，并且主要与<code>MimeMessageHelper</code>类一起用于创建<code>MimeMessage</code>。建议在此接口实现类<code>JavaMailSenderImpl</code>中使用<code>MimeMessagePreparator</code>机制；</p>
</li>
<li><p><strong>JavaMailSenderImpl class</strong>：实现了<code>JavaMailSender</code> 的接口，它支持<code>MimeMessage</code>和<code>SimpleMailMessage</code>；</p>
</li>
<li><p> <strong>SimpleMailMessage class</strong>：用于创建简单的邮件消息，包括from，to，cc，subject和text字段；</p>
</li>
<li><p><strong>MimeMessagePreparator interface</strong>：提供一个回调接口，用于编写MIME消息；</p>
</li>
<li><p><strong>MimeMessageHelper class</strong>：用于创建MIME消息的帮助类。它为HTML布局中的图像，典型邮件附件和文本内容提供支持。</p>
</li>
</ol>
<p>在以下部分中，我将向大家展示如何使用这些接口和类：</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>下面举例163邮箱（最常用的）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    host: smtp.163.com # 发件服务器</span><br><span class="line">    username: coderxm@163.com # 账号</span><br><span class="line">    password: xxxx # 密码（163需要授权第三方登录密码，请查看设置-客户端授权码密码开通）</span><br><span class="line">    port: 465</span><br><span class="line">    protocol: smtp</span><br><span class="line">    default-encoding: utf-8</span><br><span class="line">    # 下面这些配置大家不用深究，主要用于配置ssl</span><br><span class="line">    properties:</span><br><span class="line">      mail:</span><br><span class="line">        imap:</span><br><span class="line">          ssl:</span><br><span class="line">            socketFactory:</span><br><span class="line">              fallback: false</span><br><span class="line">        smtp:</span><br><span class="line">          auth: true</span><br><span class="line">          ssl:</span><br><span class="line">            enable: true</span><br><span class="line">            socketFactory:</span><br><span class="line">              class: com.fintech.modules.base.util.mail.MailSSLSocketFactory</span><br><span class="line">          starttls:</span><br><span class="line">            enable: true</span><br><span class="line">            required: true</span><br><span class="line">      test-connection: false</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h4><p>按照常见的代码结构，我们先定义一个发送邮件的<strong>接口</strong>，负责创建和发送新的邮件消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface EmailService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送简单文本内容</span><br><span class="line">     * @param to 发件人</span><br><span class="line">     * @param subject 主题</span><br><span class="line">     * @param text 内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void sendSimpleMessage(String to,</span><br><span class="line">                           String subject,</span><br><span class="line">                           String text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将一些常用的配置添加到yml配置文件当中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 邮件配置</span><br><span class="line">xiaoming:</span><br><span class="line">  email:</span><br><span class="line">    subject: &quot;程序员小明&quot;</span><br><span class="line">    from: &quot;coderxm@163.com&quot;</span><br><span class="line">    to: &quot;xiaohong@163.com&quot;</span><br><span class="line">    # 抄送人：类型定义为数组，可以配置多个</span><br><span class="line">    cc:</span><br><span class="line">      - &quot;xiaogang@163.com&quot;</span><br></pre></td></tr></table></figure>
<p>然后再通过注解注入到一个实体类中，这样很优雅，随用随取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;xiaoming.email&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="keyword">private</span> String[] cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再定义一个类去实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailServiceImpl</span> <span class="keyword">implements</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> JavaMailSender emailSender;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmailConfig emailConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleMessage</span><span class="params">(String to, String subject, String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">            message.setTo(to);</span><br><span class="line">            message.setFrom(<span class="string">&quot;coderxm@163.com&quot;</span>);</span><br><span class="line">            message.setSubject(subject);</span><br><span class="line">            message.setText(text);</span><br><span class="line">            emailSender.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MailException exception) &#123;</span><br><span class="line">            log.error(ExceptionUtil.stacktraceToString(exception));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们做一个简单的测试：简单的邮件是否能够发送成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        emailService.sendSimpleMessage(<span class="string">&quot;ligang@163.com&quot;</span>,<span class="string">&quot;XX篮球&quot;</span>,<span class="string">&quot;你好，我想让周琦代言！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用html作为模版发送邮件"><a href="#使用html作为模版发送邮件" class="headerlink" title="使用html作为模版发送邮件"></a>使用html作为模版发送邮件</h3><p>正在洋洋得意（准备划水）的时候，我们的产品突然对我说，“用简单的文本发送邮件也太简陋了吧，显示不出来我们的产品档次”，然后给我了一个样式，让我以这种形式发送，好啊，什么都难不倒小明。我连忙找到我们的前端，（假装低三下四地）让她帮忙排一个页面给我（这个工作我实在不想做，一是懒，二是人家前端肯定比我专业啊），为了保密，我简化一下，大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    姓 名：&lt;span th:text&#x3D;&quot;$&#123;userName&#125;&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    性 别：&lt;span th:text&#x3D;&quot;$&#123;gender&#125;&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>其实样式很好看的，但是这都不是重点，我们就以此作为模版举个例子，语法使用的都是thymeleaf，在此处就不再赘述，如果有想了解的可以去官网找。</p>
<h4 id="增加Thymeleaf-dependency"><a href="#增加Thymeleaf-dependency" class="headerlink" title="增加Thymeleaf dependency"></a>增加Thymeleaf dependency</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="service层-1"><a href="#service层-1" class="headerlink" title="service层"></a>service层</h4><p>创建另一个服务类，它主要通过读取html模版封装数据准备邮件内容，在我们之前的示例中，这是一个简单的文本消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MailContentBuilder &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MailContentBuilder(TemplateEngine templateEngine) &#123;</span><br><span class="line">        this.templateEngine &#x3D; templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String build(Map&lt;String, Object&gt; message) &#123;</span><br><span class="line">        Context context &#x3D; new Context();</span><br><span class="line">        context.setVariables(message);</span><br><span class="line">        return templateEngine.process(&quot;email&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>EmailService</code>增加接口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface EmailService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送简单文本内容</span><br><span class="line">     * @param to 发件人</span><br><span class="line">     * @param subject 主题</span><br><span class="line">     * @param text 内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void sendSimpleMessage(String to,</span><br><span class="line">                           String subject,</span><br><span class="line">                           String text);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 传递多个变量，用于动态更换页面模版内容</span><br><span class="line">     * @param emailInfoMap</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void prepareAndSend(Map&lt;String,Object&gt; emailInfoMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>EmailServiceImpl</code>增加发送html形式邮件的实现方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void prepareAndSend(Map&lt;String,Object&gt; emailInfoMap) &#123;</span><br><span class="line">    MimeMessagePreparator messagePreparator &#x3D; mimeMessage -&gt; &#123;</span><br><span class="line">        MimeMessageHelper messageHelper &#x3D; new MimeMessageHelper(mimeMessage);</span><br><span class="line">        messageHelper.setFrom(emailConfig.getFrom());</span><br><span class="line">        messageHelper.setTo(emailConfig.getTo());</span><br><span class="line">        messageHelper.setCc(emailConfig.getCc());</span><br><span class="line">        messageHelper.setSubject(emailConfig.getSubject());</span><br><span class="line">&#x2F;&#x2F;            messageHelper.setText(message);</span><br><span class="line">        String content &#x3D; mailContentBuilder.build(info);</span><br><span class="line">        messageHelper.setText(content,true);</span><br><span class="line">    &#125;;</span><br><span class="line">    try &#123;</span><br><span class="line">        emailSender.send(messagePreparator);</span><br><span class="line">    &#125; catch (MailException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; runtime exception; compiler will not force you to handle it</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EmailTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EmailService emailService;</span><br><span class="line">  </span><br><span class="line">    @Test</span><br><span class="line">    public void testHtml()&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;userName&quot;,&quot;程序员小明&quot;);</span><br><span class="line">        map.put(&quot;gender&quot;,&quot;男&quot;);</span><br><span class="line">        emailService.prepareAndSend(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个Springboot发送邮件的场景已经复盘结束，大家如果有用到的速速体验吧！</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title>vue cli + axios + springboot 实现文件下载</title>
    <url>/p/2366.html</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="install-axios"><a href="#install-axios" class="headerlink" title="install axios"></a>install axios</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install axios --save</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#39;axios&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><p>执行的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">downLoadMix() &#123;  </span><br><span class="line">  let params &#x3D; &#123;&#125;;</span><br><span class="line">  let url &#x3D; this.$store.state.urlPrefix+&quot;&#x2F;company&#x2F;download&quot;;</span><br><span class="line">  let title &#x3D; null;</span><br><span class="line">    axios(&#123;  </span><br><span class="line">    method: &#39;post&#39;, </span><br><span class="line">    url,  </span><br><span class="line">    headers: &#123;  </span><br><span class="line">    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    data: params,  </span><br><span class="line">    responseType: &#39;arraybuffer&#39;  </span><br><span class="line">    &#125;).then(res &#x3D;&gt; &#123;  </span><br><span class="line">        let headers &#x3D; res.headers;  &#x2F;&#x2F;后端需要配置Access-Control-Expose-Headers,否则浏览器只能访问到默认的响应头,具体如下</span><br><span class="line">        let blob &#x3D; new Blob([res.data], &#123;  </span><br><span class="line">          type: headers[&#39;content-type&#39;]  </span><br><span class="line">        &#125;);  </span><br><span class="line">        let link &#x3D; document.createElement(&#39;a&#39;);  </span><br><span class="line">        link.href &#x3D; window.URL.createObjectURL(blob);  </span><br><span class="line">        if (!title) &#123;  </span><br><span class="line">          const fileName &#x3D; headers[&#39;content-disposition&#39;];  </span><br><span class="line">          title &#x3D; fileName.includes(&#39;filename&#x3D;&#39;) ? fileName.split(&#39;&#x3D;&#39;)[1] : &#39;下载的表单文件&#39;;  </span><br><span class="line">        &#125;  </span><br><span class="line">        link.download &#x3D; title;  </span><br><span class="line">        link.click();  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="后端代码-解决axios获取Http响应头"><a href="#后端代码-解决axios获取Http响应头" class="headerlink" title="后端代码(解决axios获取Http响应头)"></a>后端代码(解决axios获取Http响应头)</h2><p>浏览器默认只能访问以下响应头</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>
<p>因此如果想让浏览器能访问到其他响应头内容的话，比如<code>Content-disposition</code>,需要在服务器上设置 <code>Access-Control-Expose-Headers</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Content-disposition&quot;);</span><br></pre></td></tr></table></figure>
<p>或者完全放开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;*&quot;);</span><br></pre></td></tr></table></figure>
<p>即可允许浏览器访问任意一个响应头，当然除次之外还要设置下载文件相关的响应头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setContentType(&quot;application&#x2F;octet-stream&quot;);</span><br><span class="line">response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename&#x3D;createList.xls&quot;);&#x2F;&#x2F;默认Excel名称</span><br></pre></td></tr></table></figure>
<p>后端i/o流照常处理，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;download&quot;, method &#x3D; &#123;RequestMethod.POST&#125;, produces &#x3D; &#123;&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;&#125;)</span><br><span class="line">public void download(@RequestBody RequestFacade request, HttpServletResponse response) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        &#x2F;&#x2F;创建工作簿</span><br><span class="line">        XSSFWorkbook wb &#x3D; new XSSFWorkbook();</span><br><span class="line">        &#x2F;&#x2F;创建一个sheet</span><br><span class="line">        XSSFSheet sheet &#x3D; wb.createSheet();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建单元格样式</span><br><span class="line">        XSSFCellStyle style &#x3D; wb.createCellStyle();</span><br><span class="line">        style.setFillForegroundColor(HSSFColor.WHITE.index);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        response.setContentType(&quot;application&#x2F;octet-stream&quot;);</span><br><span class="line">        response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename&#x3D;createList.xls&quot;);&#x2F;&#x2F;默认Excel名称</span><br><span class="line">        response.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;*&quot;);</span><br><span class="line">        response.flushBuffer();</span><br><span class="line">        wb.write(response.getOutputStream());</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>「Elasticsearch」SpringBoot快速集成ES</title>
    <url>/p/21452.html</url>
    <content><![CDATA[<blockquote>
<p>Elastic Search 的底层是开源库 Lucene。但是Lucene的使用门槛比较高，必须自己写代码去调用它的接口。而Elastic Search的出现正是为了解决了这个问题，它是 Lucene 的封装，提供了 REST API 的操作接口，我们可以开箱即用。</p>
</blockquote>
<a id="more"></a>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>JDK版本：8</li>
<li>SpringBoot:2.x</li>
<li>ES版本：7.1.1<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   集成es client，并排除低版本依赖(5.6)     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2>使用配置类配置，可以参考如下所示：<br>先创建一个builder，用于初始化ES client<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsClientBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectTimeoutMillis = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> socketTimeoutMillis = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectionRequestTimeoutMillis = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxConnectPerRoute = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxConnectTotal = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HttpHost&gt; httpHosts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EsClientBuilder</span><span class="params">(List&lt;HttpHost&gt; httpHosts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpHosts = httpHosts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EsClientBuilder <span class="title">setConnectTimeoutMillis</span><span class="params">(<span class="keyword">int</span> connectTimeoutMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectTimeoutMillis = connectTimeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EsClientBuilder <span class="title">setSocketTimeoutMillis</span><span class="params">(<span class="keyword">int</span> socketTimeoutMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socketTimeoutMillis = socketTimeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EsClientBuilder <span class="title">setConnectionRequestTimeoutMillis</span><span class="params">(<span class="keyword">int</span> connectionRequestTimeoutMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionRequestTimeoutMillis = connectionRequestTimeoutMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EsClientBuilder <span class="title">setMaxConnectPerRoute</span><span class="params">(<span class="keyword">int</span> maxConnectPerRoute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxConnectPerRoute = maxConnectPerRoute;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EsClientBuilder <span class="title">setMaxConnectTotal</span><span class="params">(<span class="keyword">int</span> maxConnectTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxConnectTotal = maxConnectTotal;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EsClientBuilder <span class="title">build</span><span class="params">(List&lt;HttpHost&gt; httpHosts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EsClientBuilder(httpHosts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpHost[] httpHostArr = httpHosts.toArray(<span class="keyword">new</span> HttpHost[<span class="number">0</span>]);</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(httpHostArr);</span><br><span class="line"></span><br><span class="line">        builder.setRequestConfigCallback(requestConfigBuilder -&gt; &#123;</span><br><span class="line">            requestConfigBuilder.setConnectTimeout(connectTimeoutMillis);</span><br><span class="line">            requestConfigBuilder.setSocketTimeout(socketTimeoutMillis);</span><br><span class="line">            requestConfigBuilder.setConnectionRequestTimeout(connectionRequestTimeoutMillis);</span><br><span class="line">            <span class="keyword">return</span> requestConfigBuilder;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        builder.setHttpClientConfigCallback(httpClientBuilder -&gt; &#123;</span><br><span class="line">            httpClientBuilder.setMaxConnTotal(maxConnectTotal);</span><br><span class="line">            httpClientBuilder.setMaxConnPerRoute(maxConnectPerRoute);</span><br><span class="line">            <span class="keyword">return</span> httpClientBuilder;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再交给spring容器管理：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.nodes&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.schema&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String schema;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.max-connect-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxConnectTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.max-connect-per-route&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxConnectPerRoute;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.connection-request-timeout-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer connectionRequestTimeoutMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.socket-timeout-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer socketTimeoutMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.connect-timeout-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer connectTimeoutMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">getRestHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;HttpHost&gt; httpHosts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String[] parts = StringUtils.split(node, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">                Assert.notNull(parts,<span class="string">&quot;Must defined&quot;</span>);</span><br><span class="line">                Assert.state(parts.length == <span class="number">2</span>, <span class="string">&quot;Must be defined as &#x27;host:port&#x27;&quot;</span>);</span><br><span class="line">                httpHosts.add(<span class="keyword">new</span> HttpHost(parts[<span class="number">0</span>], Integer.parseInt(parts[<span class="number">1</span>]), schema));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Invalid ES nodes &quot;</span> + <span class="string">&quot;property &#x27;&quot;</span> + node + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EsClientBuilder.build(httpHosts)</span><br><span class="line">                .setConnectionRequestTimeoutMillis(connectionRequestTimeoutMillis)</span><br><span class="line">                .setConnectTimeoutMillis(connectTimeoutMillis)</span><br><span class="line">                .setSocketTimeoutMillis(socketTimeoutMillis)</span><br><span class="line">                .setMaxConnectTotal(maxConnectTotal)</span><br><span class="line">                .setMaxConnectPerRoute(maxConnectPerRoute)</span><br><span class="line">                .create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
再配置一下常用的配置：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置es</span></span><br><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="comment">#  如果是cluster，application.yml的nodes设置多个ip:host逗号隔开即可。</span></span><br><span class="line">  <span class="attr">nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9200</span></span><br><span class="line">  <span class="attr">schema:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">max-connect-total:</span> <span class="number">50</span></span><br><span class="line">  <span class="attr">max-connect-per-route:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">connection-request-timeout-millis:</span> <span class="number">500</span></span><br><span class="line">  <span class="attr">socket-timeout-millis:</span> <span class="number">30000</span></span><br><span class="line">  <span class="attr">connect-timeout-millis:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>接下来我们测试一下配置是否生效，一个简单的验证送给大家，如下所示：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        MainResponse info = client.info(RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(info.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
配置生效的话，就会返回Elastic Search的配置信息：包含当前节点、集群、版本等信息。<br>SpringBoot集成ES至此结束。</li>
</ul>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>「SpringBoot」如何优雅地管理SpringBoot项目</title>
    <url>/p/63677.html</url>
    <content><![CDATA[<p>本文主要讲述一下如何优雅地管理SpringBoot项目。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>课堂上，当小明形如流水地回答完沐芳老师提出来的问题时，却被至今没有对象的胖虎无情嘲讽了？</p>
<blockquote>
<p>沐芳老师：小明，你平时是如何启动、停止你的SpringBoot项目的？</p>
<p>小明（自信满满）：启动时使用<code>java -jar xxxx.jar</code>命令启动，停止服务时，使用<code>ps -ef</code>找到服务的<code>pid</code>，然后再<code>kill</code>掉停止。</p>
<p>胖虎：就这？</p>
</blockquote>
<a id="more"></a>
<p>这让小明很有挫败感，原计划按时放学回去陪隔壁小花打王者荣耀的小明，毅然决然留在教室潜心研究一番到底什么是SpringBoot优雅启动的正确姿势？经过几番挫折，小明终于搜集整理出两种优雅启动SpringBoot项目的方式分享给小明的小伙伴们。</p>
<h3 id="第一种方式：使用SHELL脚本"><a href="#第一种方式：使用SHELL脚本" class="headerlink" title="第一种方式：使用SHELL脚本"></a>第一种方式：使用SHELL脚本</h3><p>As we known 作为一个后端程序猿，每天的工作除了与前端妹子一块连调接口（拌几嘴）以外，就是终日沉浸在黑压压的Linux服务器之中，部署服务、监控服务器状态、分析日志（找bug）……因此，掌握一些常用的SHEEL脚本命令是自然而然地（迫不得已）。</p>
<blockquote>
<p>大胆胡说：什么是SHELL脚本？故名思议，她乐了（她乐你也乐）。</p>
</blockquote>
<p>因此，小明站在巨人的肩膀上，参考了一些圈内资深高级JAVA开发工程师的经验，整理了一份防嘲讽必备的SHELL脚本（Github地址见文末），只是为了自己的SpringBoot服务，只是为了不被单身的胖虎嘲讽。</p>
<p>这一份SHELL脚本很神奇，有多神奇呢？</p>
<p>你只要把这个脚本放到你的SpringBoot项目打好的jar包<strong>同级目录</strong>下：</p>
<p><img src="https://img.mynamecoder.com/20200405175500.png"></p>
<p>在该目录下，简单粗暴地执行下面这个命令，赋予该脚本相应执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 app.sh</span><br></pre></td></tr></table></figure>
<p>就能完成如下功能：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">./app.sh start</td>
<td align="center">启动应用</td>
</tr>
<tr>
<td align="center">./app.sh stop</td>
<td align="center">停止应用</td>
</tr>
<tr>
<td align="center">./app.sh restart</td>
<td align="center">重启应用</td>
</tr>
<tr>
<td align="center">./app.sh status</td>
<td align="center">查看应用状态</td>
</tr>
<tr>
<td align="center">./app.sh stop -f</td>
<td align="center">强制kill应用进程</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：如果一个目录下有多个jar包我们执行一个文件，那就需要指定jar包，比如<code>./app.sh start coder-xiaoming-0.0.1-SNAPSHOT.jar</code></p>
</blockquote>
<p>惊不惊喜？让大家看一下小明实操预览图，过过眼瘾先。</p>
<p><img src="https://img.mynamecoder.com/20200405180902.png"></p>
<p>我们可以看到，通过运行启动命令，控制台输出提示：正在启动……并且该目录下会根据jar包名称和日期输出一个日志文件（调试bug使用）。</p>
<p>为了走一个流程，我们再查看一下应用状态，并停止应用</p>
<p><img src="https://img.mynamecoder.com/20200405183250.png"></p>
<p>篇幅有限，其他几个命令大家可以自己尝试一下。</p>
<p>当然，我们还可以尝试自定义脚本中的内容：</p>
<p>比如，<strong>gc</strong>、<strong>Xms</strong>、<strong>Xmx</strong>等针对当前服务器的实际配置进行修改；</p>
<p><img src="https://img.mynamecoder.com/20200405191825.png"></p>
<p>不同大小的项目，正常停止项目的时间也不同，因此我们还可以设置<code>restart</code>应用时的等待时间，确保应用正常停止后再启动，如下所示将等待时间设为5s。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in &#123;5..1&#125;</span><br><span class="line">do</span><br><span class="line">	echo -n &quot;$i &quot;</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>是不是感觉已经很规范很优雅了？但，故事还要继续，远没有完，小明又继续探索下去，发现如果你使用的是<strong>SpringBoot 2.0</strong>及以上的版本，那小明的小伙伴们便有福了，不需要以上的脚本就可以很优雅。接下来，看一下第二种方式。</p>
<h3 id="第二种方式：把SpringBoot以服务形式启动"><a href="#第二种方式：把SpringBoot以服务形式启动" class="headerlink" title="第二种方式：把SpringBoot以服务形式启动"></a>第二种方式：把SpringBoot以服务形式启动</h3><blockquote>
<p>英文名字：Spring Boot Application as a Service Deploying .</p>
</blockquote>
<p>搁在平时，小明在Linux服务器上启动Springboot项目，都是通过<strong>nohup</strong>命令让程序作为后台进程执行的，但是这样，程序并不好管理维护，反而显得小明和小明的伙伴们都很不专业，更好的方法是将<em>SpringBoot</em>作为<em>Service</em>启动。</p>
<p>首先需要更改打包方式，如果你使用的是maven构建的SpringBoot项目，首先将SpringBoot项目中的<strong>pom.xml</strong>中增加一个<strong>plugin</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;executable&gt;true&lt;&#x2F;executable&gt;</span><br><span class="line">				&lt;&#x2F;configuration&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>
<p>其中“<executable>true</executable>”一定要加，标示该jar为可执行，否则机器启动SpringBoot服务会报错。</p>
<p>如果你使用的是<strong>gradle</strong>构建的<strong>SpringBoot</strong>项目，则相应地需要增加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootJar &#123;</span><br><span class="line">     launchScript()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来拿主要拿maven打包举例：</p>
<p>首先通过package命令打jar包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>接着，我们需要在Linux服务器上，如下所示，增加一个软连接，就可以将应用注册到Service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;opt&#x2F;coder-xiaoming.jar &#x2F;etc&#x2F;init.d&#x2F;coder-xiaoming</span><br></pre></td></tr></table></figure>
<p>其中<code>/opt/coder-xiaoming.jar</code>为你上传至服务器jar的绝对路径，一定要写全哦。<br><code>/etc/init.d/coder-xiaoming</code>里面的<code>coder-xiaoming</code>可以修改为你自己中意的名字，执行相关命令时会用到。</p>
<p>接下来，就是见证奇迹的时刻，我们通过如下命令来操作应用（和操作汤姆猫一样）：</p>
<p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service coder-xiaoming start</span><br></pre></td></tr></table></figure>
<p>停止服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service coder-xiaoming stop</span><br></pre></td></tr></table></figure>
<p>查看服务状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service coder-xiaoming status</span><br></pre></td></tr></table></figure>
<p>有些小伙伴可能注意到了，这样快捷操作省去很多配置，固然很方便，那启动服务时如何自定义参数呢？接着往下看。</p>
<h4 id="自定义JVM参数"><a href="#自定义JVM参数" class="headerlink" title="自定义JVM参数"></a>自定义JVM参数</h4><p>我们只需在jar包所在的同级目录下添加与jar包同名的配置文件，比如添加一个叫coder-xiaoming.conf的配置文件(名字要和jar的名字相同哦)，然后在文件里面自定义JVM参数<strong>JAVA_OPTS</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_OPTS&#x3D;&quot;-Xmx4096m -Xms4096m&quot;</span><br></pre></td></tr></table></figure>
<p>这样启动时，就会读取该文件中的配置，我们查看一下进程状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure>
<p>你一定可以看到，对应的Java进程启动参数上会多了“-Xmx4096m -Xms4096m”，如果要增加其他启动参数配置同理哈。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自从小明掌握以上两个骚操作之后，在日常开发中也可以目中无人地<strong>启动/停止</strong>SpringBoot应用，极大地提高了日常工作效率，这让身旁的胖虎也呆若木鸡。这样操作的意义很大，以当前眼光来看，小明可以多陪小花打几把王者荣耀；以长远来看，这对于之后的CICD或者Docker化应用都有很大的帮助。小明的小伙伴们，你们还不赶紧应用起来？保证今晚不加班～</p>
<blockquote>
<p>附</p>
<p>sheel脚本Github地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming/blob/master/deploy/app.sh" >https://github.com/WhenCoding/coder-xiaoming/blob/master/deploy/app.sh<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>「规范」如何优雅地代码分层？</title>
    <url>/p/46081.html</url>
    <content><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a><strong>1、背景</strong></h2><p>说起应用分层，大部分人都会认为这个不是很简单嘛 就controller，service, mapper三层。看起来简单，很多人其实并没有把他们职责划分开，在很多代码中，controller做的逻辑比service还多,service往往当成透传了，这其实是很多人开发代码都没有注意到的地方，反正功能也能用，至于放哪无所谓呗。这样往往造成后面代码无法复用，层级关系混乱，对后续代码的维护非常麻烦。</p>
<a id="more"></a>
<p>的确在这些人眼中分层只是一个形式，前辈们的代码这么写的，其他项目代码这么写的，那么我也这么跟着写。</p>
<p>但是在真正的团队开发中每个人的习惯都不同，写出来的代码必然带着自己的标签，有的人习惯controller写大量的业务逻辑，有的人习惯在service中之间调用远程服务，这样就导致了每个人的开发代码风格完全不同，后续其他人修改的时候，一看，我靠这个人写的代码和我平常的习惯完全不同，修改的时候到底是按着自己以前的习惯改，还是跟着前辈们走，这又是个艰难的选择，选择一旦有偏差，你的后辈又维护你的代码的时候，恐怕就要骂人了。</p>
<p>所以一个好的应用分层需要具备以下几点:</p>
<ul>
<li>方便后续代码进行维护扩展；</li>
<li>分层的效果需要让整个团队都接受；</li>
<li>各个层职责边界清晰。</li>
</ul>
<h2 id="2、应用分层模型"><a href="#2、应用分层模型" class="headerlink" title="2、应用分层模型"></a>2、应用分层模型</h2><p>在项目开发中，一个良好的工程架构是必须的。工程架构就像一个骨架，写代码就是在这个骨架上增添血肉，这个骨架会影响到整体的模块划分，功能划分，即会影响到代码的解耦和聚合，将会很大程度上决定一个项目写得好不好。</p>
<p>这里要分享的是我个人在开发时所采取的工程架构，以及相关的思想。不同的人对于工程架构的理解会不同，实际上也很难分出哪种好，哪种坏，只要符合自己的设计思想，并且能够有效的进行开发，那就是好的一种架构方式。</p>
<h3 id="2-1、分层"><a href="#2-1、分层" class="headerlink" title="2.1、分层"></a>2.1、分层</h3><p>我整体上的思想为《阿里巴巴 Java 开发手册》中所描述的分层模型。如下：</p>
<p><img src="https://img.mynamecoder.com/20200411234541.png">应用分层图</p>
<blockquote>
<p>在这里插一嘴哈，在这里我使用的流程图工具是<strong>ProcessOn</strong>，是一款在线画图工具，非常适合画各种示意图，体验极佳，如果大家想尝试一下，可以使用我的<a class="link"   href="https://www.processon.com/i/5a967fdce4b01965e7301910" >邀请链接<i class="fas fa-external-link-alt"></i></a>注册使用～</p>
</blockquote>
<p>接下来将自底向上的讲解我对各层的理解和设计，还有我自己所增加的层。</p>
<h3 id="2-2、通用工具层"><a href="#2-2、通用工具层" class="headerlink" title="2.2、通用工具层"></a>2.2、通用工具层</h3><p>通用工具层其实为对业务无关的，通用的工具类，例如日期处理的工作累，一些数据格式的序列化与反序列化工具。类似于 apache commons 包和 guava 包。</p>
<h3 id="2-3、分层领域模型"><a href="#2-3、分层领域模型" class="headerlink" title="2.3、分层领域模型"></a>2.3、分层领域模型</h3><p>领域模型，也就是我们之前常见的各种数据实体，用 DDD 的术语来说，这种在分层模型中的领域模型称为贫血领域模型。<br>贫血领域模型只作为数据载体，只有 getter/setter 方法，而不包含业务方法。</p>
<p>对于分层领域模型，会进一步进行划分规约，主要也是参考自《阿里巴巴 Java 开发手册》具体如下：</p>
<ul>
<li><strong>DO(Data Object)</strong> : 数据对象，对数据源数据的映射，如数据库表，ElasticSearch 索引的数据结构。所在包一般命名为 data 。</li>
<li><strong>DTO(Data Transfer Object)</strong> : 数据传输对象，业务层向外传输的对象。如果在某个业务中需要多次查询获取不同的数据对象，最后将会把这多个数据对象组合成一个 DTO 并对外传输。所在包命名为 dto 。</li>
<li><strong>BO(Business Object)</strong> : 业务对象，由 Service 层输出的封装业务逻辑的对象。即对象除了数据外，还会包含一定的业务逻辑，也可以说是充血领域模型。但是我一般不会使用。</li>
<li><strong>AO(Application Object)</strong> : 应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。比较少用。</li>
<li><strong>VO(View Object)</strong> : 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。现在的项目多数为前后端分离，后端只需要返回 JSON ，那么可以理解为 JSON 即是需要渲染成的“模板”。我一般会将这类对象命名为 xxxResponse ，所在包命名为 response 。</li>
<li><strong>Query</strong> : 数据查询对象，数据查询对象，各层接收上层的查询请求。其实一般用于 Controller 接受传过来的参数，可以将其都命名为 xxxQuery ，而我个人习惯将放在 request body 的参数（即 @RequestBody）包装为 xxxRequest ，而如果使用表单传输过来的参数（即 @RequestParam）包装为 xxxForm ，并分别放在包 request 和包 form 下。</li>
</ul>
<p>其实贫血领域模型只是作为数据的载体，在一开始我觉得没必要进行具体的分类，基本上都是往一个包内丢，但是当项目规模上来后，各种各样的数据实体开始增加，慢慢的变得混乱。对数据对象的分类是为了更好的定义每个数据的作用以及在后续能够快速的定位到对应的数据对象。</p>
<h3 id="2-4、Helper"><a href="#2-4、Helper" class="headerlink" title="2.4、Helper"></a>2.4、Helper</h3><p>开发中会遇到一些很基础的，通用的业务逻辑，例如我们可能会根据每个用户的信息生成一个唯一的 account id 。又或者说有一个用户排名的需求，我们将从用户的相关信息中计算出一个分数，从而根据这个分数进行排名。那么这时候我们可能会将这些逻辑写在 User 数据对象或是其他相应对应的数据对象下。<br>而我个人来说，不希望数据对象包含业务逻辑，所以我会将这些通用的业务逻辑都抽出来，放到 Manager 中进行统一管理。如会将生成 account id 的逻辑放在 AccountIdGenerator 中，将计算排名分数的逻辑放在 RankCalculator 中。<br>我将这些类都归为 Helper ，用于提供底层的业务计算逻辑。而为什么不放在通用工具层中呢？因为这些 Helper 其实都是依赖于特定的领域，即特定的业务。而通用工具类则是业务无关的，任何系统，只要有需要都可以引用。</p>
<h3 id="2-5、DAO"><a href="#2-5、DAO" class="headerlink" title="2.5、DAO"></a>2.5、DAO</h3><p>DAO 就不用过多解释了，数据访问对象，用于对数据库的访问。但是我个人不会将 DAO 只局限于数据库，对于不同的数据源的交互，如 HBase ，ElasticSearch ，本地缓存甚至 Redis 我都会定义相对应的 DAO 进行访问。<br>这样的定义，其实是想将数据 CURD 的逻辑和业务逻辑进行分离，将获 CRUD 封装在 DAO 中，业务逻辑即放在业务层中。</p>
<p>之前接手了一个项目，项目将 Redis 视为中间件，将相关的逻辑都封装在 xxxRedisService 中，包括 CRUD 和一些业务逻辑。随着项目的发展，一些其实可以归类到一起的业务，变得有些放在了 RedisService 中，一些放在了业务层的 Service 中，可想而知十分混乱，还导致了一些 BUG 的出现。</p>
<h3 id="2-6、Service-和-Manager"><a href="#2-6、Service-和-Manager" class="headerlink" title="2.6、Service 和 Manager"></a>2.6、Service 和 Manager</h3><p>Service 的作用不用多说明，为具体业务逻辑的封装层。</p>
<p>具体要说明的是 Manager ，《阿里巴巴 Java 开发手册》中定义如下:</p>
<ol>
<li>对第三方平台封装的层，预处理返回结果及转化异常信息</li>
<li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理</li>
<li>与 DAO 层交互，对多个 DAO 的组合复用</li>
</ol>
<p>可以将 Manager 理解为对通用逻辑的封装，避免 Service 与 Service 进行相互调用，以及对通用逻辑的管理。</p>
<p>在开发中，我们经常会遇到 AService 中的某个业务可以提供给 BService 调用，从而让 BService 调用 AService 的方法，认为是 Service 之间具有共同的业务。其实 Service 之间没有共同的业务，而是<strong>具备通用的逻辑</strong>，这时应该将其抽离出来放在 Manager 中。无论何种工程架构都好，我都不赞同 Service 与 Service 之间的相互调用。</p>
<p>在实际开发中，我会对 Manager 进行更细一点的划分。大致将其分为用于项务类，所封装的是由 Service 下沉的通用业务。<br>而另一种则是一些偏向于工具、计算的类，例如某个业务使用了策略模式，所编写的策略类则属于这一类。<br>我会将业务类的用 @Service 注释，而偏工具类的则用 @Component 注释。这样做的原因还是避免业务之间的相互调用，相互耦合。</p>
<p>这里可能会想，为什么不将 Helper 的逻辑也放在 Manager 层中？原因在于 Helper 的逻辑比 Manager 更加基础，有可能在 DAO 中都会调用 Helper 的相关逻辑，如果放在 Manager 中，就会出现底层依赖上层的问题。</p>
<h3 id="2-7、接口层"><a href="#2-7、接口层" class="headerlink" title="2.7、接口层"></a>2.7、接口层</h3><p>最后的一层，则是暴露给外部调用的层。可以是 Spring 体系中的 Controller ，也可以是 gRPC 。<br>这一层将组织、调用我们所定义的 Service ，进行业务处理。</p>
<h2 id="3、分层模型的优点以及缺点"><a href="#3、分层模型的优点以及缺点" class="headerlink" title="3、分层模型的优点以及缺点"></a>3、分层模型的优点以及缺点</h2><p>无论什么工程架构，都会有其优点以及缺点，在选择工程架构时，其实就是对优点缺点的衡量。</p>
<h3 id="3-1、优点"><a href="#3-1、优点" class="headerlink" title="3.1、优点"></a>3.1、优点</h3><p>其实无论什么架构，特别是对业务工程来说，最希望架构带来的是解耦以及内聚。<br>通过分层，在一定程度上对项目内的各个模块进行了解耦内聚，依赖关系十分明确，再怎么写，只要符合规约，总是上层依赖于下层。而且分层的规约十分简单，在多人协作的情况下大部分情况都可以很好的遵守规约。</p>
<h3 id="3-2、缺点"><a href="#3-2、缺点" class="headerlink" title="3.2、缺点"></a>3.2、缺点</h3><p>简单是一个优点，也是一个缺点。分层虽然在一定程度上进行了解耦，但是粒度十分粗，只要不出现下层依赖上层的情况，都可以认为是符合规约的，在这种情况下，很容易导致代码的分散、功能的碎片化，明明是同一类业务功能的代码，却分散在多个类，多个层次之间。在项目不断迭代时变得巨大时，慢慢就会变得混乱，然后就是一轮重构。<br>归根到底就是太松懈了，导致开发人员很容易就是在项目中随便找个地方写，还很容易导致由大量的复制粘贴所产生重复代码。</p>
<p>在学校开设的软件工程课中，设计一个系统，首先是组织架构的了解，然后从中抽出数据流，然后再在数据流中抽出业务流，进行根据业务流进行开发。而采用分层模型的化，往往在数据流中就可以开始开发，采用分层模型的话，每个业务其实可以简单的抽象成数据在各层之间的流动。<br>这可以说是一个优点，简化了业务的理解，实现快速的开发，我在比较紧的排期下也由这么做过，扫一眼业务，构思好数据流的流动后就动手了。但这也是一个很严重的缺点，我见过不少功能性 BUG ，就是由于对业务的不充分理解所导致的，而且由于没有对业务流程充分理解后就开发，后续的扩展和修复，看起来就是不断的修修补补。</p>
<p>上面，我除了《阿里巴巴 Java 开发手册》所写的内容外，还添加了不少细节，其实所想要做的就是尽量减少这种功能碎片化的问题。</p>
<h2 id="4、与充血领域模型的对比"><a href="#4、与充血领域模型的对比" class="headerlink" title="4、与充血领域模型的对比"></a>4、与充血领域模型的对比</h2><p>既然是说工程架构，就不得不提 DDD 这一个概念。</p>
<p>为什么我说的是“与充血领域模型的对比”而不是“与 DDD 的对比”呢？是因为 DDD 是比分层模型更加高层的一种概念，它是一个产品服务，整个团队开发的一种指导思想，而不是一种工程代码上的规约。</p>
<p>DDD 可以分为两大方向，一个是战略层面上的，即之前提到的是一种开发的指导思想，定义、划分服务的领域，规定统一语言提高沟通效率等，这也是可以用于使用分层领域模型的项目开发中的。如果要与分层模型对比的话，其实是 DDD 的战术层面，即充血领域模型。</p>
<p>充血领域模型其实是回归于面向对象的思想。在目前的分层模型中，哪怕是用 Java 这种面向对象的语言去写，其实总体上还是一种过程式的编程，在 DDD 中称为事务脚本。</p>
<p>充血领域模型是重领域，轻 Service 的。以之前生成 account id 以及排名的例子，在充血领域模型中，User 类将会有 generateAccountId 方法和 ranking 方法来完成这一逻辑。<br>完全的面向对象，就可以充分的发挥面向对象的特性。面向对象的特性在书上为：<em>继承、多态，封装</em>。前两者能够实现归一化，使模块泛化通用，封装即会使模块划分明确，能够很好的实现解耦和内聚。比起分层模型，使用充血领域模型可以很好的解决上面提到的代码分散，碎片化的问题。</p>
<p>充血领域模型的优点是面向对象的优点，但是面向对象的缺点也成为这种模型的缺点。首先，万物皆可抽象在我看来就是伪命题，因为现实世界中总有事务是难以进行抽象的，或者抽象起来不优雅，总是有一种硬是抽象的感觉。<br>在知乎中有一个很好的回答，描述了面向对象的弊端</p>
<p>相信很多人在初接触 DDD 时，都会去搜索充血领域模型实践的例子。其实在学校学习 Java Web 开发时，书本中写道的 MVC 结构其实在一定程度上也是充血领域模型，Model 除了是数据的载体外，还包含业务逻辑，通过 Controller 对 Model 的选择以及调用完成业务。假如用这种结构开发，当项目庞大后，我觉得首先遇到的问题应该就是依赖问题，复杂的业务必然牵扯到各方各面，自然也就有复杂的依赖关系产生，甚至会有为了完成业务而产生很“脏”的实现，这是难以避免的。</p>
<p>我个人觉得充血领域模型目前还是只适合于个人，很小的团队中使用，例如 2 到 3 个人的团队，因为抽象本身就是一个非常复杂的过程，随着需求迭代，之前的抽象还不一定正确，如果在较为多人的多人协作中，各种奇奇怪怪的写法都会出现，必然也会有随便找个“地”写的情况出现，这种情况比在分层模型中更为致命。</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>还是那句话，工程架构无分好坏，只有适合与不适合，问题的来与在于业务的复杂，计算机始终在某些方面难以映射到现实世界。所以我个人建议好好的理解好自己目前所用到的工程架构，尽量做到扬长避短。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>「Elasticsearch」查询并删除匹配文档之_delete_by_query</title>
    <url>/p/6cce.html</url>
    <content><![CDATA[<blockquote>
<p>思路：先查询确认，后精准删除</p>
</blockquote>
<p>假设我想删除title是”小明今晚真的不加班“这条记录，先查看一下现有的记录：</p>
<p>(不加班不好吗？为什么要删除呢？)</p>
<a id="more"></a>
<blockquote>
<p>tips:可以使用<code>match_phrase</code>精准查询，查询命令可以通过curl查询，也可以通过其他工具请求（其实道理都一样）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http:&#x2F;&#x2F;192.168.16.65:9211&#x2F;blog&#x2F;_search&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;小明今晚真的不加班&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<p><code>blog</code>为索引，<code>_search</code>为es的查询指令，查询结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;took&quot;: 13,</span><br><span class="line">	&quot;timed_out&quot;: false,</span><br><span class="line">	&quot;_shards&quot;: &#123;</span><br><span class="line">		&quot;total&quot;: 3,</span><br><span class="line">		&quot;successful&quot;: 3,</span><br><span class="line">		&quot;skipped&quot;: 0,</span><br><span class="line">		&quot;failed&quot;: 0</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;hits&quot;: &#123;</span><br><span class="line">		&quot;total&quot;: &#123;</span><br><span class="line">			&quot;value&quot;: 1,</span><br><span class="line">			&quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;max_score&quot;: 110.28655,</span><br><span class="line">		&quot;hits&quot;: [&#123;</span><br><span class="line">			&quot;_index&quot;: &quot;blog&quot;,</span><br><span class="line">			&quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">			&quot;_id&quot;: &quot;6a0d343fb629da2e2cdf6f4bf250af04&quot;,</span><br><span class="line">			&quot;_score&quot;: 110.28655,</span><br><span class="line">			&quot;_source&quot;: &#123;</span><br><span class="line">				&quot;author&quot;: &quot;程序员小明&quot;,</span><br><span class="line">				&quot;capture_time&quot;: 1583820020000,</span><br><span class="line">				&quot;content&quot;: &quot;今晚终于可以王者荣耀带妹了&quot;,</span><br><span class="line">				&quot;title&quot;: &quot;小明今晚真的不加班&quot;,</span><br><span class="line">				&quot;top_domain&quot;: &quot;mynamecoder.com&quot;,</span><br><span class="line">				&quot;url&quot;: &quot;http:&#x2F;&#x2F;blog.mynamecoder.com&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到数据中有一条符合条件的文档，我们现在就要删除该文档。</p>
<p>删除<code>title</code>为”小明今晚真的不加班”的文档（忍痛）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST &quot;http:&#x2F;&#x2F;127.0.0.1:9211&#x2F;blog&#x2F;_delete_by_query&quot; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match&quot;:&#123;</span><br><span class="line">      &quot;title&quot;:&quot;小明今晚真的不加班&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 使用<code>_delete_by_query</code>时，必须指定索引，此处<code>blog</code>就是索引，<code>_delete_by_query</code>是elasticsearch的删除指令</p>
</blockquote>
<p>删除结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 147,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;deleted&quot;: 1,</span><br><span class="line">  &quot;batches&quot;: 1,</span><br><span class="line">  &quot;version_conflicts&quot;: 0,</span><br><span class="line">  &quot;noops&quot;: 0,</span><br><span class="line">  &quot;retries&quot;: &#123;</span><br><span class="line">    &quot;bulk&quot;: 0,</span><br><span class="line">    &quot;search&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;throttled_millis&quot;: 0,</span><br><span class="line">  &quot;requests_per_second&quot;: -1.0,</span><br><span class="line">  &quot;throttled_until_millis&quot;: 0,</span><br><span class="line">  &quot;total&quot;: 119,</span><br><span class="line">  &quot;failures&quot; : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注<code>total</code>（查询到的条数）和<code>deleted</code>（删除的总数）两个字段，最后不放心的话，可以再查询一下刚才那个文档是否还存在。</p>
<blockquote>
<p>tips:es执行删除的时候es并不是立即删除，虽然我们再次查询已经找不到了，但es自身是将该文档先标记准备删除状态，一段时间后，异步删除。</p>
</blockquote>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】使用Selenium实现淘宝抢单</title>
    <url>/p/44847.html</url>
    <content><![CDATA[<blockquote>
<p>最近，小明为了达成小姐姐的愿望，在某宝买到心仪的宝贝，再加上又迷上了python，就通过python轻而易举地实现了（个人声明：对Java来说，这并不是背叛）。</p>
</blockquote>
<h2 id="需求分析-amp-前期准备"><a href="#需求分析-amp-前期准备" class="headerlink" title="需求分析&amp;前期准备"></a>需求分析&amp;前期准备</h2><p>需求其实很简单，正常购物。那我们平常的购物流程如下所示：<br><img src="https://img.mynamecoder.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png"></p>
<a id="more"></a>
<p>开始之前，我们需要准备一下程序运行环境。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>系统：Windows/Mac OS</li>
<li>Python版本：3.7.2<br>为了让程序模拟我们每一步操作，给大家介绍一个利器：<strong>Selenium</strong><blockquote>
<p>Selenium测试同学应该会感觉特别亲切。它是一个自动化测试工具，通过它我们可以驱动浏览器执行特定的动作，如点击、下拉等等操作，所见即所得。</p>
</blockquote>
<h3 id="Selenium的安装"><a href="#Selenium的安装" class="headerlink" title="Selenium的安装"></a>Selenium的安装</h3>运行如下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
但若想使用Selenium成功调用Chrome浏览器完成相应的操作，我们还需要一个媒介与浏览器对接。小明本次使用的是Chrome浏览器，因此就需要通过ChromeDriver来驱动。<h3 id="ChromeDriver的安装"><a href="#ChromeDriver的安装" class="headerlink" title="ChromeDriver的安装"></a>ChromeDriver的安装</h3>这里是谷歌浏览器<strong>ChromeDriver</strong>的官方下载地址：<br><a class="link"   href="https://chromedriver.storage.googleapis.com/index.html" >https://chromedriver.storage.googleapis.com/index.html<i class="fas fa-external-link-alt"></i></a><br>我们需要根据自己的Chrome浏览器版本，找到相应版本的ChromeDriver，再根据你电脑系统的平台类型进行下载、解压。</li>
<li>windows:将其放置在Python安装路径下<code>Scripts</code>文件夹下</li>
<li>Mac OS:将其放置在<code>/usr/local/bin</code>下<br>环境配置到此结束，小明编写了一个python脚本，用来验证环境搭建是否成功：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">　　# 打开Chrome浏览器</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">　　browser &#x3D; webdriver.Chrome()</span><br></pre></td></tr></table></figure>
运行代码后，如果成功打开了一个新的浏览器，就证明我们的环境安装的没问题，接下来就可以愉快的购物了。<h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2>对比上面淘宝购物流程图，对应代码如下：</li>
<li>打开淘宝网站<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.get(&quot;https:&#x2F;&#x2F;www.taobao.com&quot;)</span><br></pre></td></tr></table></figure></li>
<li>登录<br>首先是跳转到登陆页<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_link_text(&quot;亲，请登录&quot;).click()</span><br></pre></td></tr></table></figure>
登录方式选择二维码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_class_name(&quot;icon-qrcode&quot;).click()</span><br></pre></td></tr></table></figure>
用手机进行扫码成功之后进行下一步。</li>
<li>登录成功后，打开购物车<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.get(&quot;https:&#x2F;&#x2F;cart.taobao.com&#x2F;cart.htm&quot;)</span><br></pre></td></tr></table></figure></li>
<li>勾选商品<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_id(&quot;J_SelectAll1&quot;).click()</span><br></pre></td></tr></table></figure>
推荐选择全选，但如果你的购物车商品比较多，又不想全选购买，那就暂先手动勾选想要下单的商品😅。</li>
<li>结算<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_link_text(&quot;结 算&quot;).click()</span><br></pre></td></tr></table></figure></li>
<li>提交订单<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_link_text(&#39;提交订单&#39;).click()</span><br></pre></td></tr></table></figure>
只要下单成功，接下来的付款，不用着急，只要在规定的时间内支付就好。<br>以上就是完整购物的流程。那秒杀是如何实现呢？<h2 id="秒杀的实现"><a href="#秒杀的实现" class="headerlink" title="秒杀的实现"></a>秒杀的实现</h2>　　思路其实很简单，就是在正常购物的基础上增加一个时间的判断：如果当前时间到了指定的时间点，就触发下单。<br>　　获取当前时间，需要使用到datetime这个内置模块，代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line">　　now &#x3D; datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S.%f&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="代码梳理"><a href="#代码梳理" class="headerlink" title="代码梳理"></a>代码梳理</h3></li>
<li>定义一个login函数，用来登录</li>
<li>定义一个picking函数勾选购物车中的商品</li>
<li>定义一个buy函数等待抢购时间，定时秒杀<br>完整代码请<a class="link"   href="https://github.com/WhenCoding/python-demo/tree/master/buy_quickly" >点击<i class="fas fa-external-link-alt"></i></a>访问我的github<h2 id="推荐文档"><a href="#推荐文档" class="headerlink" title="推荐文档"></a>推荐文档</h2></li>
<li><a class="link"   href="https://selenium-python-zh.readthedocs.io/en/latest/index.html" >Selenium-Python中文文档<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>动态控制多层for循环嵌套</title>
    <url>/p/5bd3.html</url>
    <content><![CDATA[<blockquote>
<p><a class="link"   href="https://blog.csdn.net/fukaiit/article/details/82730537" >参考链接<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>有些场景我们解多元一次方程时，如果方程组不够，就需要通过枚举求解，比如<code>2x+3y+4z=10</code>,需要3层for循环求解，但如果元数未知，枚举时则需要动态控制for循环的深度，我们可以通过递归解决这个问题，大概思路如下</p>
<ul>
<li>首先通过二维数组枚举所有可能的值</li>
<li>递归遍历二维数组控制for循环的层数</li>
<li>递归到最后一层时判断控制是否满足方程的条件，打印输出<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1>根据红包的总额，红包的总份数及每个红包的金额种类，得到每个红包金额对应的份数<h1 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h1>github: <a class="link"   href="https://github.com/WhenCoding/calcRedPackage" >https://github.com/WhenCoding/calcRedPackage<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Freemarker生成Word文件</title>
    <url>/p/8425.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一天，产品经理递给我了一份word报告，我定睛一看</p>
<p>这个文档有大大小小的标题层级，还有排版好的段落、各种一目了然的饼图、走势图，当然还少不了颜色循环交替的报表。精致程度不亚于小明同学的学习报告。</p>
<a id="more"></a>

<p><img src="https://img.mynamecoder.com/webp.png"></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>鲁迅：身为一名Java程序员，任何时候都不要忘记站在巨人的肩膀上。</p>
</blockquote>
<p><img src="https://img.mynamecoder.com/20200907151347.png"><br>通过某歌搜索关键词：<strong>java+word+导出</strong>，我立马得出了很多成熟的方案，通过横向、纵向比较，再结合本次报告样式比较多、用户可灵活选择不同模块导出的特点，最终，我决定使用<strong>Freemarker</strong> 动态替换模版数据来导出word文档。至于导出文档的最终格式，有两种选择：<br><img src="https://img.mynamecoder.com/20200903160210.png"></p>
<p>那到底使用<strong>doc</strong>还是<strong>docx</strong>格式的文档？<br>每当人生当中每次面临选择我都很慎重。最终我选择使用<strong>docx</strong>格式（原因文末会讲），但是为了让大家有更多的选择，满足更多的业务场景，借此机会，小明会给大家分别介绍使用<strong>freemarker</strong>导出两种格式的word文档方式。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p> FreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构生成动态网页。但是，它是一个通用的模板引擎，不依赖于servlets或HTTP或HTML，因此它通常还用于生成源代码，配置文件或电子邮件。</p>
</blockquote>
<p>此时，我们用它动态生成xml文件，进而导出word文档。<br><img src="https://img.mynamecoder.com/20200903154144.png"><br>整体流程如下：<br><img src="https://img.mynamecoder.com/20200903152139.png"></p>
<h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><ul>
<li>WPS<blockquote>
<p> 由金山软件股份有限公司发布，用于办公软件最常用的文字编辑、表格、演示稿等功能。</p>
</blockquote>
</li>
</ul>
<p>对，就是这个国产的办公软件。我也是第一次发现在导出文档这件事上，它如多年好友般友好。（word解析后的xml文件阅读性很强，一般人我不告诉他）</p>
<ul>
<li>开发工具（IDEA、Visual Studio Code等）<br>你喜欢的，顺手的，就是最好的。<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="集成Freemarker模版引擎"><a href="#集成Freemarker模版引擎" class="headerlink" title="集成Freemarker模版引擎"></a>集成Freemarker模版引擎</h3>本次项目使用的框架依旧是Springboot，这个框架在集成各个组件表现都很便捷，不再赘述，这次集成Freemarker也不例外。</li>
<li>首先我们在项目中增添依赖<code>spring-boot-starter-freemarker</code><br>pom.xml文件如下所示：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>按照默认约定，我们可以在resources下创建一个templates文件夹（查看FreeMarkerProperties源码可以发现默认目录就是这个），用于存放模版文档。<br><img src="https://img.mynamecoder.com/20200903164916.png"></li>
<li>application.yml增加配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">template-loader-path:</span> <span class="string">classpath:/templates</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment"># 开发环境缓存关闭</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">xml</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>
<h3 id="生成doc格式的文档"><a href="#生成doc格式的文档" class="headerlink" title="生成doc格式的文档"></a>生成doc格式的文档</h3>这里先拿使用freemarker导出doc格式的word文档举例。</li>
<li>首先将docxTemplate.docx（调整好样式的模版文档）另存为WORD 2003 XML文档(*.xml)<br><img src="https://img.mynamecoder.com/20200903162724.png"><br>此处命名为docTemplete.xml，使用编辑工具首次打开时，会发现这个文档里面是压缩的xml，因此我们首先需要格式化一下。<blockquote>
<p> 注意：如果你使用的是<strong>Visual Studio Code</strong>开发工具，一定要检查你所使用的xml格式化插件，是否会优化你的xml标签 。比如：<code>&lt;w:rPr&gt;</code>会变成<code>&lt;rPr&gt;</code>。使用<strong>Visual Studio Code</strong>的同学，oh my god ! 小明在这里推荐大家使用这个插件：XML Language Support by Red Hat</p>
</blockquote>
</li>
<li>现在，我们就使用freemarker语法编辑docTemplete.xml，比如使用占位符<code>$&#123;&#125;</code>替换当前文档中的文本，以达到动态生成文本的目的，直接上代码。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Configuration getConfiguration()&#123;</span><br><span class="line">        &#x2F;&#x2F;创建配置实例</span><br><span class="line">        Configuration configuration &#x3D; new Configuration(Configuration.VERSION_2_3_28);</span><br><span class="line">        &#x2F;&#x2F;设置编码</span><br><span class="line">        configuration.setDefaultEncoding(&quot;utf-8&quot;);</span><br><span class="line">        configuration.setClassForTemplateLoading(WordUtil.class, &quot;&#x2F;templates&quot;);</span><br><span class="line">        return configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成doc文件</span><br><span class="line">     *</span><br><span class="line">     * @param ftlFileName 模板ftl文件的名称</span><br><span class="line">     * @param params      动态传入的数据参数</span><br><span class="line">     * @param outFilePath 生成的最终doc文件的保存完整路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void ftlToDoc(String ftlFileName, Map params, String outFilePath) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;** 加载模板文件 **&#x2F;</span><br><span class="line">            Template template &#x3D; configuration.getTemplate(ftlFileName);</span><br><span class="line">            &#x2F;** 指定输出word文件的路径 **&#x2F;</span><br><span class="line">            File docFile &#x3D; new File(outFilePath);</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(docFile);</span><br><span class="line">            Writer bufferedWriter &#x3D; new BufferedWriter(new OutputStreamWriter(fos, &quot;utf-8&quot;), 10240);</span><br><span class="line">            template.process(params, bufferedWriter);</span><br><span class="line">            if (bufferedWriter !&#x3D; null) &#123;</span><br><span class="line">                bufferedWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (TemplateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成docx格式的文档"><a href="#生成docx格式的文档" class="headerlink" title="生成docx格式的文档"></a>生成docx格式的文档</h3></li>
<li>*高能预警！** 在成功使用Freemarker动态导出doc格式的文档之后，相信大家和我的心情一样非常激动。但以上操作只是一个小铺垫，接下来我们来看看如何实现docx格式的文档导出，小明相信一定会让各位看官大跌眼镜！不，大开眼界！<br>首先，告诉大家一个秘密：<strong>docx格式的文档其实是一个ZIP格式的压缩文件哦！</strong> 什么？你不信？验证如下：</li>
<li>windows的小伙伴<br>将docx文档修改为ZIP格式（修改.docx后缀名为.zip），然后通过解压工具解压。</li>
<li>MacOS的小伙伴<br>直接使用<code>unzip</code>命令解压word文档，解压过后我们会发现该文档其实还有自己的<strong>目录结构</strong>！<br><img src="https://img.mynamecoder.com/20200907100322.png" alt="震惊！"><br><img src="https://img.mynamecoder.com/20200907101744.png"><br>当然，这么多文件我们不必一一知悉，只需关注小明红线标注的文件和目录即可：</li>
<li>document.xml文件用于存放核心数据，文字，表格，图片引用等</li>
<li>media目录用于存放所有文档的图片</li>
<li>_rels目录下的document.xml.rels里存放的是配置信息，比如图片引用关系，即在document.xml中引用id对应media中的哪个图片。</li>
<li>获取zip里的document.xml文档以及_rels文件夹下的document.xml.rels文档</li>
<li>显而易见，如果我们要想根据数据动态导出不同的word文档，只需要：通过freemarker将本次数据填充到document.xml中，并将图片配置信息填充至document.xml.rels文档里，再用文件流把本次图片写入到media目录下替换已经存在的图片，最后把填充过内容的document.xml、document.xml.rels以及media用流的方式写入zip即可输出docx文档！上代码。<blockquote>
<p> 好吧，限于篇幅，代码见文末 Github地址</p>
</blockquote>
<h2 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h2>当然，大家在第一次尝试去干某一件事时，都不一定是一蹴而就的。就比如在导出word时，就可能会遇到以下问题。​</li>
</ul>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><strong>问题</strong>：有些文本数据中难免含有特殊字符，如：<code>&lt; &gt; @ ! $ &amp;</code> 等等。</p>
<p><strong>解决方案</strong>：这些特殊字符如果不进行转义，就会引起word打不开的现象，比如表格中的超链接的<code>&amp;</code>符号，就需要替换为<code>&amp;amp;</code>，如果你的文档用office打开时提示文件损坏，九成是因为特殊符号引起的，我们可以打开documet.xml定位报错位置；当然还有终极方案，我们可以利用Freemarker的语法直接在模板中使用<code>&lt;![CDATA[  ]]&gt; </code> 处理。比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;w:t&gt;&lt;![CDATA[ $&#123;article.title&#125; ]]&gt;&lt;&#x2F;w:t&gt;</span><br></pre></td></tr></table></figure>
<h3 id="图片变形"><a href="#图片变形" class="headerlink" title="图片变形"></a>图片变形</h3><p><strong>问题</strong>：因为echarts生成的图表是响应式的，不同的屏幕大小、分辨率，会造成每次前端传过来的图片宽高比例不一致，如果还直接将图片按照之前的比例放进文档，会造成生成后文档中的图片变形。</p>
<p><strong>思路</strong>：首先将文档中的图片设置为原图，然后锁定宽高比，将图片调整到合适大小，解压文档从<code>document.xml</code>，得到此时word中该图片宽高对应的值，如下所示：<br><img src="https://img.mynamecoder.com/20200913163808.png"></p>
<p>要想保证不同像素比例的宽高在文档中不变形，我们需要固定<code>cy</code>的值，然后根据固定比例动态求得当前像素比例图片在word中代表的宽<code>cx</code>的值。计算方法如下所示：<br>公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x2F;b &#x3D; x&#x2F;y</span><br></pre></td></tr></table></figure>
<p>其中，a表示图片在word中宽的数值，b代表图片在word中高的数值，x表示前端传过来图片的宽（单位：像素），y表示前端传过来图片的高（单位：像素）。因此，已知b、x、y,根据公式，我们即可求出a；</p>
<h2 id="我就是文末"><a href="#我就是文末" class="headerlink" title="我就是文末"></a>我就是文末</h2><p>当然，还有用一些其他注意事项：</p>
<ul>
<li>如果word中的模块比较多的话，使用Freemarker语法要仔细一点；</li>
<li>为什么小明最终选择导出docx格式的文档呢？（还不是因为产品经理的需求嘛）因为doc格式的文档，小明尝试导出后，发现该文档并不是一个合法的doc文档，体现在：不能在手机上（微信、钉钉）正常预览，office提示以xml形式打开等。因此在导出doc文档时，通过Freemaker填充document.xml后得到的并不是一个合法的word文档，查了相关资料，还需要借助第三方工具进行签名，而签名还需要在windows系统下才能完成，但是我们平时用的生产环境都是Linux……因此，考虑再三，再三权衡，最终选择导出docx格式的文档。这种方式再适合不过，而且还能保证在当前主流APP上都能正常预览。</li>
<li>敲黑板！导出docx文档最重要的一个思想是将本次数据写入覆盖模版文件（在商业中，相当于借壳上市），重新输出一个zip格式压缩的文件，这个文件就是我们最终想要的文档。</li>
</ul>
<p>以上，就是小明word导出的前前后后，如果你也曾经遇到过或者现在正好遇到word文档导出开发的问题，欢迎一起讨论交流。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>我上传了工具类，包含doc、docx 的导出，以及导出word文档时特殊符号转义，还有图片Base64转换成文件输出的方法。<br>GitHub地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming/blob/master/src/main/java/com/xm/coder/util/WordUtil.java" >https://github.com/WhenCoding/coder-xiaoming/blob/master/src/main/java/com/xm/coder/util/WordUtil.java<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title>开发日常分享</title>
    <url>/p/7e8c.html</url>
    <content><![CDATA[<h2 id="数据库连接工具"><a href="#数据库连接工具" class="headerlink" title="数据库连接工具"></a>数据库连接工具</h2><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a><strong>Mac</strong></h4><p>Sequel Pro/Navicat</p>
<h4 id="win"><a href="#win" class="headerlink" title="win"></a><strong>win</strong></h4><p> HeidiSQL</p>
<h2 id="hosts文件所在目录"><a href="#hosts文件所在目录" class="headerlink" title="hosts文件所在目录"></a>hosts文件所在目录</h2><h4 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a><strong>Mac</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure>


<h4 id="win-1"><a href="#win-1" class="headerlink" title="win"></a>win</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c:\Windows\System32\divers\etc\hosts</span><br></pre></td></tr></table></figure>


<h2 id="Tomcat存放目录"><a href="#Tomcat存放目录" class="headerlink" title="Tomcat存放目录"></a>Tomcat存放目录</h2><h4 id="Mac-2"><a href="#Mac-2" class="headerlink" title="Mac"></a>Mac</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Library</span><br></pre></td></tr></table></figure>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>自定义</p>
<h2 id="redis查看工具Redis-client"><a href="#redis查看工具Redis-client" class="headerlink" title="redis查看工具Redis client"></a>redis查看工具Redis client</h2><h4 id="Mac-3"><a href="#Mac-3" class="headerlink" title="Mac"></a>Mac</h4><p>Redis Desktop Manager</p>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT IGNORE 忽略导致错误的行，如果有则不插入也不报错，并将其余行插入到表中。</span><br></pre></td></tr></table></figure>
<h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 域名&#x2F;ip</span><br></pre></td></tr></table></figure>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>获取列表长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLen key</span><br></pre></td></tr></table></figure>
<p>获取前10个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRANGE key 0 10</span><br></pre></td></tr></table></figure>


<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="Spring-Boot-启动加载数据-CommandLineRunner"><a href="#Spring-Boot-启动加载数据-CommandLineRunner" class="headerlink" title="Spring Boot 启动加载数据 CommandLineRunner"></a>Spring Boot 启动加载数据 CommandLineRunner</h3><p><a class="link"   href="https://blog.csdn.net/catoop/article/details/50501710" >https://blog.csdn.net/catoop/article/details/50501710<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="springboot中-scheduled开关机制"><a href="#springboot中-scheduled开关机制" class="headerlink" title="springboot中@scheduled开关机制"></a>springboot中@scheduled开关机制</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">@ConditionalOnProperty(prefix &#x3D; &quot;scheduling&quot;, name &#x3D; &quot;enabled&quot;, havingValue &#x3D; &quot;true&quot;)</span><br><span class="line">public class SchedulingConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheduling.enabled&#x3D;true</span><br></pre></td></tr></table></figure>


<h2 id="idea-打开cpu监控如何关闭"><a href="#idea-打开cpu监控如何关闭" class="headerlink" title="idea 打开cpu监控如何关闭"></a>idea 打开cpu监控如何关闭</h2><p>view-&gt;tool windows-&gt;coverage-&gt;关闭application</p>
<h2 id="mac查看图片如何来回切换"><a href="#mac查看图片如何来回切换" class="headerlink" title="mac查看图片如何来回切换"></a>mac查看图片如何来回切换</h2><p>按住空格，通过方向键切换</p>
<h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f .&#x2F;catalina.out | grep &#39;舆情秘书&#39; -A 10</span><br></pre></td></tr></table></figure>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">① grep -E &quot;word1|word2|word3&quot; file.txt</span><br><span class="line">满足任意条件（word1、word2和word3之一）将匹配。</span><br><span class="line">② grep word1 file.txt | grep word2 |grep word3</span><br><span class="line">必须同时满足三个条件（word1、word2和word3）才匹配。</span><br></pre></td></tr></table></figure>


<h2 id="idea自动导入包"><a href="#idea自动导入包" class="headerlink" title="idea自动导入包"></a>idea自动导入包</h2><p>Preference（快捷键：command+,）-&gt;maven-&gt;import maven projects automaticallly</p>
<h2 id="idea忽略-iml"><a href="#idea忽略-iml" class="headerlink" title="idea忽略*.iml"></a>idea忽略*.iml</h2><ol>
<li><code>Editor-&gt;File Types=&gt;Ignore files and folders增加*.iml;</code></li>
<li><code>在lgnore files and folesrs中输入.idea;注意要&quot;;&quot;结尾。你就可以隐藏.idea文件夹了</code></li>
</ol>
<h2 id="idea查看properties中文变成unicode码如何解决"><a href="#idea查看properties中文变成unicode码如何解决" class="headerlink" title="idea查看properties中文变成unicode码如何解决"></a>idea查看properties中文变成unicode码如何解决</h2><p>Preference（快捷键：command+,）-&gt;搜索File Encoding-&gt;Transparent native-to-ascii conversion勾选框，勾选之后点击确认。</p>
<h2 id="idea-好用的插件"><a href="#idea-好用的插件" class="headerlink" title="idea 好用的插件"></a>idea 好用的插件</h2><h3 id="Free-Mybatis-plugin"><a href="#Free-Mybatis-plugin" class="headerlink" title="Free Mybatis plugin"></a>Free Mybatis plugin</h3><p>A idea plugin for mybatis free-idea-mybatis is an enchange plugin for idea to supoort mybatis</p>
<h2 id="清除ios输入法预测的记录"><a href="#清除ios输入法预测的记录" class="headerlink" title="清除ios输入法预测的记录"></a>清除ios输入法预测的记录</h2><p>设置》通用》还原》还原键盘词典。</p>
<h2 id="redis-查看当前发布订阅命令"><a href="#redis-查看当前发布订阅命令" class="headerlink" title="redis 查看当前发布订阅命令"></a>redis 查看当前发布订阅命令</h2><p>pubsub channels</p>
<h2 id="imovie"><a href="#imovie" class="headerlink" title="imovie"></a>imovie</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>文件-&gt;分享-&gt;文件-&gt;选择视频或者音频</p>
<h2 id="Mac-4"><a href="#Mac-4" class="headerlink" title="Mac"></a>Mac</h2><h3 id="移动（剪切）"><a href="#移动（剪切）" class="headerlink" title="移动（剪切）"></a>移动（剪切）</h3><ul>
<li>command+c</li>
<li>command+option+v</li>
</ul>
<h3 id="Visual-Studio-Code-Dock没有图标"><a href="#Visual-Studio-Code-Dock没有图标" class="headerlink" title="Visual Studio Code Dock没有图标"></a>Visual Studio Code Dock没有图标</h3><p>最近发现使用Visual Studio Code在Dock上居然找不到图标（bug）。<br>打开<code>terminal</code>命令行工具，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">killall Dock</span><br></pre></td></tr></table></figure>
<p>回车，这样Dock就可以自动重启，vs code的图标在Dock中也恢复正常显示。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>统计log中关键词出现的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#39;192.168.185.112&#39; | wc | awk &#39;&#123;print $1&#125;&#39;</span><br></pre></td></tr></table></figure>
<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -d &quot;userid&#x3D;69129&amp;KK_TYPE&#x3D;01&quot; http:&#x2F;&#x2F;192.168.185.63:8080&#x2F;SubjectTree&#x2F;getTree.do</span><br></pre></td></tr></table></figure>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#39;192.168.185.112&#39; | wc -l</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat localhost_access_log.txt | grep &#39;192.168.185.112&#39; | wc | awk &#39;&#123;print $1&#125;&#39;</span><br></pre></td></tr></table></figure>
<h3 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init 0</span><br></pre></td></tr></table></figure>
<h3 id="用户组控制目录权限"><a href="#用户组控制目录权限" class="headerlink" title="用户组控制目录权限"></a>用户组控制目录权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown tomcat:tomcat yqms_error.log</span><br></pre></td></tr></table></figure>
<h3 id="SSH下用vim打开文件，文件显示不全"><a href="#SSH下用vim打开文件，文件显示不全" class="headerlink" title="SSH下用vim打开文件，文件显示不全"></a>SSH下用vim打开文件，文件显示不全</h3><p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stty rows 200 columns 250</span><br></pre></td></tr></table></figure>
<h3 id="vim显示行号"><a href="#vim显示行号" class="headerlink" title="vim显示行号"></a>vim显示行号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set number</span><br></pre></td></tr></table></figure>
<h3 id="配置ssh免登录"><a href="#配置ssh免登录" class="headerlink" title="配置ssh免登录"></a>配置ssh免登录</h3><p>首先确认当前用户本地是否存在公钥私钥对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br></pre></td></tr></table></figure>
<p>如果存在跳过这一步，如果不存在使用<code>ssh-keygen</code>即可生成公钥私钥对（一直回车，我们不需要使用密码保护私钥对）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>我们发现当前用户目录下生成以下文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authorized_keys</span><br><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br><span class="line">known_hosts</span><br></pre></td></tr></table></figure>
<p>至此，我们使用<code>ssh-copy-id</code>将公钥复制到远程机器中，即可通过ssh免密访问服务器、scp免密上传文件，类似的应用场景还有github代码管理也有用到，确实非常方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -p 端口号 -i ~&#x2F;.ssh&#x2F;id_rsa.pub 用户名@ip地址</span><br></pre></td></tr></table></figure>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><h4 id="根据关键词筛选日志"><a href="#根据关键词筛选日志" class="headerlink" title="根据关键词筛选日志"></a>根据关键词筛选日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f -n 100 log | grep 关键词</span><br></pre></td></tr></table></figure>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看端口号占用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>
<p>查看端口被哪个进程使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp|grep 8080</span><br></pre></td></tr></table></figure>
<p>在一次启动jar包的服务中，通过以上方法如果找不到端口号占用情况，通过删除nohup文件解决</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><h4 id="根据“java”执行命令的查看进程"><a href="#根据“java”执行命令的查看进程" class="headerlink" title="根据“java”执行命令的查看进程"></a>根据“java”执行命令的查看进程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps ax | grep java</span><br></pre></td></tr></table></figure>
<h4 id="杀死同名全部进程方法"><a href="#杀死同名全部进程方法" class="headerlink" title="杀死同名全部进程方法"></a>杀死同名全部进程方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep phantomjs |grep -v grep|awk &#39;&#123;print $2&#125;&#39;|xargs kill -9</span><br></pre></td></tr></table></figure>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>统计当前目录文档数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls | wc -l</span><br></pre></td></tr></table></figure>
<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>统计磁盘使用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>


<h2 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h2><ul>
<li><p>jenkins SSH插件如果不指定目录位置，默认目录是<code>/root</code>下，需要注意，目前推荐使用默认，方便统一管理。</p>
</li>
<li><p>当配置SSH插件脚本时，需要注意在目标服务器上执行脚本（ssh exec command）时，使用以下命令才能正常使用脚本，启动应用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>dev</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令</title>
    <url>/p/4635.html</url>
    <content><![CDATA[<h2 id="yum命令使用举例"><a href="#yum命令使用举例" class="headerlink" title="yum命令使用举例"></a>yum命令使用举例</h2><h3 id="yum安装nginx"><a href="#yum安装nginx" class="headerlink" title="yum安装nginx"></a>yum安装nginx</h3><ul>
<li>安装命令：yum install nginx</li>
<li>查看列表：yum list | grep nginx</li>
<li>其他相关命令<ul>
<li>查看版本: nginx -v</li>
<li>查看nginx对应的参数: nginx -V </li>
<li>检验配置文件:/usr/sbin/nginx -t </li>
<li>重启Nginx服务<ul>
<li>/usr/sbin/nginx -s reload</li>
</ul>
</li>
<li>rpm -ql nginx //yum 源安装实际上是在我们的服务器上安装了一个一个的rpm包</li>
</ul>
</li>
<li>根据包路径查找安装目录<ul>
<li><strong>rpm -ql 包名称</strong></li>
</ul>
</li>
</ul>
<h3 id="yum安装tomcat"><a href="#yum安装tomcat" class="headerlink" title="yum安装tomcat"></a>yum安装tomcat</h3><ul>
<li>安装命令：yum install tomcat</li>
<li>启动tomcat: sudo systemctl start tomcat</li>
<li>重启tomcat: sudo systemctl restart tomcat<h2 id="vim命令使用"><a href="#vim命令使用" class="headerlink" title="vim命令使用"></a>vim命令使用</h2></li>
<li>查找<ul>
<li>?关键词:从下往上查找</li>
<li>/关键词：从上往下查找</li>
</ul>
</li>
</ul>
<ul>
<li>nginx <ul>
<li>配置静态文件404问题：<a class="link"   href="https://blog.csdn.net/line_aijava/article/details/71473793" >https://blog.csdn.net/line_aijava/article/details/71473793<i class="fas fa-external-link-alt"></i></a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;api&#x2F;v1&#x2F;upload &#123;</span><br><span class="line">     alias &#x2F;opt&#x2F;edu&#x2F;upload&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="yum-安装maven"><a href="#yum-安装maven" class="headerlink" title="yum 安装maven"></a>yum 安装maven</h3></li>
</ul>
</li>
</ul>
<ul>
<li>两步安装maven<ul>
<li>下载包<br>wget <a class="link"   href="http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo" >http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo<i class="fas fa-external-link-alt"></i></a> -O /etc/yum.repos.d/epel-apache-maven.repo</li>
</ul>
</li>
<li>安装maven<br>yum -y install apache-maven<h4 id="查找maven安装路径"><a href="#查找maven安装路径" class="headerlink" title="查找maven安装路径"></a>查找maven安装路径</h4></li>
</ul>
<h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行。在服务器的配置和管理中，这个工具常被应用，简单明了。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pgrep [options] &lt;pattern&gt;</span><br></pre></td></tr></table></figure>
<h3 id="常用举例"><a href="#常用举例" class="headerlink" title="常用举例"></a>常用举例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pgrep java &#x2F;&#x2F; 列出java所有进程</span><br><span class="line">pgrep -c java &#x2F;&#x2F; 当前当前服务器上java进程数量</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java开发时遇到的问题</title>
    <url>/p/1a81.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>maven使用阿里镜像有问题</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>新建或者覆盖settings.xml，完美解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0</span><br><span class="line">                          https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;settings-1.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;alimaven&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">        &lt;&#x2F;mirror&gt;</span><br><span class="line">      &lt;&#x2F;mirrors&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>使用MacOs更新系统Catalina之后Git出现问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools), missing xcrun at: &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;usr&#x2F;bin&#x2F;xcrun</span><br></pre></td></tr></table></figure>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>这是Xcode命令行工具需要更新，在你的Terminal中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
<p>当出现提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode-select: note: install requested for command line developer tools</span><br></pre></td></tr></table></figure>
<p>表示Xcode更新成功，可以正常使用，这个问题主要出现在系统大版本更新的时候，因此时刻保证Xcode工具更新即可避免该问题。</p>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>  在SpringBoot打包成jar后，无法读取自定义文件的解决办法</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>  前两天在做springcloud框架下的项目的时候，用到有一个框架之外的文件需要进行读取，当时在eclipse中编码时通过this.getClass().getResource来获取文件的路径，没有任何的问题，但是在打成jar以后，这是是打成jar包不是war，结果发现不能正常的读取我放在工程里面的文件，但是在jar里面对应的class路径下可以看到该文件，后来将文件直接放到和我一个java文件平级的目录下，问题依然，最后使用了InputStream inputStream=this.getClass().getResourceAsStream(“/config/a.pfx”);来读取，才解决了问题。<br>  tips:切记打成jar后如果需要用到这种框架之外的文件的话要用上面的方法来读取。</p>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>​    ~ SpringBoot: 运行maven打包的jar包报错-jar中没有主清单属性,使用mvn package打jar包，运行java -jar XXX.jar的时候报错：jar中没有主清单属性。</p>
<h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h4><p>​    ~ pom.xml中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;plugin&gt;</span><br><span class="line">	&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>
<p>​        再次运行mvn package之后，即可正常运行。</p>
<h2 id="问题：接口请求Status-blocked-other"><a href="#问题：接口请求Status-blocked-other" class="headerlink" title="问题：接口请求Status(blocked:other)"></a>问题：接口请求Status(blocked:other)</h2><p>有一次在前端请求后台提供的接口时，突然发现自己的浏览器不能请求</p>
<p><img src="http://img.mynamecoder.com/FrHqA_C7J80ifxtGHoPjlF1emCU3"></p>
<p>倒腾了很久，才发现是被浏览器插件（如我使用的是AdBlock插件）当作广告拦截了，当你在一个广告业务的公司工作，尤其要注意一哈。</p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><ol>
<li>停用你的广告拦截器</li>
<li>在当前网站停用广告拦截插件（比如AdBlock）</li>
</ol>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>我是如何用IDEA调试BUG的？</title>
    <url>/p/8644.html</url>
    <content><![CDATA[<blockquote>
<p>最近小明的bug有点多，忙的连王者荣耀都顾不上玩了，导致现在不得不抽点时间研究一下作为当前大多Java程序员开发工具的IDEA DEBUG功能，以提高效率。</p>
</blockquote>
<h3 id="一、条件断点"><a href="#一、条件断点" class="headerlink" title="一、条件断点"></a>一、条件断点</h3><a id="more"></a>

<blockquote>
<p>场景：我们在遍历某个集合，期望程序在满足某些预设条件时停住，比如：沐芳老师在课堂上点名，需要在点到小明的时候暂停确认一下是否有人在帮小明答“到”！</p>
</blockquote>
<p>那沐芳老师可以这样：</p>
<p><img src="https://img.mynamecoder.com/20200331212416.png"></p>
<p>右击断点旁边的小红点（断点），弹出面板，在<strong>Condition</strong>这里填入暂停条件（返回boolean类型，一定要遵守语法哈），这样调试时，当程序满足条件时就会稳稳地停在<code>&quot;小明&quot;.equals(student)</code>的位置。</p>
<h3 id="二、回到”过去”"><a href="#二、回到”过去”" class="headerlink" title="二、回到”过去”"></a>二、回到”过去”</h3><blockquote>
<p>场景：人非圣贤，孰能无过。在日常开发中，大家都有手残的时候，比如在调试一个业务逻辑比较复杂，有多个方法嵌套时，一不小心手抖，断点过去了，这该怎么办？</p>
</blockquote>
<p>这天，沐芳老师如往常一样在上课前点名，当点到小明的时候，不争气的小明在偷偷看喜欢的妹子，没有注意听，当反应过来时，已经错过了答到！十分懊悔（红颜祸水啊），这时小明就可以借用大雄的机器猫进行时光穿梭：</p>
<p><img src="https://img.mynamecoder.com/20200329231627.png"></p>
<p>观察上图，我们看到，按照点名顺序，现在沐芳老师点名已经轮到小红，小明已经错过答到，机器猫可以这样帮助小明：点击上图红色框框圈中的<strong>Drop Frame</strong>图标（如果存在多个方法的嵌套调用，可以多点几下），就这样，小明穿越了，没有错过这次的答到：</p>
<p><img src="https://img.mynamecoder.com/20200329231834.png"></p>
<p><strong>tips</strong>:这个按钮之所以叫做<strong>Drop Frame</strong>，是因为<strong>JVM</strong>内部是以<strong>栈帧</strong>为单位来保存线程的运行状态，<strong>Drop Frame</strong>直译过来就是扔掉当前运行的栈帧，回到上一帧的位置，这样就实现了穿越。</p>
<h3 id="三、多线程调试"><a href="#三、多线程调试" class="headerlink" title="三、多线程调试"></a>三、多线程调试</h3><blockquote>
<p>终于老师点名结束了，现在可以正常上课了。到了同学们最爱的老师提问，同学们抢答的环节。</p>
</blockquote>
<p>As we know 当我们启动多个线程时，哪个线程内的程序先执行，完全靠CPU的心情（爸爸一样的存在），这样就会造成一个问题：无法像单线程那样按照执行顺序debug。现象就是你只管打断点，线程之间不乱跳算我输，程序举例如下：</p>
<p><img src="https://img.mynamecoder.com/20200329233500.png"></p>
<p>老师提出问题后，四个同学开始抢答：</p>
<p><img src="https://img.mynamecoder.com/20200329235936.png"></p>
<p>这么多同学抢答，让坚守岗位30多年的沐芳老师觉得再这样下去课堂可能会有点混乱：但这并难不倒从业30多年的沐芳老师，她按如下图所示：在断点的位置上右击，选择<strong>Thread</strong>，就可以有目的地跟踪某一位同学的抢答情况（一切都在掌握之中）。</p>
<p><img src="https://img.mynamecoder.com/20200330000443.png"></p>
<h3 id="四、远程调试"><a href="#四、远程调试" class="headerlink" title="四、远程调试"></a>四、远程调试</h3><p>大家能看到这里，小明不得不给大家介绍一个装X的技能：云调试。即本机不用启动项目，只要本机的源代码与远程服务器运行的jar包匹配，就可以在本机直接远程调试服务器上的代码！打开姿势如下：</p>
<h4 id="远程项目启动时，先允许远程调试"><a href="#远程项目启动时，先允许远程调试" class="headerlink" title="远程项目启动时，先允许远程调试"></a>远程项目启动时，先允许远程调试</h4><p>现在大多都是SpringBoot项目，因此我们在远程服务器上运行一个jar包时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -server -Xms512m -Xmx512m -Xdebug -Xnoagent -Djava.compiler&#x3D;NONE -Xrunjdwp:transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;8080 -jar xiaoming.jar</span><br></pre></td></tr></table></figure>
<p>这里起作用的核心命令就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xdebug -Xnoagent -Djava.compiler&#x3D;NONE -Xrunjdwp:transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;8080</span><br></pre></td></tr></table></figure>
<blockquote>
<p>远程调试从技术上讲，就是在本机与远程服务之间建立scoket通讯，所以本机要可以访问到远程服务的端口。</p>
</blockquote>
<h4 id="在idea中设置远程调试"><a href="#在idea中设置远程调试" class="headerlink" title="在idea中设置远程调试"></a>在idea中设置远程调试</h4><p><img src="https://img.mynamecoder.com/20200330003106.png"></p>
<p>接下来我们就可以正常调试了，调试方式和本地运行服务调试无差，不信你发起一个请求，并在对应的逻辑代码中打个断点试试？</p>
<h3 id="五、临时执行表达式"><a href="#五、临时执行表达式" class="headerlink" title="五、临时执行表达式"></a>五、临时执行表达式</h3><p>再一个就是调试时，我们还可以临时执行一些表达式，点击红色框框选中的图标，然后输入你想执行的表达式，如下所示：</p>
<p><img src="https://img.mynamecoder.com/20200330004714.png"></p>
<p>大家可以看到，小明心灵是多么脆弱，因为无法直面自己的实际年龄，再快要得到真实年龄是，偷偷的减去了7年，所以他实际年龄永远为18岁（手动滑稽）。</p>
<h3 id="六、修改变量的运行值"><a href="#六、修改变量的运行值" class="headerlink" title="六、修改变量的运行值"></a>六、修改变量的运行值</h3><p>当然，如果调试时，想动态修改变量的值，也很容易，在变量上右击，然后选择<strong>Set Value</strong>，比如简单粗暴的更改小明的年龄为18……</p>
<p><img src="https://img.mynamecoder.com/20200330005141.png"></p>
<p>以上，这就是小明近期总结的IDEA的DEBUG技巧，希望可以帮助到大家。善用上述调试技巧，相信大家撸起代码来会更加有感觉，主要体现在：今晚可以不用加班！</p>
<p>代码已经提交到Github地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming" >https://github.com/WhenCoding/coder-xiaoming<i class="fas fa-external-link-alt"></i></a><br><em>欢迎大家关注微信公众号“程序员小明”，获取更多精彩！</em></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>小明收藏的利器</title>
    <url>/p/a8a6.html</url>
    <content><![CDATA[<h2 id="在线工具全览"><a href="#在线工具全览" class="headerlink" title="在线工具全览"></a>在线工具全览</h2><p><a class="link"   href="https://www.toolnb.com/"  title="想要的都有">https://www.toolnb.com/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="免费的图片上传获取链接"><a href="#免费的图片上传获取链接" class="headerlink" title="免费的图片上传获取链接"></a>免费的图片上传获取链接</h2><p><a class="link"   href="https://zh-cn.imgbb.com/"  title="上传与分享您的照片">https://zh-cn.imgbb.com/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="MarkDown样式自由转换"><a href="#MarkDown样式自由转换" class="headerlink" title="MarkDown样式自由转换"></a>MarkDown样式自由转换</h2><ul>
<li>在线使用：<a class="link"   href="http://md.aclickall.com/"  title="力荐">http://md.aclickall.com/<i class="fas fa-external-link-alt"></i></a></li>
<li>在线使用：<a class="link"   href="https://md.rmiao.top/"  title="同上">https://md.rmiao.top/<i class="fas fa-external-link-alt"></i></a></li>
<li>浏览器插件 Markdown here<h2 id="好用的图标"><a href="#好用的图标" class="headerlink" title="好用的图标"></a>好用的图标</h2></li>
<li><a class="link"   href="https://imgchr.com/"  title="支持html、markdown、BBCode等格式！（力荐）">https://imgchr.com/<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.iconfont.cn/"  title="应有尽有哦">https://www.iconfont.cn<i class="fas fa-external-link-alt"></i></a><h2 id="自学python书籍推荐《自学是门手艺》"><a href="#自学python书籍推荐《自学是门手艺》" class="headerlink" title="自学python书籍推荐《自学是门手艺》"></a>自学python书籍推荐《自学是门手艺》</h2>github地址: <a class="link"   href="https://github.com/selfteaching/the-craft-of-selfteaching"  title="自学是门手艺">https://github.com/selfteaching/the-craft-of-selfteaching<i class="fas fa-external-link-alt"></i></a><h2 id="抢票必备"><a href="#抢票必备" class="headerlink" title="抢票必备"></a>抢票必备</h2></li>
<li>windows:<a class="link"   href="https://www.bypass.cn/" >https://www.bypass.cn/<i class="fas fa-external-link-alt"></i></a></li>
<li>mac：这个需要使用python开源项目<a class="link"   href="https://github.com/testerSunshine/12306" >https://github.com/testerSunshine/12306<i class="fas fa-external-link-alt"></i></a><h2 id="缩短你的网址"><a href="#缩短你的网址" class="headerlink" title="缩短你的网址"></a>缩短你的网址</h2></li>
<li>虽然类似的有好多，但是只有微博的更强大：<a class="link"   href="http://dwz.wailian.work/" >http://dwz.wailian.work/<i class="fas fa-external-link-alt"></i></a><h2 id="表格转换"><a href="#表格转换" class="headerlink" title="表格转换"></a>表格转换</h2>支持makdown、IDEA、CSV、JSON、xml、yaml、sql、html、excel、latex、T TEXT相互转换</li>
<li><a class="link"   href="https://tableconvert.com/"  title="真心爽">https://tableconvert.com/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>公众号开发入门：查询用户是否已经关注公众号？</title>
    <url>/p/d69c.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> 最近，小明在参与app改版时，有一个业务场景是：用户完成指定的任务，判断当前登录用户是否已经关注指定的官方微信公众号，如果关注会获得相应的奖励，为了弥补语言的匮乏，小明偷偷给大家上张图：</p>
<p><img src="https://i.ibb.co/PMmYvfz/image.png" alt="app截图"></p>
<a id="more"></a>
<p>众所周知，我们程序员第一次接收到之前没做过的需求时，第一步肯定离不开搜查资料（我觉得国内的产品，百度就够用），小明也不例外，花了大概五分钟，一切就了然于胸，由此可见，程序员的<strong>搜商</strong>很重要 😂。ok，废话少说，翠花，上菜！。</p>
<h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2><ul>
<li>微信公众平台-开发-基本配置-成为开发者，得到 <code>appId</code> 和 <code>appSecret</code>（注意：<code>appSecret</code>只展示一次，需保存下来，否则需要重置获取），</li>
<li>添加ip白名单，这个是为了提高公众平台开发者接口调用的安全性，避免一旦开发者ID和密码泄露后给帐号造成损失。对调用“获取<code>access_token</code>”接口增加IP白名单校验：只有将IP地址设置为公众号的IP白名单，才能成功调用该接口。</li>
<li>微信认证通过，拥有获取用户基本信息的权限（注意：如果帐号主体为个人，是无法开通微信认证的）；</li>
</ul>
<h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><h3 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https请求方式: GET</span><br><span class="line">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;token?grant_type&#x3D;client_credential&amp;appid&#x3D;APPID&amp;secret&#x3D;APPSECRET</span><br></pre></td></tr></table></figure>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grant_type</td>
<td>是</td>
<td>获取access_token填写client_credential</td>
</tr>
<tr>
<td>appid</td>
<td>是</td>
<td>第三方用户唯一凭证</td>
</tr>
<tr>
<td>secret</td>
<td>是</td>
<td>第三方用户唯一凭证密钥，即appsecret</td>
</tr>
</tbody></table>
<h4 id="返回说明"><a href="#返回说明" class="headerlink" title="返回说明"></a>返回说明</h4><p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>access_token</td>
<td>获取到的凭证</td>
</tr>
<tr>
<td>expires_in</td>
<td>凭证有效时间，单位：秒</td>
</tr>
</tbody></table>
<p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为AppID无效错误）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errcode&quot;:40013,&quot;errmsg&quot;:&quot;invalid appid&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回码说明"><a href="#返回码说明" class="headerlink" title="返回码说明"></a>返回码说明</h4><table>
<thead>
<tr>
<th>返回码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>系统繁忙，此时请开发者稍候再试</td>
</tr>
<tr>
<td>0</td>
<td>请求成功</td>
</tr>
<tr>
<td>40001</td>
<td>AppSecret错误或者AppSecret不属于这个公众号，请开发者确认AppSecret的正确性</td>
</tr>
<tr>
<td>40002</td>
<td>请确保grant_type字段值为client_credential</td>
</tr>
<tr>
<td>40164</td>
<td>调用接口的IP地址不在白名单中，请在接口IP白名单中进行设置。（小程序及小游戏调用不要求IP地址在白名单内。）</td>
</tr>
</tbody></table>
<p>详情查看官方文档-获取access_token： <a class="link"   href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" >https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="获取用户openId或者unionId"><a href="#获取用户openId或者unionId" class="headerlink" title="获取用户openId或者unionId"></a>获取用户openId或者unionId</h3><p>在关注者与公众号产生<strong>消息交互后</strong>，公众号可获得关注者的OpenID（说明：OpenID就是加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。特别需要注意的是，如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号，用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。因此,如果要判断当前登陆app的微信用户是否关注官方微信公众号，我们要使用的是unionId。需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<h3 id="根据前两个步骤获得的信息（access-token和openId或者unionId），调用微信接口获取用户基本信息"><a href="#根据前两个步骤获得的信息（access-token和openId或者unionId），调用微信接口获取用户基本信息" class="headerlink" title="根据前两个步骤获得的信息（access_token和openId或者unionId），调用微信接口获取用户基本信息"></a>根据前两个步骤获得的信息（access_token和openId或者unionId），调用微信接口获取用户基本信息</h3><p>完整的用户基本信息包括昵称、头像、性别、所在城市、语言和关注时间等。<br>接口调用请求说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https请求方式: GET</span><br><span class="line">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;info?access_token&#x3D;ACCESS_TOKEN&amp;openid&#x3D;OPENID&amp;lang&#x3D;zh_CN</span><br></pre></td></tr></table></figure>
<h4 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>是否必须</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>access_token</td>
<td>是</td>
<td>调用接口凭证</td>
</tr>
<tr>
<td>openid</td>
<td>是</td>
<td>普通用户的标识，对当前公众号唯一</td>
</tr>
<tr>
<td>lang</td>
<td>否</td>
<td>返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语</td>
</tr>
</tbody></table>
<h4 id="返回说明-1"><a href="#返回说明-1" class="headerlink" title="返回说明"></a>返回说明</h4><p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;subscribe&quot;: 1, &#x2F;&#x2F;这就是我们想要的值哈，解释如下表格</span><br><span class="line">    &quot;openid&quot;: &quot;o6_bmjrPTlm6_2sgVt7hMZOPfL2M&quot;, </span><br><span class="line">    &quot;nickname&quot;: &quot;Band&quot;, </span><br><span class="line">    &quot;sex&quot;: 1, </span><br><span class="line">    &quot;language&quot;: &quot;zh_CN&quot;, </span><br><span class="line">    &quot;city&quot;: &quot;广州&quot;, </span><br><span class="line">    &quot;province&quot;: &quot;广东&quot;, </span><br><span class="line">    &quot;country&quot;: &quot;中国&quot;, </span><br><span class="line">    &quot;headimgurl&quot;:&quot;http:&#x2F;&#x2F;thirdwx.qlogo.cn&#x2F;mmopen&#x2F;g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe&#x2F;0&quot;,</span><br><span class="line">    &quot;subscribe_time&quot;: 1382694957,</span><br><span class="line">    &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">    &quot;remark&quot;: &quot;&quot;,</span><br><span class="line">    &quot;groupid&quot;: 0,</span><br><span class="line">    &quot;tagid_list&quot;:[128,2],</span><br><span class="line">    &quot;subscribe_scene&quot;: &quot;ADD_SCENE_QR_CODE&quot;,</span><br><span class="line">    &quot;qr_scene&quot;: 98765,</span><br><span class="line">    &quot;qr_scene_str&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>subscribe</td>
<td><strong>用户是否订阅该公众号标识，值为0时，代表此用户没有关注该公众号，拉取不到其余信息。</strong></td>
</tr>
<tr>
<td>openid</td>
<td>用户的标识，对当前公众号唯一</td>
</tr>
<tr>
<td>nickname</td>
<td>用户的昵称</td>
</tr>
<tr>
<td>sex</td>
<td>用户的性别，值为1时是男性，值为2时是女性，值为0时是未知</td>
</tr>
<tr>
<td>city</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>……</td>
<td></td>
</tr>
</tbody></table>
<p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为AppID无效错误）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errcode&quot;:40013,&quot;errmsg&quot;:&quot;invalid appid&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>详情查看官方文档-获取用户基本信息 <a class="link"   href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839" >https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839<i class="fas fa-external-link-alt"></i></a></p>
<p>好了，以上就是今天小明整理给大家的有关公众号开发的文档。欢迎大家多多交流学习。</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>日常开发</category>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>【面试】最容易被问到的N种排序算法！</title>
    <url>/p/7836.html</url>
    <content><![CDATA[<blockquote>
<p>面试官：小明，是吧？你都知道哪些排序算法，哪几种是稳定排序？<br>小明：这个我有总结！</p>
</blockquote>
<h1 id="关于排序稳定性的定义"><a href="#关于排序稳定性的定义" class="headerlink" title="关于排序稳定性的定义"></a>关于排序稳定性的定义</h1><p>通俗地讲就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<h1 id="现实生活中稳定排序如何表现呢？"><a href="#现实生活中稳定排序如何表现呢？" class="headerlink" title="现实生活中稳定排序如何表现呢？"></a>现实生活中稳定排序如何表现呢？</h1><blockquote>
<p>举个例子：<br>某次学校发奖学金，只有排在前三个的有奖，结果一排序把原来在第三位的并列第三名给弄到第四位了，他估计不会乐意😂</p>
</blockquote>
<p>接下来给大家用java代码演绎一下常见的几种排序，前提：有一个数组arr，要求从小到大排序。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>简单选择排序的思想是：从第一个位置开始，逐渐向后，选择后面的无序序列中的最小值放到该位置。很简单，直接上代码吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;选择排序</span><br><span class="line">for(int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;&#x2F;&#x2F; 做第i趟排序</span><br><span class="line">    int k &#x3D; i;</span><br><span class="line">    for(int j &#x3D; k + 1; j &lt; arr.length; j++)&#123;&#x2F;&#x2F; 选最小的记录</span><br><span class="line">        if(arr[j] &lt; arr[k])&#123; </span><br><span class="line">            k &#x3D; j; &#x2F;&#x2F;记下目前找到的最小值所在的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span><br><span class="line">    if(i !&#x3D; k)&#123;  &#x2F;&#x2F;交换a[i]和a[k]</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[k];</span><br><span class="line">        arr[k] &#x3D; temp;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那选择排序是稳定排序吗？"><a href="#那选择排序是稳定排序吗？" class="headerlink" title="那选择排序是稳定排序吗？"></a>那选择排序是稳定排序吗？</h2><blockquote>
<p>举个例子，假如有序列[5,8,5,2,9]按从小到大排序，第一遍排序,第一个元素“5”会和第四个元素“2”交换，那么原序列中两个“5”的相对前后顺序此时就遭到破坏了，由此可见，选择排序不是一个稳定的排序算法。</p>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序就是相邻的两个元素之间按照要求进行比较交换，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 冒泡排序</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123; &#x2F;&#x2F;外层循环n-1</span><br><span class="line">    for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123; &#x2F;&#x2F;内层循环n-i-1</span><br><span class="line">        if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F;从第一个开始，往后两两比较大小，如果前面的比后面的大，交换位置</span><br><span class="line">            int tmp &#x3D; arr[j];</span><br><span class="line">            arr[j] &#x3D; arr[j + 1];</span><br><span class="line">            arr[j + 1] &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那冒泡排序是稳定排序吗？"><a href="#那冒泡排序是稳定排序吗？" class="headerlink" title="那冒泡排序是稳定排序吗？"></a>那冒泡排序是稳定排序吗？</h2><p>因为发生在相邻的元素之间，所以，如果两个元素相等，我们是不会多此一举把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定</strong>排序算法。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 插入排序</span><br><span class="line">for (int index &#x3D; 1; index &lt; length; index++) &#123; &#x2F;&#x2F;外层向右的index，即作为比较对象的数据的index</span><br><span class="line">    int temp &#x3D; arr[index]; &#x2F;&#x2F;用作比较的数据</span><br><span class="line">    int leftindex &#x3D; index - 1;</span><br><span class="line">    while (leftindex &gt;&#x3D; 0 &amp;&amp; arr[leftindex] &gt; temp) &#123; &#x2F;&#x2F;当比到最左边或者遇到比temp小的数据时，结束循环</span><br><span class="line">        arr[leftindex + 1] &#x3D; arr[leftindex];</span><br><span class="line">        leftindex--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[leftindex + 1] &#x3D; temp;&#x2F;&#x2F;把temp放到空位上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，左边会产生一个只有一个元素的有序序列，比较是从该有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。</p>
<h2 id="那插入排序是稳定排序吗？"><a href="#那插入排序是稳定排序吗？" class="headerlink" title="那插入排序是稳定排序吗？"></a>那插入排序是稳定排序吗？</h2><p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序有两个方向，左边的i下标一直往右走，当<code>a[i] &lt;= a[center_index]</code>，其中<code>center_index</code>是中枢元素的数组下标，一般取为数组<strong>第0个元素</strong>。而右边的j下标一直往左走，当<code>a[j] &gt; a[center_index]</code>。如果i和j都走不动了，<code>i &lt;= j</code>，交换<code>a[i]</code>和<code>a[j]</code>,重复上面的过程，直到<code>i &gt; j</code>。 交换<code>a[j]</code>和<code>a[center_index]</code>，完成一趟快速排序。在中枢元素和<code>a[j]</code>交换的时候，很有可能把前面的元素的稳定性打乱，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 快速排序</span><br><span class="line">public static void sort(int[] a, int low, int height) &#123;</span><br><span class="line">        int i &#x3D; low;</span><br><span class="line">        int j &#x3D; height;</span><br><span class="line">        if (i &gt; j) &#123;    &#x2F;&#x2F;放在k之前，防止下标越界</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int k &#x3D; a[i];</span><br><span class="line">        while (i &lt; j) &#123;   </span><br><span class="line">            while (i &lt; j &amp;&amp; a[j] &gt; k) &#123;    &#x2F;&#x2F;找出小的数</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            while (i &lt; j &amp;&amp; a[i] &lt;&#x3D; k) &#123;  &#x2F;&#x2F;找出大的数</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;   &#x2F;&#x2F;交换</span><br><span class="line">                int swap &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; a[j];</span><br><span class="line">                a[j] &#x3D; swap;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;交换K</span><br><span class="line">        k &#x3D; a[i];</span><br><span class="line">        a[i] &#x3D; a[low];</span><br><span class="line">        a[low] &#x3D; k;</span><br><span class="line">        &#x2F;&#x2F;对左边进行排序,递归算法</span><br><span class="line">        sort(a, low, i - 1);</span><br><span class="line">        &#x2F;&#x2F;对右边进行排序</span><br><span class="line">        sort(a, i + 1, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那快速排序是稳定排序吗？"><a href="#那快速排序是稳定排序吗？" class="headerlink" title="那快速排序是稳定排序吗？"></a>那快速排序是稳定排序吗？</h2><blockquote>
<p>比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第五个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
</blockquote>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 归并排序</span><br><span class="line">public class Main &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr &#x3D; &#123;11,44,23,67,88,65,34,48,9,12&#125;;</span><br><span class="line">		int[] tmp &#x3D; new int[arr.length];    &#x2F;&#x2F;新建一个临时数组存放</span><br><span class="line">		mergeSort(arr,0,arr.length-1,tmp);</span><br><span class="line">		for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void merge(int[] arr,int low,int mid,int high,int[] tmp)&#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		int j &#x3D; low,k &#x3D; mid+1;  &#x2F;&#x2F;左边序列和右边序列起始索引</span><br><span class="line">		while(j &lt;&#x3D; mid &amp;&amp; k &lt;&#x3D; high)&#123;</span><br><span class="line">			if(arr[j] &lt; arr[k])&#123;</span><br><span class="line">				tmp[i++] &#x3D; arr[j++];</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				tmp[i++] &#x3D; arr[k++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;若左边序列还有剩余，则将其全部拷贝进tmp[]中</span><br><span class="line">		while(j &lt;&#x3D; mid)&#123;    </span><br><span class="line">			tmp[i++] &#x3D; arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		while(k &lt;&#x3D; high)&#123;</span><br><span class="line">			tmp[i++] &#x3D; arr[k++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int t&#x3D;0;t&lt;i;t++)&#123;</span><br><span class="line">			arr[low+t] &#x3D; tmp[t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public static void mergeSort(int[] arr,int low,int high,int[] tmp)&#123;</span><br><span class="line">		if(low&lt;high)&#123;</span><br><span class="line">			int mid &#x3D; (low+high)&#x2F;2;</span><br><span class="line">			mergeSort(arr,low,mid,tmp); &#x2F;&#x2F;对左边序列进行归并排序</span><br><span class="line">			mergeSort(arr,mid+1,high,tmp);  &#x2F;&#x2F;对右边序列进行归并排序</span><br><span class="line">			merge(arr,low,mid,high,tmp);    &#x2F;&#x2F;合并两个有序序列</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那归并排序是稳定排序吗？"><a href="#那归并排序是稳定排序吗？" class="headerlink" title="那归并排序是稳定排序吗？"></a>那归并排序是稳定排序吗？</h2><p>可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是<strong>稳定</strong>的排序算法。</p>
<h1 id="基数排序（又称桶子法）"><a href="#基数排序（又称桶子法）" class="headerlink" title="基数排序（又称桶子法）"></a>基数排序（又称桶子法）</h1><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p>
<p><img src="https://s2.ax1x.com/2019/06/21/Vxw1G4.gif" alt="桶子法动画"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 基数排序（又称桶子法）</span><br><span class="line">public static void myRadixSort(int[] arr) &#123;</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;        找到最大的数</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; max) &#123;</span><br><span class="line">            max &#x3D; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;        获取最大数的位数</span><br><span class="line">    int times &#x3D; 0;</span><br><span class="line">    while (max &gt; 0) &#123;</span><br><span class="line">        max &#x3D; max &#x2F; 10;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;        创建一个二维的list</span><br><span class="line">    List&lt;ArrayList&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;  创建10个list（每一位有从0到9，一共10个数，每个list数组用来存放每次迭代中，0-9 每个数组中需要装入的数）</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        ArrayList list1 &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F;在二维数组中把这10个数组加进去，相当于二维数组的行，从0-9的行</span><br><span class="line">        list.add(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;        进行times次分配和收集</span><br><span class="line">    for (int i &#x3D; 0; i &lt; times; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            分配</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            int x &#x3D; arr[j] % (int) Math.pow(10, i + 1) &#x2F; (int) Math.pow(10, i);</span><br><span class="line">            &#x2F;&#x2F; list.get(x) 是在返回第0的这个行的list上面的数，然后再 add(arr[j]) 是把当前的这个数添加到末尾去</span><br><span class="line">            list.get(x).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;            收集        ------------&gt;   把这0-9共10个list里面的数值存到一个数组里面</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">            while (list.get(j).size() &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 把list这个二维list中的第j行返回并赋值给list2</span><br><span class="line">                ArrayList&lt;Integer&gt; list2 &#x3D; list.get(j);</span><br><span class="line">                &#x2F;&#x2F;  把list2这个数组中的第0个位置的元素，赋值给arr[count]         </span><br><span class="line">                arr[count] &#x3D; list2.get(0);</span><br><span class="line">                &#x2F;&#x2F;   把list2这个数组中的第0个位置的元素删除掉，则后面的元素会自动移上来                      </span><br><span class="line">                list2.remove(0);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那基数排序是稳定排序吗？"><a href="#那基数排序是稳定排序吗？" class="headerlink" title="那基数排序是稳定排序吗？"></a>那基数排序是稳定排序吗？</h2><p>由上可得，基数排序基于分别排序，分别收集，所以其是稳定的<strong>排序算法</strong>。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序是按照不同步长对元素进行<strong>插入排序</strong>，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高，所以，希尔排序的时间复杂度会比O(n^2)好一些。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 希尔排序</span><br><span class="line">int incrementNum &#x3D; arr.length &#x2F; 2;</span><br><span class="line">while (incrementNum &gt;&#x3D; 1) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;进行插入排序</span><br><span class="line">        for (int j &#x3D; i; j &lt; arr.length - incrementNum; j &#x3D; j + incrementNum) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + incrementNum]) &#123;</span><br><span class="line">                int temple &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; arr[j + incrementNum];</span><br><span class="line">                arr[j + incrementNum] &#x3D; temple;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置新的增量</span><br><span class="line">    incrementNum &#x3D; incrementNum &#x2F; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="那希尔排序是稳定排序吗？"><a href="#那希尔排序是稳定排序吗？" class="headerlink" title="那希尔排序是稳定排序吗？"></a>那希尔排序是稳定排序吗？</h2><p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><a class="link"   href="https://www.cnblogs.com/chengxiao/p/6129630.html" >堆排序<i class="fas fa-external-link-alt"></i></a>的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了,代码举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 堆排序</span><br><span class="line">public static void sort(int[] arr) &#123;</span><br><span class="line">    &#x2F;&#x2F;1.构建大顶堆</span><br><span class="line">    for (int i &#x3D; arr.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F;从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">    for (int j &#x3D; arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">        swap(arr, 0, j);&#x2F;&#x2F;将堆顶元素与末尾元素进行交换</span><br><span class="line">        adjustHeap(arr, 0, j);&#x2F;&#x2F;重新对堆进行调整</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="line">*</span><br><span class="line">* @param arr</span><br><span class="line">* @param i</span><br><span class="line">* @param length</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void adjustHeap(int[] arr, int i, int length) &#123;</span><br><span class="line">    int temp &#x3D; arr[i];&#x2F;&#x2F;先取出当前元素i</span><br><span class="line">    for (int k &#x3D; i * 2 + 1; k &lt; length; k &#x3D; k * 2 + 1) &#123;&#x2F;&#x2F;从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">        if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;&#x2F;&#x2F;如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr[k] &gt; temp) &#123;&#x2F;&#x2F;如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">            arr[i] &#x3D; arr[k];</span><br><span class="line">            i &#x3D; k;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] &#x3D; temp;&#x2F;&#x2F;将temp值放到最终的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 交换元素</span><br><span class="line">*</span><br><span class="line">* @param arr</span><br><span class="line">* @param a</span><br><span class="line">* @param b</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void swap(int[] arr, int a, int b) &#123;</span><br><span class="line">    int temp &#x3D; arr[a];</span><br><span class="line">    arr[a] &#x3D; arr[b];</span><br><span class="line">    arr[b] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="那堆排序是稳定排序吗？"><a href="#那堆排序是稳定排序吗？" class="headerlink" title="那堆排序是稳定排序吗？"></a>那堆排序是稳定排序吗？</h2><p>我们知道堆的结构是节点i的孩子为<code>2 * i</code>和<code>2 * i + 1</code>节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第<code>n / 2</code>开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为<code>n / 2 - 1， n / 2 - 2， ... 1</code>这些个父节点选择元素时，就会破坏稳定性。有可能第<code>n / 2</code>个父节点交换把后面一个元素交换过去了，而第<code>n / 2 - 1</code>个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>不稳定的排序: 选择排序、快速排序、希尔排序、堆排序</li>
<li>稳定排序：冒泡排序、插入排序、归并排序、基数排序</li>
</ul>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的简历到底该怎么写？</title>
    <url>/p/6d2.html</url>
    <content><![CDATA[<blockquote>
<p>小明最近有换工作的打算，那身为程序员的我们，简历到底应该怎么写呢？</p>
</blockquote>
<p>我们知道，HR在筛选简历时主要从公司需求出发，重点不一，不过还是有很多“通用”的套路，为了在30秒内判断出这份简历是否值得跟进，我认为程序员写简历的正确姿势是这样的：</p>
<h1 id="主要风格"><a href="#主要风格" class="headerlink" title="主要风格"></a>主要风格</h1><p>即首次看到简历后的第一感觉。就好比小明多年相亲未遂，鼓起勇气参加“非诚勿扰”的节目，首次登场，台下的妹子看见他的第一眼，一定会有一个整体的Feel，他是fashion的、小清新的还是老道的？有了第一印象感觉之后，台下的妹子才会确定是灭灯还是亮灯（小明的话八成会是全亮的）。下面给大家举个例子：</p>
<p>加分写法：</p>
<ul>
<li><p>逻辑结构清晰，简洁明了。</p>
</li>
<li><p>字体适中，排版顺畅，清晰整齐。</p>
</li>
<li><p>DF格式，兼容性不仅强而且不易乱序。</p>
</li>
</ul>
<p>减分写法：</p>
<ul>
<li><p>设计的十分浮夸或者十分简单。（eg.简历做的十分酷炫、又是五颜六色，but半天找不到联系方式，抑或是只有个人基本信息和公司名称)</p>
</li>
<li><p>冗余过度，写了好多页，但是半天打不开的，更甚至加载了半天，打开还乱码！</p>
</li>
</ul>
<h1 id="基本信息（姓名-性别-毕业院校-电话-邮箱-居住地-期望地）"><a href="#基本信息（姓名-性别-毕业院校-电话-邮箱-居住地-期望地）" class="headerlink" title="基本信息（姓名/性别/毕业院校/电话/邮箱/居住地/期望地）"></a>基本信息（姓名/性别/毕业院校/电话/邮箱/居住地/期望地）</h1><p>加分写法:</p>
<ul>
<li>清晰罗列出以上信息，这样HR不仅在接下来的电话沟通或面试中不会再去追问这些内容，而且又进一步建立对你的熟悉度。</li>
<li>增加社交账号，比如QQ或者微信，防患于未然（万一有时候HR电话打不通，这种情况挺多见的）</li>
</ul>
<p>减分写法：</p>
<ul>
<li><p>相当大的基本信息没有写。</p>
</li>
<li><p>只留下一个Github链接或者博客链接，甚至极致简洁的几句描述，HR只能通过你的链接来找你的联系方式，那就难受啦。（ps：除非写的特别nice，不然基本是要放弃你了）</p>
</li>
</ul>
<h1 id="工作经历-amp-项目经历"><a href="#工作经历-amp-项目经历" class="headerlink" title="工作经历&amp;项目经历"></a>工作经历&amp;项目经历</h1><p>加分写法：</p>
<ul>
<li>工作经历项目经历可以参照万能的STAR法则来写。（STAR不清楚的童鞋自觉百度哈）</li>
<li>曾经效力过哪些公司，是否和求职公司匹配？</li>
<li>做过什么行业领域，是否和求职公司匹配？</li>
<li>你最擅长的技术语言，应用了哪些技术栈？（Java,Scala,Pyhton,Ruby, React, Vue, Microservice…）</li>
<li>经历的项目时间复杂度，及在项目中承担什么样的角色(人的变化/技术的变化/环境的变化/不同工作经历相同角色的不同点)</li>
<li>时间节点（空档期）</li>
</ul>
<p>减分写法：</p>
<ul>
<li>HR观摩了半天，不知所云，毫无亮点，没有可以继续聊一聊的话题。</li>
</ul>
<h1 id="先来几个栗子"><a href="#先来几个栗子" class="headerlink" title="先来几个栗子"></a>先来几个栗子</h1><h2 id="栗子1错误打开方式："><a href="#栗子1错误打开方式：" class="headerlink" title="栗子1错误打开方式："></a>栗子1错误打开方式：</h2><ul>
<li>XX（全栈工程师）2013.06 — 至今</li>
<li>参与需求分析及实现方案设计。</li>
<li>产品线上部署及运维。</li>
<li>负责公司配置管理，环境维护等工作</li>
<li>负责公司产品性能测试，及线上数据分析</li>
<li>设计数据库表结构，实现后台功能及web页面展示。</li>
</ul>
<p>点评：太概括不具体，没有逻辑性，甚至不知道采用的技术语言，根本不能了解情况。</p>
<h2 id="栗子2正确打开方式："><a href="#栗子2正确打开方式：" class="headerlink" title="栗子2正确打开方式："></a>栗子2正确打开方式：</h2><p>北京XXX公司 Java工程师 — 2017.2月-2018.4月<br>1、LINK推荐架构数据与缓存层设计开发</p>
<ul>
<li>LINK是一款时尚资讯app,负责推荐页面资讯feed流的展示及用户历史的展示；</li>
<li>负责进行压测监测、缓存处理,对接又进一步改进优化,主用redis缓存；</li>
<li>负责数据层,处理前端逻辑整个开发工作,分布式rpc服务搭建。</li>
</ul>
<p>2、基于JAVA的电商爬虫开发</p>
<ul>
<li>使用java搭建爬虫server平台,进行配置和开发,进行网页改版监测功能开发；</li>
<li>通过频率、ip池、匿名代理等应对一些网站的反爬；</li>
<li>爬取淘宝时尚品牌与其他电商网站商品品牌与详情等。</li>
</ul>
<p>3、同图搜索Solr服务开发</p>
<ul>
<li>基于算法组的同图策略,使用solr做java接口，又实现rpc服务搭建,进行索引构建和solr实现。</li>
<li>点评：非常清晰的告诉简历阅读者自己做了什么事情，负责了什么样的事情，用了什么技术栈，且逻辑连贯。</li>
</ul>
<h1 id="工作期望-amp-个人评价"><a href="#工作期望-amp-个人评价" class="headerlink" title="工作期望&amp;个人评价"></a>工作期望&amp;个人评价</h1><p>加分写法：</p>
<ul>
<li>对自己有一个全方位的一个描述总结，可以让他人更好的解读我们。甚至可以在此处，大笔书写你的优点特长有哪些。</li>
<li>我们可以不写个人评价，但是也一定记得写上工作期望！</li>
</ul>
<p>减分写法：</p>
<ul>
<li>丝毫看不出个性特点，写和没写没什么区别。  再 来几个栗子</li>
</ul>
<h2 id="栗子1-错误打开方式"><a href="#栗子1-错误打开方式" class="headerlink" title="栗子1 错误打开方式"></a>栗子1 错误打开方式</h2><ul>
<li>为人性格,诚实谦虚，勤奋，能吃苦耐劳，有耐心，有团队意识，能和同学和谐相处，能虚心接受别人的建议的人。</li>
<li>责任心强，善于沟通，具有良好的团队合作精神；专业扎实，具有较强的钻研精神和学习能力；性格比较乐观外向，喜欢打羽毛球。</li>
</ul>
<h2 id="栗子2正确打开方式"><a href="#栗子2正确打开方式" class="headerlink" title="栗子2正确打开方式"></a>栗子2正确打开方式</h2><ul>
<li>极客、热爱技术、热爱开源</li>
<li>Ruby on Rails：精通</li>
<li>AWS：掌握</li>
<li>Docker：掌握</li>
<li>Agile/Lean：精通</li>
<li>ReactJS：掌握</li>
</ul>
<h2 id="栗子3正确打开方式"><a href="#栗子3正确打开方式" class="headerlink" title="栗子3正确打开方式"></a>栗子3正确打开方式</h2><ul>
<li><p>我对自己的定位: 主攻前端,同时在其他方面打打辅助。我不希望过于依赖别人,即使没有后端没有设计没有产品经理,我依然想要把这个产品做到完美。毕竟全栈才能最高效地解决问题。</p>
</li>
<li><p>我对工作的态度: 第一,要高效完成自己的本职工作。第二,要在完成的基础上寻找完美。第三,要在完美的基础上,与其他同事 互相交流学习,互相提升。工作是一种生活方式,不是一份养家糊口的差事。</p>
</li>
<li><p>我怎样克服困难: 不用百度是第一原则,在遇到技术问题时我往往会去Google、Stack over flow上寻找答案。但通常很多问题 并不一定已经被人解决,所以熟练地阅读源码、在手册、规范甚至 REPL的环境自己做实验才是最终解决问题的办法。相信事实的结果,自己动手去做。</p>
</li>
<li><p>怎样保持自己的视野:我一直认为软件开发中视野极其重要,除了在 Twitter 上关注业界大牛,Github Trending 也是每周必刷。 另外 Podcast、Hacker News、Reddit 以及TechRadar 也是重要的一手资料。保持开阔视野才能找到更酷的解决方案。</p>
</li>
<li><p>我的优势: 热爱技术、自学能力强,有良好的自我认知。全面的技能树与开阔的视野,良好的心态、情商与沟通能力。</p>
</li>
<li><p>我的劣势: 非科班出身没有科班同学对算法的熟练掌握,但我决定死磕技术,弥补不足。</p>
</li>
</ul>
<h1 id="博客，个人技术栈点等"><a href="#博客，个人技术栈点等" class="headerlink" title="博客，个人技术栈点等"></a>博客，个人技术栈点等</h1><ul>
<li>看到有这项的HR两眼已经放光了，加分加分项，说明你真正的热爱技术，善于学习总结，乐于分享，且有投入自己的业余时间到软件事业中。</li>
<li>我喜欢的书籍:《重构》《卓有成效的程序员》《代码整洁之道》等</li>
<li>我喜欢的社区: 图灵社区，知乎，博客园，Stack Over flow，Google Developer Group等</li>
<li>我的博客链接、个人作品链接如下:<br><a class="link"   href="https://github.com/github" >https://github.com/github<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="http://www.oschina.net/" >http://www.oschina.net/<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.cnblogs.com/" >https://www.cnblogs.com/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h1 id="简历内容真实性"><a href="#简历内容真实性" class="headerlink" title="简历内容真实性"></a>简历内容真实性</h1><p>老司机提醒你，你简历的任意一个细节将会是后面面试中的呈堂证供。因此在技术方面，我们还是要真真实实下功夫的！</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>解决SpringBoot jar包中的文件读取问题</title>
    <url>/p/38722.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringBoot微服务已成为业界主流，从开发到部署都非常省时省力，但是最近小明开发时遇到一个问题：在代码中读取资源文件(比如word文档、导出模版等)，本地开发时可以正常读取 ，但是，当我们打成jar包发布到服务器后，再次执行程序时就会抛出找不到文件的异常。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这个问题是在一次使用freemarker模版引擎导出word报告时发现的。大概说一下docx导出java实现思路：导出word的文档格式为docx，事先准备好一个排好版的docx文档作为模版，读取解析该模版，将其中的静态资源替换再导出。</p>
<blockquote>
<p>docx文档本身其实是一个压缩的zip文件，将其解压过后就会发现它有自己的目录结构。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这个docx文档所在目录如下图所示：<br><img src="https://img.mynamecoder.com/20200824111042.png"><br>在本地调试时，我使用如下方式读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ResourceUtils;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File docxTemplate = ResourceUtils.getFile(<span class="string">&quot;classpath:templates/docxTemplate.docx&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以正常解析使用，但是打包发布到beta环境却不可用。抛出异常如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">java.io.FileNotFoundException: class path resource [templates/docxTemplate.docx] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/usr/local/subject-server.jar!/BOOT-INF/classes!/templates/docxTemplate.docx</span><br></pre></td></tr></table></figure>
<p>显而易见，这个异常告诉我们：<strong>没有找到文件</strong>，但是将jar包解压过后，发现这个文件是真真实实存在的。<br>那这到底是怎么回事呢？这压根难不倒我。我们要善于透过堆栈信息看本质。通过仔细观察堆栈信息，我发现此时的文件路径并不是一个合法的URL(文件资源定位符)。原来jar包中资源有其专门的URL形式： jar:<url>!/{entry} )。所以，此时如果仍然按照标准的文件资源定位形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(<span class="string">&quot;jar:file:……&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>定位文件，就会抛出<strong>java.io.FileNotFoundException</strong>。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>虽然我们不能用常规操作文件的方法来读取jar包中的资源文件<strong>docxTemplate.docx</strong>，但可以通过<strong>Class</strong>类的<strong>getResourceAsStream</strong>()方法，即通过流的方式来获取 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">InputStream inputStream = WordUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;templates/docxTemplate.docx&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>拿到流之后，就可以将其转换为任意一个我们需要的对象，比如<strong>File</strong>、<strong>String</strong>等等，此处我要获取<strong>docxTemplate.docx</strong>下的目录结构，因此我需要一个<strong>File</strong>对象，代码举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = WordUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;templates/docxTemplate.docx&quot;</span>);</span><br><span class="line">        File docxFile = <span class="keyword">new</span> File(<span class="string">&quot;docxTemplate.docx&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用common-io的工具类即可转换</span></span><br><span class="line">        FileUtils.copyToFile(inputStream,docxFile);</span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(docxFile);</span><br><span class="line">        Enumeration&lt;? extends ZipEntry&gt; zipEntrys = zipFile.entries();</span><br><span class="line">        <span class="comment">// todo 记得关闭流</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>打包、发布至beta环境，亲测可用，问题完美解决。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>订单超时取消的解决方案</title>
    <url>/p/268.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol>
<li><p>为什么需要使用延迟队列？适用于什么场景？<br>   场景一：订单下单之后30分钟后，如果用户没有付钱，则系统自动取消订单。<br>   这样类似的需求是我们经常会遇见的问题。最常用的方法是定期轮训数据库，设置状态。在数据量小的时候并没有什么大的问题，但是数据量一大轮训数据库的方式就会变得特别耗资源。当面对千万级、上亿级数据量时，本身写入的IO就比较高，导致长时间查询或者根本就查不出来。通过使用延迟队列来解决这种问题</p>
</li>
<li><p>使用RabbitMQ来实现延迟任务必须先了解RabbitMQ的两个概念：消息的Time To Live(TTL)和Dead Letter Exchanges（DLX），利用两者的组合来实现延迟队列<br>简述一下：A.消息的TTL就是消息的存活时间，B.DLX是死信路由<br>实现原理：先发送一个消息到队列中，设置存活时间，超时后会转发到死信路由中，客户端消费死信路由中的消息，消息中包装好需要转发的队列名，再根据此队列名发送消息，这样间接中转的方式实现了延迟队列。</p>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="新建SpringBoot项目，添加-amqp-引用"><a href="#新建SpringBoot项目，添加-amqp-引用" class="headerlink" title="新建SpringBoot项目，添加 amqp 引用"></a>新建SpringBoot项目，添加 amqp 引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.47&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="在配置文件application-properties中配置好mq的连接地址"><a href="#在配置文件application-properties中配置好mq的连接地址" class="headerlink" title="在配置文件application.properties中配置好mq的连接地址"></a>在配置文件application.properties中配置好mq的连接地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#rabbitmq</span><br><span class="line">spring.rabbitmq.host&#x3D;127.0.0.1   </span><br><span class="line">spring.rabbitmq.port&#x3D;5672  </span><br><span class="line">spring.rabbitmq.username&#x3D;root</span><br><span class="line">spring.rabbitmq.password&#x3D;root</span><br><span class="line">spring.rabbitmq.virtual-host&#x3D;ykh_vhosts</span><br></pre></td></tr></table></figure>
<h4 id="创建配置类，使用配置文件中的连接"><a href="#创建配置类，使用配置文件中的连接" class="headerlink" title="创建配置类，使用配置文件中的连接"></a>创建配置类，使用配置文件中的连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 读取application.properties中的连接配置</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger &#x3D; Logger.getLogger(&quot;RabbitMQConfiguration&quot;);</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.host&#125;&quot;)</span><br><span class="line">    public String host;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.port&#125;&quot;)</span><br><span class="line">    public int port;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.username&#125;&quot;)</span><br><span class="line">    public String username;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.password&#125;&quot;)</span><br><span class="line">    public String password;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rabbitmq.virtual-host&#125;&quot;)</span><br><span class="line">    public String virtualHost;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConnectionFactory connectionFactory() &#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory &#x3D; new CachingConnectionFactory(host, port);</span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connectionFactory.setVirtualHost(virtualHost);</span><br><span class="line">        connectionFactory.setPublisherConfirms(true);</span><br><span class="line">        logger.info(&quot;Create ConnectionFactory bean ..&quot;);</span><br><span class="line">        return connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">    public RabbitTemplate rabbitTemplate() &#123;</span><br><span class="line">        RabbitTemplate template &#x3D; new RabbitTemplate(connectionFactory());</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建一个常量类，定义队列名称"><a href="#创建一个常量类，定义队列名称" class="headerlink" title="创建一个常量类，定义队列名称"></a>创建一个常量类，定义队列名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Rabbit消息队列相关常量</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final class MQConstant &#123;</span><br><span class="line"></span><br><span class="line">    private MQConstant()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;exchange name</span><br><span class="line">    public static final String DEFAULT_EXCHANGE &#x3D; &quot;ZyChange&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;TTL QUEUE</span><br><span class="line">    public static final String DEFAULT_DEAD_LETTER_QUEUE_NAME &#x3D; &quot;zy.dead.letter.queue&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;DLX repeat QUEUE 死信转发队列</span><br><span class="line">    public static final String DEFAULT_REPEAT_TRADE_QUEUE_NAME &#x3D; &quot;zy.repeat.trade.queue&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Hello 测试消息队列名称</span><br><span class="line">    public static final String HELLO_QUEUE_NAME &#x3D; &quot;HELLO&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建一个队列配置类，作用是信道配置，队列配置，队列绑定"><a href="#创建一个队列配置类，作用是信道配置，队列配置，队列绑定" class="headerlink" title="创建一个队列配置类，作用是信道配置，队列配置，队列绑定"></a>创建一个队列配置类，作用是信道配置，队列配置，队列绑定</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 队列配置，所有配置@Bean的队列名称，由系统启动时创建队列，并绑定到Exchane上</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class QueueConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;信道配置</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange defaultExchange() &#123;</span><br><span class="line">        return new DirectExchange(MQConstant.DEFAULT_EXCHANGE, true, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*********************    业务队列定义与绑定 hello 测试    *****************&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queue() &#123;</span><br><span class="line">        Queue queue &#x3D; new Queue(MQConstant.HELLO_QUEUE_NAME,true);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Binding binding() &#123;</span><br><span class="line">        &#x2F;&#x2F;队列绑定到exchange上，再绑定好路由键</span><br><span class="line">        return BindingBuilder.bind(queue()).to(defaultExchange()).with(MQConstant.HELLO_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*********************    业务队列定义与绑定 hello 测试    *****************&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;下面是延迟队列的配置</span><br><span class="line">    &#x2F;&#x2F;转发队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue repeatTradeQueue() &#123;</span><br><span class="line">        Queue queue &#x3D; new Queue(MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME,true,false,false);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;绑定转发队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding  drepeatTradeBinding() &#123;</span><br><span class="line">        return BindingBuilder.bind(repeatTradeQueue()).to(defaultExchange()).with(MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;死信队列  -- 消息在死信队列上堆积，消息超时时，会把消息转发到转发队列，转发队列根据消息内容再把转发到指定的队列上</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue deadLetterQueue() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(&quot;x-dead-letter-exchange&quot;, MQConstant.DEFAULT_EXCHANGE);</span><br><span class="line">        arguments.put(&quot;x-dead-letter-routing-key&quot;, MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME);</span><br><span class="line">        Queue queue &#x3D; new Queue(MQConstant.DEFAULT_DEAD_LETTER_QUEUE_NAME,true,false,false,arguments);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;绑定死信队列</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding  deadLetterBinding() &#123;</span><br><span class="line">        return BindingBuilder.bind(deadLetterQueue()).to(defaultExchange()).with(MQConstant.DEFAULT_DEAD_LETTER_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建消息生成接口和实现"><a href="#创建消息生成接口和实现" class="headerlink" title="创建消息生成接口和实现"></a>创建消息生成接口和实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IMessageService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void send(String queueName,String message);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 延迟发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     * @param times 延迟时间 单位毫秒</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void send(String queueName,String message,long times);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 消息队列服务接口实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service(&quot;messageService&quot;)</span><br><span class="line">public class MessageService implements IMessageService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void send(String queueName, String message) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(MQConstant.DEFAULT_EXCHANGE,queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 延迟发送消息到队列</span><br><span class="line">     * @param queueName 队列名称</span><br><span class="line">     * @param message 消息内容</span><br><span class="line">     * @param times 延迟时间 单位毫秒</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void send(String queueName, String message, long times) &#123;</span><br><span class="line">        &#x2F;&#x2F;消息发送到死信队列上，当消息超时时，会发生到转发队列上，转发队列根据下面封装的queueName，把消息转发的指定队列上</span><br><span class="line">        &#x2F;&#x2F;发送前，把消息进行封装，转发时应转发到指定 queueName 队列上</span><br><span class="line">        DLXMessage dlxMessage &#x3D; new DLXMessage(MQConstant.DEFAULT_EXCHANGE,queueName,message,times);</span><br><span class="line">        MessagePostProcessor processor &#x3D; new MessagePostProcessor()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">                message.getMessageProperties().setExpiration(times + &quot;&quot;);</span><br><span class="line">                return message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        rabbitTemplate.convertAndSend(MQConstant.DEFAULT_EXCHANGE,MQConstant.DEFAULT_DEAD_LETTER_QUEUE_NAME, JSON.toJSONString(dlxMessage), processor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="死信消息载体"><a href="#死信消息载体" class="headerlink" title="死信消息载体"></a>死信消息载体</h4><p>DLXMessage是一个消息封装对象，很关键，发送延迟队列时，先把消息存在此对象中，在加上目的地队列名称，然后再发到死信队列中，当消息超时时，转发到转发队列，添加对转发队列的监听，消费转发队列，获取需要延迟发送的信息，该信息就是DLXMessage对象，这样就拿到了目的地队列名称，然后再发送一次消息，就完成了延迟队列的发送。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * rabbit 死信消息载体</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DLXMessage implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 9956432152000L;</span><br><span class="line">    private String exchange;</span><br><span class="line">    private String queueName;</span><br><span class="line">    private String content;</span><br><span class="line">    private long times;</span><br><span class="line"></span><br><span class="line">    public DLXMessage() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DLXMessage(String queueName, String content, long times) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.queueName &#x3D; queueName;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">        this.times &#x3D; times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DLXMessage(String exchange, String queueName, String content, long times) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.exchange &#x3D; exchange;</span><br><span class="line">        this.queueName &#x3D; queueName;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">        this.times &#x3D; times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static long getSerialVersionUID() &#123;</span><br><span class="line">        return serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getExchange() &#123;</span><br><span class="line">        return exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExchange(String exchange) &#123;</span><br><span class="line">        this.exchange &#x3D; exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getQueueName() &#123;</span><br><span class="line">        return queueName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQueueName(String queueName) &#123;</span><br><span class="line">        this.queueName &#x3D; queueName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getTimes() &#123;</span><br><span class="line">        return times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTimes(long times) &#123;</span><br><span class="line">        this.times &#x3D; times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加消息消费者监听，当有消息时进行消费"><a href="#添加消息消费者监听，当有消息时进行消费" class="headerlink" title="添加消息消费者监听，当有消息时进行消费"></a>添加消息消费者监听，当有消息时进行消费</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;监听hello队列，有消息时进行消费</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues &#x3D; MQConstant.HELLO_QUEUE_NAME)</span><br><span class="line">public class ReceiverMessage &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String content) &#123;</span><br><span class="line">        System.out.println(&quot;接受时间:&quot;+ System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;接受消息:&quot; + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听转发队列，有消息时，把消息转发到目标队列</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues &#x3D; MQConstant.DEFAULT_REPEAT_TRADE_QUEUE_NAME)</span><br><span class="line">public class ReceiverDelayMessage &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IMessageService messageService;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String content) &#123;</span><br><span class="line">        &#x2F;&#x2F;此时，才把消息发送到指定队列，而实现延迟功能</span><br><span class="line">        DLXMessage message &#x3D; JSON.parseObject(content, DLXMessage.class);</span><br><span class="line">        messageService.send(message.getQueueName(), message.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试-启动项目，会执行发送消息代码"><a href="#测试-启动项目，会执行发送消息代码" class="headerlink" title="测试,启动项目，会执行发送消息代码"></a>测试,启动项目，会执行发送消息代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 启动启动时执行</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class SysInitLoad implements ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private IMessageService messageService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;发送时间:&quot;+ System.currentTimeMillis());</span><br><span class="line">        String message &#x3D; &quot;测试延迟消息&quot;;</span><br><span class="line">        messageService.send(MQConstant.HELLO_QUEUE_NAME,message,6000);</span><br><span class="line"></span><br><span class="line">        message &#x3D; &quot;测试普通消息&quot;;</span><br><span class="line">        messageService.send(MQConstant.HELLO_QUEUE_NAME,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通消息马上就接收到了，延迟消息6s后收到。</p>
<p>以上就是订单超时未处理的解决方案，希望能够给予大家帮助。</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>通过shell脚本一键安装python3</title>
    <url>/p/62773.html</url>
    <content><![CDATA[<blockquote>
<p> 本文主要介绍python3的安装，通过python3.6.4源码安装，并且兼容python2， 实现python2与python3共存。文中包括python3的安装介绍以及安装脚本。</p>
</blockquote>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>因为红帽系列默认没有安装python3，而debian早就已经自带了python3。在centos服务器上安装python3，因此写了一个一键安装脚本供大家参考。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>一键安装python3脚本，脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y wget epel-release xz gcc zlib zlib-devel openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel</span><br><span class="line">if [[ ! -s /usr/bin/python3 ]]; then</span><br><span class="line">        wget http://file.aionlife.xyz/source/download?id=5b9e7227dc72d90ebb47023a -O Python-3.6.4.tar.xz  #https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz(这个地址国内下载比较慢，所以这里换成另一个地址 )</span><br><span class="line">        tar -Jxvf Python-3.6.4.tar.xz</span><br><span class="line">        cd Python-3.6.4</span><br><span class="line">        ./configure --prefix=/usr/python3.6</span><br><span class="line">        make&amp;&amp;make install</span><br><span class="line">        ln -s /usr/python3.6/bin/python3 /usr/bin/python3</span><br><span class="line">        mkdir ~/.pip</span><br><span class="line">        echo -e &quot;[global]\nindex-url = http://mirrors.aliyun.com/pypi/simple/\n[install]\ntrusted-host = mirrors.aliyun.com&quot; &gt; ~/.pip/pip.conf</span><br><span class="line">        ln -s /usr/python3.6/bin/pip3 /usr/bin/pip3  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p> tips: 也可以根据所安装的版本更换安装包的下载链接，注意脚本中的文件名也要同步修改。</p>
</blockquote>
<p>上面脚本可以用<code>vi</code>保存脚本文件<code>installpy3.sh</code>，然后执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh installpy3.sh</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>经过大约几分钟的等待，脚本执行安装完毕，我们就可以分别执行<code>python3</code>和<code>pip3</code>进行验证，如出现命令提示即表示安装成功。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次因使用Date引起的线上BUG处理</title>
    <url>/p/6653.html</url>
    <content><![CDATA[<blockquote>
<p>生活中，我们需要掌控自己的时间，减少加班，提高效率；日常开发中，我们需要操作时间API，保证效率、安全、稳定。现在都2020年了，了解如何在JDK8及以后的版本中更好地操控时间就很有必要，尤其是一次线上BUG的发生，让小明更是深有体会。</p>
</blockquote>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在<strong>Java8</strong>以前，每每操控时间，我们经常使用的类库就是<strong>Date</strong>，并且会通过<strong>SimpleDateFormat</strong>类对时间进行格式化。你可知道？<strong>Date</strong>类是一个可变类，<strong>SimpleDateFormat</strong>类也是线程不安全的，因此在多线程的场景下执行格式化操作时，就会发生意想不到的情况。下面我们看一下使用<strong>Date</strong>、<strong>SimpleDateFormat</strong>在多线程下可能发生的问题以及使用<strong>LocalDateTime</strong>、<strong>DateTimeFormatter</strong>的方法和优势。</p>
<h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><p>多线程环境下，使用<strong>Date</strong>、<strong>SimpleDateFormat</strong>时，如果我们将它定义为一个静态变量使用，虽然会避免重复创建实例， 但是会出现个别线程获取时间失败的现象，我们通过代码模拟这个场景：</p>
<p><img src="https://img.mynamecoder.com/java7time.jpeg"></p>
<p>运行<strong>main</strong>方法，查看控制台会发现有个别线程会报<strong>java.lang.NumberFormatException</strong>异常。类似下图所示:</p>
<p><img src="https://img.mynamecoder.com/20200420005215.png"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>接下来，我们通过查看源码进一步分析（多图预警），可以看到<strong>SimpleDateFormat</strong>是直接继承的<strong>DateFormat</strong>类：</p>
<p><img src="https://img.mynamecoder.com/20200420011327.png">并重写了**parse()**（字符串转日期）和 **format()**（日期转字符串）方法，因此我们重点从这两个方法来分析。</p>
<p>首先是<strong>SimpleDateFormat</strong>的<strong>parse()**方法，该方法中创建了一个</strong>CalendarBuilder**对象，</p>
<p><img src="https://img.mynamecoder.com/20200420011757.png"></p>
<p>再往下看，会看到<strong>CalendarBuilder</strong>使用<strong>establish</strong>方法将变量<strong>calendar</strong>设值到其属性中，</p>
<p>![image-20200420012213545](/Users/xin/Library/Application Support/typora-user-images/image-20200420012213545.png) </p>
<p>而<strong>calendar</strong>是父类<strong>DateFormat</strong>类的共享变量，可以被多个线程访问到</p>
<p><img src="https://img.mynamecoder.com/20200420010713.png"></p>
<p>因此当<strong>SimpleDateFormat</strong>声明为<strong>static</strong>时，线程并不安全，多个线程同时操作访问就会抛出异常。</p>
<p>同样地通过查看<strong>format()**，我们发现</strong>format<strong>方法中有一行<code>calendar.setTime(date)</code>;也是操作的该共享变量</strong>calendar**，线程也是不安全的。</p>
<p><img src="https://img.mynamecoder.com/20200420013251.png"></p>
<p>有趣的是，在<strong>DateFormat</strong>源码注释上作者也已经给出醒目的提示:</p>
<p><img src="https://img.mynamecoder.com/20200420013620.png"></p>
<p>使用Google翻译过来就是</p>
<blockquote>
<p>日期格式不同步。 建议为每个线程创建单独的格式实例。 如果多个线程同时访问一种格式，则必须在外部同步该格式。</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>小明有一句座右铭，方法总比问题多。我们来看几个小明认为不错的解决方案。</p>
<h5 id="1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。"><a href="#1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。" class="headerlink" title="1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。"></a>1、仅在需要用到的地方创建一个新的实例，就没有线程安全问题。</h5><p><strong>点评</strong>：加重了创建对象的负担，频繁地创建和销毁对象，消耗资源，效率较低。</p>
<h5 id="2、通过synchronized解决线程安全问题；"><a href="#2、通过synchronized解决线程安全问题；" class="headerlink" title="2、通过synchronized解决线程安全问题；"></a>2、通过<strong>synchronized</strong>解决线程安全问题；</h5><p><strong>点评</strong>：并发量大的时候会对性能有影响，容易造成线程阻塞。</p>
<h5 id="3、通过ThreadLocal保证线程之间变量不共享"><a href="#3、通过ThreadLocal保证线程之间变量不共享" class="headerlink" title="3、通过ThreadLocal保证线程之间变量不共享"></a>3、通过ThreadLocal保证线程之间变量不共享</h5><p><strong>点评：</strong>ThreadLocal可以确保每个线程都可以得到单独的一个<strong>SimpleDateFormat</strong>的对象，那么自然也就不存在竞争问题了。就是有点大材小用。</p>
<p><img src="https://img.mynamecoder.com/20200420014512.png"></p>
<p>以上就是小明能够提供的所有方案。什么，都不满意？我们来看一下2020年JDK8的解决方案。</p>
<h2 id="使用LocalDateTime"><a href="#使用LocalDateTime" class="headerlink" title="使用LocalDateTime"></a>使用<strong>LocalDateTime</strong></h2><p>在<strong>Java8</strong>以后，我们有了新的选择，使用<strong>LocalDateTime</strong>时间类。首先，<strong>LocalDateTime</strong>本身是线程安全的，其对应的格式化工具类<strong>DateTimeFormatter</strong>也是线程安全的，不存在变量共享，每一个属性字段都用了final关键字修饰，因此每次操作后都是返回的copy对象。并且<strong>LocalDateTime</strong>类本身也有很多操作时间的API来替代传统的<strong>Calendar</strong>类。</p>
<p>基于<strong>Java8</strong>的<strong>DateTimeFormatter</strong>的解决方案，我们对之前的代码进行改造，多线程环境下，运行代码，并未发现任何异常，稳定高效:</p>
<p><img src="https://img.mynamecoder.com/20200420015556.png"></p>
<p>我们可以看到<strong>在DateTimeFormatter</strong>源码上作者也贴心的加注释说明，该类是不可变的，并且是线程安全的。</p>
<p><img src="https://img.mynamecoder.com/20200420015208.png"></p>
<p>同理，这点我们也可以从<strong>LocalDateTime</strong>的官方源码中看出。</p>
<h2 id="其他骚操作"><a href="#其他骚操作" class="headerlink" title="其他骚操作"></a>其他骚操作</h2><p>为了让大家忘掉之前使用<strong>Calendar</strong>操作时间的笨拙，我们来切实感受一下<strong>LocalDateTime</strong>给实际开发中带来的便利: </p>
<p><img src="https://img.mynamecoder.com/20200420021510.png"></p>
<blockquote>
<p>更多举例说明，请点击文末阅读原文</p>
<p>代码地址：<a class="link"   href="https://github.com/WhenCoding/coder-xiaoming" >https://github.com/WhenCoding/coder-xiaoming<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，小明推荐小伙伴们使用JDK8的<strong>LocalDateTime</strong>系列来取代<strong>Date</strong>系列，这样做不仅能够保证线上项目平稳运行，而且通过其自带的API还能操作时间，还能提高开发效率，今晚可以不加班！</p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云企业云邮箱收发设置</title>
    <url>/p/17df.html</url>
    <content><![CDATA[<blockquote>
<p>小明最近在自己的mac上面登录公司的企业邮箱（运营一套用的都是阿里云），找到了阿里云邮箱的收件和发件邮箱地址设置方法，给大家节省一下时间。</p>
</blockquote>
<h1 id="企业云邮箱POP-SMTP-IMAP地址和端口信息"><a href="#企业云邮箱POP-SMTP-IMAP地址和端口信息" class="headerlink" title="企业云邮箱POP\SMTP\IMAP地址和端口信息"></a>企业云邮箱POP\SMTP\IMAP地址和端口信息</h1><h2 id="收件服务器地址"><a href="#收件服务器地址" class="headerlink" title="收件服务器地址"></a>收件服务器地址</h2><p>发件协议两个协议可供选择</p>
<ul>
<li>POP 服务器地址：pop3.mxhichina.com(或者pop3.公司域名，举例:pop3.coderxm.com) 端口110，如果采用SSL加密，则端口改为加密端口995</li>
</ul>
<p>或者</p>
<ul>
<li>IMAP 服务器地址：imap.mxhichina.com(或者pop3.公司域名，举例:pop3.coderxm.com) 端口143，如果采用SSL加密，则端口改为加密端口993</li>
</ul>
<h2 id="发件服务器地址"><a href="#发件服务器地址" class="headerlink" title="发件服务器地址"></a>发件服务器地址</h2><ul>
<li>SMTP 服务器地址：smtp.mxhichina.com 端口25，如果采用SSL加密，则端口改为加密端口465</li>
</ul>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>日常开发</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装Homebrew并配置Redis</title>
    <url>/p/707c.html</url>
    <content><![CDATA[<h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><p>如果已经安装可以忽略，没有安装的请查看小明之前写好的文章 <a href="/p/75a0.html" title="Mac安装Homebrew的那些事儿">Mac安装Homebrew的那些事儿</a></p>
<h2 id="使用Homebrew安装Redis"><a href="#使用Homebrew安装Redis" class="headerlink" title="使用Homebrew安装Redis"></a>使用Homebrew安装Redis</h2><h5 id="1-安装命令"><a href="#1-安装命令" class="headerlink" title="(1) 安装命令"></a>(1) 安装命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>
<h5 id="2-查看软件安装及配置文件位置"><a href="#2-查看软件安装及配置文件位置" class="headerlink" title="(2) 查看软件安装及配置文件位置"></a>(2) 查看软件安装及配置文件位置</h5><p>Homebrew安装的软件会默认在<code>/usr/local/Cellar/</code>路径下；</p>
<p>redis的配置文件<code>redis.conf</code>存放在<code>/usr/local/etc</code>路径下。</p>
<h5 id="3-启动redis服务"><a href="#3-启动redis服务" class="headerlink" title="(3) 启动redis服务"></a>(3) 启动redis服务</h5><h6 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h6><p>brew除了可以帮助我们安装软件以外，还可以帮助我们启动软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start redis</span><br></pre></td></tr></table></figure>
<h6 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<h5 id="4-查看redis服务进程"><a href="#4-查看redis服务进程" class="headerlink" title="(4) 查看redis服务进程"></a>(4) 查看redis服务进程</h5><p>我们可以通过下面命令查看redis是否正在运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps axu | grep redis</span><br></pre></td></tr></table></figure>
<h5 id="5-redis-cli连接redis服务"><a href="#5-redis-cli连接redis服务" class="headerlink" title="(5) redis-cli连接redis服务"></a>(5) redis-cli连接redis服务</h5><p>redis默认端口号<strong>6379</strong>，默认<strong>auth</strong>为空，输入以下命令即可连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>
<h5 id="6-关闭redis服务"><a href="#6-关闭redis服务" class="headerlink" title="(6) 关闭redis服务"></a>(6) 关闭redis服务</h5><p>优雅的关闭<code>redis-cli shutdown</code>或者杀死<code>sudo pkill redis-server</code></p>
<h5 id="7-redis-conf配置文件说明"><a href="#7-redis-conf配置文件说明" class="headerlink" title="(7) redis.conf配置文件说明"></a>(7) redis.conf配置文件说明</h5><p>redis默认是前台启动，如果我们想以守护进程的方式运行（后台运行），可以在<strong>redis.conf</strong>中将<code>daemonize no</code>,修改成<code>yes</code>即可。</p>
]]></content>
  </entry>
  <entry>
    <title>ThreadLocal解决了什么问题？</title>
    <url>/p/b5c2.html</url>
    <content><![CDATA[<blockquote>
<p>小明所在的项目组（迭代组：一直在迭代的路上），经常会在已有接口的基础上开发一些小功能，并且前提是在保证现有用户的不受影响基础上迭代。功能迭代，在代码层面小明有1w种实现方法（吹牛的），一起来看看这次小明如何使用<strong>ThreadLocal</strong>优雅地完成本次迭代吧！</p>
</blockquote>
<p>由于 ThreadLocal 支持范型，如 ThreadLocal&lt; StringBuilder &gt;，为表述方便，后文用 <strong>变量</strong> 代表 ThreadLocal 本身，而用 <strong>实例</strong> 代表具体类型（如 StringBuidler ）的实例。</p>
<a id="more"></a>
<h2 id="理解误区"><a href="#理解误区" class="headerlink" title="理解误区"></a>理解误区</h2><p>写这篇文章之前，小明就在网上看了很多博客关于 ThreadLocal 的适用场景以及解决的问题，描述的都并不是很清楚，甚至误人子弟的。比如下面是常见对于 ThreadLocal的介绍（<strong>wrong</strong>）</p>
<blockquote>
<p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路；<br>ThreadLocal的目的是为了解决多线程访问资源时的共享问题。</p>
</blockquote>
<p>在小明大量阅读和动手实验后得出结论：ThreadLocal 并不是像上面所说为了解决多线程 <strong>共享</strong>变量的问题。</p>
<h2 id="正确理解"><a href="#正确理解" class="headerlink" title="正确理解"></a>正确理解</h2><p>ThreadLoal 变量，它的基本原理是，同一个 ThreadLocal 所包含的对象（对ThreadLocal&lt; StringBuilder &gt;而言即为 StringBuilder 类型变量），在不同的 Thread 中有不同的副本（实际上是不同的实例）:</p>
<ul>
<li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用；</li>
<li>既然其它 Thread 不可访问，那就不存在多线程间共享的问题。</li>
</ul>
<p>官方文档是这样描述的：</p>
<p><img src="https://img.mynamecoder.com/blogimage_20191213135422.png" alt="localthreadofjdk"></p>
<p>我看完之后，得出这样的结论</p>
<blockquote>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都会被回收。</p>
</blockquote>
<p>因此<strong>ThreadLocal 非常适用于这样的场景：每个线程需要自己独立的实例且该实例需要在多个方法中使用</strong>。当然，使用其它方式也可以实现同样的效果，但是看完这篇文章，你会发现 ThreadLocal 会让实现更简洁、更优雅！</p>
<h1 id="ThreadLocal用法"><a href="#ThreadLocal用法" class="headerlink" title="ThreadLocal用法"></a>ThreadLocal用法</h1><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p>我们通过下面的代码，先做个示例，然后分析一下现象，得出一个结论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int threadNum &#x3D; 3;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(threadNum);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; threadNum; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt;&#x3D; 2; j++) &#123;</span><br><span class="line">                    MyUtil.add(String.valueOf(j));</span><br><span class="line">                    MyUtil.print();</span><br><span class="line">                &#125;</span><br><span class="line">                MyUtil.set(&quot;hello world&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, &quot;thread - &quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class MyUtil &#123;</span><br><span class="line"></span><br><span class="line">        public static void add(String newStr) &#123;</span><br><span class="line">            StringBuilder str &#x3D; StringBuilderUtil.stringBuilderThreadLocal.get();</span><br><span class="line">            StringBuilderUtil.stringBuilderThreadLocal.set(str.append(newStr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void print() &#123;</span><br><span class="line">            System.out.printf(&quot;Thread name:%s , ThreadLocal hashcode:%s, Instance hashcode:%s, Value:%s\n&quot;,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void set(String words) &#123;</span><br><span class="line">            StringBuilderUtil.stringBuilderThreadLocal.set(new StringBuilder(words));</span><br><span class="line">            System.out.printf(&quot;Set, Thread name:%s , ThreadLocal hashcode:%s,  Instance hashcode:%s, Value:%s\n&quot;,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().hashCode(),</span><br><span class="line">                    StringBuilderUtil.stringBuilderThreadLocal.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class StringBuilderUtil &#123;</span><br><span class="line">        &#x2F;&#x2F; ThreadLocal 变量通常被 private static 修饰</span><br><span class="line">        private static ThreadLocal&lt;StringBuilder&gt; stringBuilderThreadLocal &#x3D; ThreadLocal.withInitial(() -&gt; new StringBuilder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>ThreadLocal本身支持范型，比如该例使用了 StringBuilder 类型的 ThreadLocal 变量。可通过 ThreadLocal 的 get() 方法读取 StringBuidler 实例，也可通过 set(T t) 方法设置 StringBuilder。</p>
<blockquote>
<p>tips:CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个场景：任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。下次，我们可以单独聊聊这一个功能。</p>
</blockquote>
<p>点击运行，控制台输出结果</p>
<p><img src="https://img.mynamecoder.com/blogimage_20191213102939.png" alt="123"></p>
<p>我们可以发现：</p>
<ul>
<li>每个线程访问的是同一个 ThreadLocal 变量，而通过 ThreadLocal 的 get() 方法拿到的是不同的 StringBuilder 实例；</li>
<li>虽然从代码上都是对 StringBuilderUtil 类的静态 stringBuilderThreadLocal 字段进行 get() 得到 StringBuilder 实例并追加字符串，但是这并不会将所有线程追加的字符串都放进同一个 StringBuilder 中，而是每个线程将字符串追加进各自的 StringBuidler 实例内</li>
<li>使用 set(T t) 方法后，ThreadLocal 变量所指向的 StringBuilder 实例被替换</li>
</ul>
<h1 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>我们大胆猜想一下，既然每个访问 ThreadLocal 变量的线程都有自己的一个“本地”实例副本。一个可能的方案是 ThreadLocal 维护一个 Map，Key 是当前线程，Value是ThreadLocal在当前线程内的实例。这样，线程通过该 ThreadLocal 的 get() 方案获取实例时，只需要以线程为键，从 Map 中找出对应的实例即可。该方案如下图所示</p>
<p><img src="https://img.mynamecoder.com/blogVarMap_20191213134650.png" alt="VarMap"></p>
<p>这个方案可以满足上文提到的每个线程内部都有一个ThreadLocal 实例备份的要求。每个新线程访问该 ThreadLocal 时，都会向 Map 中添加一个新的映射，而当每个线程结束时再清除该线程对应的映射。But，这样就存在两个问题：</p>
<ul>
<li>开启线程与结束线程时我们都需要及时更新 Map，因此必需保证 Map 的线程安全。</li>
<li>当线程结束时，需要保证它所访问的所有 ThreadLocal 中对应的映射均删除，否则可能会引起内存泄漏。</li>
</ul>
<p>线程安全问题是JDK 未采用该方案的一个主要原因。</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>上面这个方案，存在多线程访问同一个 Map时可能会出现的同步问题。如果该 Map 由 Thread 维护，从而使得每个 Thread 只访问自己的 Map，就不存在这个问题。该方案如下图所示。</p>
<p><img src="https://img.mynamecoder.com/blogThreadMap_20191213134650.png" alt="ThreadMap"></p>
<p>该方案虽然没有锁的问题，但是由于每个线程在访问ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLocal 变量与具体实例的映射，如果不删除这些引用（映射），就有可能会造成内存泄漏的问题。我们一起来看一下Jdk8是如何解决这个问题的。</p>
<h2 id="ThreadLocal-在-JDK-8-中的实现"><a href="#ThreadLocal-在-JDK-8-中的实现" class="headerlink" title="ThreadLocal 在 JDK 8 中的实现"></a>ThreadLocal 在 JDK 8 中的实现</h2><h3 id="ThreadLocalMap与内存泄漏"><a href="#ThreadLocalMap与内存泄漏" class="headerlink" title="ThreadLocalMap与内存泄漏"></a>ThreadLocalMap与内存泄漏</h3><p>在该方案中，Map 由 ThreadLocal 类的静态内部类 ThreadLocalMap 提供。该类的实例维护某个 ThreadLocal 与具体实例的映射。与 HashMap 不同的是，ThreadLocalMap 的每个 <strong>Entry</strong> 都是一个对 <strong>Key</strong> 的弱引用，这一点我们可以从<code>super(k)</code>可看出。另外，每个 Entry 中都包含了一个对 <strong>Value</strong> 的强引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">  &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">  Object value;</span><br><span class="line"></span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    super(k);</span><br><span class="line">    value &#x3D; v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>之所以使用弱引用，是因为当没有强引用指向 ThreadLocal 变量时，这个变量就可以被回收，就避免ThreadLocal 因为不能被回收而造成的内存泄漏的问题。</p>
<p>但是，这里又可能出现另外一种内存泄漏的问题。ThreadLocalMap 维护 ThreadLocal 变量与具体实例的映射，当 ThreadLocal 变量被回收后，该映射的键变为 null，该 Entry 无法被移除。从而使得实例被该 Entry 引用而无法被回收造成内存泄漏。</p>
<p><strong>注意：</strong>Entry是对 ThreadLocal 类型的弱引用，并不是具体实例的弱引用，因此还存在具体实例相关的内存泄漏的问题。</p>
<h3 id="读取实例"><a href="#读取实例" class="headerlink" title="读取实例"></a>读取实例</h3><p>我们来看一下ThreadLocal获取实例的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">  Thread t &#x3D; Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">  if (map !&#x3D; null) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">    if (e !&#x3D; null) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      T result &#x3D; (T)e.value;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程获取实例时，首先会通过<code>getMap(t)</code>方法获取自身的 ThreadLocalMap。从如下该方法的定义可见，该 ThreadLocalMap 的实例是 Thread 类的一个字段，即由 Thread 维护 ThreadLocal 对象与具体实例的映射，这一点与上文分析一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">  return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到 ThreadLocalMap 后，通过<code>map.getEntry(this)</code>方法获取该 ThreadLocal 在当前线程的 ThreadLocalMap 中对应的 Entry。该方法中的 this 即当前访问的 ThreadLocal 对象。</p>
<p>如果获取到的 Entry 不为 null，从 Entry 中取出值即为所需访问的本线程对应的实例。如果获取到的 Entry 为 null，则通过<code>setInitialValue()</code>方法设置该 ThreadLocal 变量在该线程中对应的具体实例的初始值。</p>
<h3 id="设置初始值"><a href="#设置初始值" class="headerlink" title="设置初始值"></a>设置初始值</h3><p>设置初始值方法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">  T value &#x3D; initialValue();</span><br><span class="line">  Thread t &#x3D; Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">  if (map !&#x3D; null)</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  else</span><br><span class="line">    createMap(t, value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>该方法为 private 方法，无法被重载。</p>
<p>首先，通过<code>initialValue()</code>方法获取初始值。该方法为 public 方法，且默认返回 null。所以典型用法中常常重载该方法。上例中即在内部匿名类中将其重载。</p>
<p>然后拿到该线程对应的 ThreadLocalMap 对象，若该对象不为 null，则直接将该 ThreadLocal 对象与对应实例初始值的映射添加进该线程的 ThreadLocalMap中。若为 null，则先创建该 ThreadLocalMap 对象再将映射添加其中。</p>
<p>这里并不需要考虑 ThreadLocalMap 的线程安全问题。因为每个线程有且只有一个 ThreadLocalMap 对象，并且只有该线程自己可以访问它，其它线程不会访问该 ThreadLocalMap，也即该对象不会在多个线程中共享，也就不存在线程安全的问题。</p>
<h3 id="设置实例"><a href="#设置实例" class="headerlink" title="设置实例"></a>设置实例</h3><p>除了通过<code>initialValue()</code>方法设置实例的初始值，还可通过 set 方法设置线程内实例的值，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">  Thread t &#x3D; Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">  if (map !&#x3D; null)</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  else</span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法先获取该线程的 ThreadLocalMap 对象，然后直接将 ThreadLocal 对象（即代码中的 this）与目标实例的映射添加进 ThreadLocalMap 中。当然，如果映射已经存在，就直接覆盖。另外，如果获取到的 ThreadLocalMap 为 null，则先创建该 ThreadLocalMap 对象。</p>
<h3 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h3><p>对于已经不再被使用且已被回收的 ThreadLocal 对象，它在每个线程内对应的实例由于被线程的 ThreadLocalMap 的 Entry 强引用，无法被回收，可能会造成内存泄漏。</p>
<p>针对该问题，ThreadLocalMap 的 set 方法中，通过 replaceStaleEntry 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 rehash 方法中通过 expungeStaleEntry 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">  Entry[] tab &#x3D; table;</span><br><span class="line">  int len &#x3D; tab.length;</span><br><span class="line">  int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">  for (Entry e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">    if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">      e.value &#x3D; value;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">      replaceStaleEntry(key, value, i);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">  int sz &#x3D; ++size;</span><br><span class="line">  if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>对于 Java Web 应用而言，Session 保存了很多信息。很多时候需要通过 Session 获取信息，有些时候又需要修改 Session 的信息。一方面，需要保证每个线程有自己单独的 Session 实例。另一方面，由于很多地方都需要操作 Session，存在多方法共享 Session 的需求。如果不使用 ThreadLocal，可以在每个线程内构建一个 Session实例，并将该实例在多个方法间传递，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SessionHandler &#123;</span><br><span class="line"></span><br><span class="line">  @Data</span><br><span class="line">  public static class Session &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String user;</span><br><span class="line">    private String status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Session createSession() &#123;</span><br><span class="line">    return new Session();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getUser(Session session) &#123;</span><br><span class="line">    return session.getUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getStatus(Session session) &#123;</span><br><span class="line">    return session.getStatus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setStatus(Session session, String status) &#123;</span><br><span class="line">    session.setStatus(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      SessionHandler handler &#x3D; new SessionHandler();</span><br><span class="line">      Session session &#x3D; handler.createSession();</span><br><span class="line">      handler.getStatus(session);</span><br><span class="line">      handler.getUser(session);</span><br><span class="line">      handler.setStatus(session, &quot;close&quot;);</span><br><span class="line">      handler.getStatus(session);</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是可以实现需求的。但是每个需要使用 Session 的地方，都需要显式传递 Session 对象，方法间耦合度较高，给人的感觉并不优雅。</p>
<p>这里使用 ThreadLocal 重新实现该功能如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SessionHandler &#123;</span><br><span class="line"></span><br><span class="line">  public static ThreadLocal&lt;Session&gt; session &#x3D; ThreadLocal.&lt;Session&gt;withInitial(() -&gt; new Session());</span><br><span class="line"></span><br><span class="line">  @Data</span><br><span class="line">  public static class Session &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String user;</span><br><span class="line">    private String status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getUser() &#123;</span><br><span class="line">    return session.get().getUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getStatus() &#123;</span><br><span class="line">    return session.get().getStatus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setStatus(String status) &#123;</span><br><span class="line">    session.get().setStatus(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      SessionHandler handler &#x3D; new SessionHandler();</span><br><span class="line">      handler.getStatus();</span><br><span class="line">      handler.getUser();</span><br><span class="line">      handler.setStatus(&quot;close&quot;);</span><br><span class="line">      handler.getStatus();</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，改造过后的代码，不再需要在各个方法间来回传递 Session 对象，并且不费吹灰之力保证了每个线程都能够拥有自己独立的实例。虽然单看其中某一点，备选方案还很多。比如还可以通过在线程内创建局部变量保证每个线程有自己的实例，通过静态变量可实现变量在方法间的共享。但如果还需要同时满足变量在线程间的隔离与方法间的共享，ThreadLocal再合适不过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>ThreadLocal 并不解决线程间共享数据的问题</li>
<li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li>
<li>每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li>
<li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题</li>
<li>ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏</li>
<li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li>
</ul>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+git搭建自己的博客</title>
    <url>/p/2969.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>喜欢写 Blog 的人，会经历三个阶段。</p>
<p>第一阶段，刚接触 Blog，觉得很新鲜，试着选择一个免费空间来写。<br>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。<br>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p>
</blockquote>
<p>这是阮一峰在博客中写到的关于 Blog 的想法，而这里的第三阶段的实现就是利用 GitHub Pages 搭建博客。</p>
<p>使用 GitHub Pages 功能搭建博客的好处有：</p>
<ul>
<li>免费，GitHub 提供无限流量。</li>
<li>都是静态文件，世界各地都有理想的访问速度。(访问速度可以进一步优化)</li>
<li>拥有绝对的管理权，又享受 Git 的版本管理功能，不用担心文章遗失。</li>
</ul>
<p>Hexo 是基于 Node.js 的一款静态博客框架，如果想要搭建博客，不想自己写页面的话可以考虑用 Hexo，其中有很多的简洁主题可供选择，同时 Hexo 支持 Markdown 语法，编辑文章更加方便，快捷。</p>
<p><strong>注：此篇分享还以 Mac 为例哈</strong></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><a class="link"   href="https://hexo.io/zh-cn/docs/" >Hexo 文档<i class="fas fa-external-link-alt"></i></a>有对 Hexo 安装及使用的详细介绍，推荐阅读。这里我主要写自己安装的步骤、踩过的坑以及一些优化的方法。</p>
<p>在正式安装 Hexo 之前，我们需要确认电脑中是否已安装下列应用程序:</p>
<ul>
<li><a class="link"   href="https://nodejs.org/en/" >Node.js<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://git-scm.com/" >Git<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>当然，我们还需要 GitHub 账号，如果没有请<a class="link"   href="https://github.com/" >注册<i class="fas fa-external-link-alt"></i></a>。<br>注册之后记得一定要前往邮箱确认注册，否则无法使用 GitHub Pages。</p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。终端输入如下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>输入管理员密码( Mac 登录密码)即开始安装。</p>
<blockquote>
<p>这里有个小坑：<a class="link"   href="https://hexo.io/zh-cn/docs/" >Hexo 官网<i class="fas fa-external-link-alt"></i></a>上的安装命令是<code>npm install -g hexo-cli</code>，安装时不要忘记前面加上<code>sudo</code>，否则会因为权限问题报错。</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>使用终端<code>cd</code>到一个您指定的目录，执行以下命令(命令中的<code>blog</code>是您将要建立的文件夹的名称)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>使用终端<code>cd</code>到<code>blog</code>文件夹下，执行以下命令，安装npm：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>好了，现在可以试试看是否已经初始化成功，执行如下命令，开启本地 Hexo 服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>此时，浏览器中打开网址(默认是4000端口) <a class="link"   href="http://localhost:4000/" >http://localhost:4000<i class="fas fa-external-link-alt"></i></a> ，能看到如下页面：</p>
<p><a href="https://camo.githubusercontent.com/1f1940bfde096eddda51c3856fde79e2ba5068be/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30352f353964356337386634616161652e706e67"><img src="https://camo.githubusercontent.com/1f1940bfde096eddda51c3856fde79e2ba5068be/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30352f353964356337386634616161652e706e67" alt="Hexo 本地"></a></p>
<p>这里我踩了个不算坑的坑，终端输入<code>hexo s</code>后没有成功，我也在网上搜到了很多解决办法，但是都没有奏效，后来我尝试改了下端口就成功了，也就是说默认的4000端口无法连接。如果您的情况跟我一样，尝试了网上的很多解决办法之后依然无效，那您也许可以尝试输入命令<code>hexo s -p 5000</code>改一下端口试试看。</p>
<h2 id="关联-GitHub"><a href="#关联-GitHub" class="headerlink" title="关联 GitHub"></a>关联 GitHub</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><ol>
<li>登录您的 GitHub 账号，新建名称为<code>您的用户名.github.io</code>的仓库。假设我的 GitHub 账号的用户名是 <code>luxun</code>，那么我就应该新建名称为<code>luxun.github.io</code>的仓库。</li>
<li><code>Description</code>可写可不写，随意。</li>
<li>勾上<code>Initialize this repository with a README</code>。</li>
<li>点击<code>Create Repository</code>完成创建。</li>
</ol>
<h3 id="开启-GitHub-Pages"><a href="#开启-GitHub-Pages" class="headerlink" title="开启 GitHub Pages"></a>开启 GitHub Pages</h3><p>点击<code>Settings</code>，你将会打开这个库的 Settings 页面，向下拖动，直到看见 GitHub Pages，如图：</p>
<p><a href="https://camo.githubusercontent.com/bf5629a7167f6a0f931edd10a231e1520793e202/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f31302f30362f353964366531306239636235662e706e67"><img src="https://camo.githubusercontent.com/bf5629a7167f6a0f931edd10a231e1520793e202/68747470733a2f2f6f6f6f2e306f302e6f6f6f2f323031372f31302f30362f353964366531306239636235662e706e67" alt="gh-p"></a></p>
<h3 id="修改全局配置文件"><a href="#修改全局配置文件" class="headerlink" title="修改全局配置文件"></a>修改全局配置文件</h3><p><a class="link"   href="https://hexo.io/zh-cn/docs/configuration.html" >Hexo 官方文档<i class="fas fa-external-link-alt"></i></a>中有对全局配置的详细说明，推荐阅读。</p>
<blockquote>
<p>小坑提醒，修改本地所有的配置文件时，注意所有的冒号<code>:</code>后边都要加一个空格，否则执行 Hexo 命令时会报错，一定注意。</p>
</blockquote>
<p>找到本地<code>blog</code>文件夹下<code>_config.yml</code>，打开后滑到最后，修改成下边的样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>您需要将<code>repository</code>后的所有<code>xxx</code>换成你自己的用户名，或者也可以在下图位置获取：</p>
<p><a href="https://camo.githubusercontent.com/6d9ac169f0d7ce162c61926fbc7438be266647c3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30362f353964373166333333313334332e706e67"><img src="https://camo.githubusercontent.com/6d9ac169f0d7ce162c61926fbc7438be266647c3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30362f353964373166333333313334332e706e67" alt="https 地址"></a></p>
<p>然后，您需要为自己配置身份信息，终端输入<code>yourname</code>和<code>youremail</code>换成您自己的 GitHub 用户名和邮箱)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>终端<code>cd</code>到<code>blog</code>文件夹下执行生成静态页面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>此时若出现如下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Local hexo not found in ~&#x2F;blog</span><br><span class="line">ERROR Try runing: &#39;npm install hexo --save&#39;</span><br></pre></td></tr></table></figure>
<p>尝试执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>
<p>若无报错，自行忽略此步骤。</p>
<p>然后在当前目录下，终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>这里踩了个坑，如果您执行命令<code>hexo d</code>仍然报错：无法连接 git 或找不到 git，则执行如下命令来安装<code>hexo-deployer-git</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>完成安装之后，再次执行<code>hexo g</code>和<code>hexo d</code>命令。</p>
<p>随后按照提示，分别输入自己的 GitHub 用户名和密码，开始上传。</p>
<p>完成上传之后，通过<code>http://xxx.github.io/</code> (<code>xxx</code>换成您自己的仓库名，也就是用户名)来访问自己刚刚上传的网站。</p>
<ul>
<li>为避免每次输入 GitHub 用户名和密码的麻烦，可参照后文 <strong>优化(个性化设置)</strong> <code>添加ssh key 到 GitHub</code>进行优化</li>
</ul>
<h2 id="常用指令和发布文章"><a href="#常用指令和发布文章" class="headerlink" title="常用指令和发布文章"></a>常用指令和发布文章</h2><ul>
<li>常用指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot;        &#x2F;&#x2F;新建文章</span><br><span class="line">hexo new page &quot;pageName&quot;        &#x2F;&#x2F;新建页面</span><br><span class="line">hexo g          &#x2F;&#x2F;生成静态页面至public目录</span><br><span class="line">hexo server         &#x2F;&#x2F;开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy         &#x2F;&#x2F;将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure>
<ul>
<li>常用组合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo d -g #生成部署</span><br><span class="line">hexo s -g #生成预览</span><br></pre></td></tr></table></figure>
<ul>
<li>发布文章</li>
</ul>
<p>终端<code>cd</code>到<code>blog</code>文件夹下，执行如下命令新建文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<p>名为<code>xxx.md</code>的文件会建在目录<code>.../blog/source/_posts</code>下。</p>
<p>所有的文章都会以<code>md</code>形式保存在<code>_post</code>文件夹中，只要在<code>_post</code>文件夹中新建<code>md</code>类型的文档，就能在执行<code>hexo g</code>的时候被渲染。新建的文章头需要添加一些信息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx    &#x2F;&#x2F;在此处添加你的标题。</span><br><span class="line">date: 2016-10-07 13:38:49   &#x2F;&#x2F;在此处输入编辑这篇文章的时间。</span><br><span class="line">tags: xxx    &#x2F;&#x2F;在此处输入这篇文章的标签。</span><br><span class="line">categories: xxx    &#x2F;&#x2F;在此处输入这篇文章的分类。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>文章编辑完成后，终端<code>cd</code>到<code>blog</code>文件夹下，依次执行如下命令来发布：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>至此，Mac 上搭建基于 GitHub Pages + Hexo 的博客就完成了。</p>
<p>下面的内容是介绍安装 Themes 、个性化设置以及优化。</p>
<h2 id="设置-Themes"><a href="#设置-Themes" class="headerlink" title="设置 Themes"></a>设置 Themes</h2><p>如果您喜欢 Hexo 默认的主题的话，可以跳过这部分。如果您想换一个主题的话，可以到<a class="link"   href="https://hexo.io/themes/" >Hexo 主题<i class="fas fa-external-link-alt"></i></a>挑选自己中意的主题。</p>
<p>这里以<a class="link"   href="https://github.com/iissnan/hexo-theme-next" >nexT 主题<i class="fas fa-external-link-alt"></i></a>为例。</p>
<p>终端<code>cd</code>到<code>blog</code>目录下执行如下命令(这是目前的稳定版本，不是最新版。最新版有一些新特性，但是可能会不稳定，所以这里推荐选择安装稳定版)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --branch v5.1.2 https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>如果想尝试最新版，请执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>打开<code>blog</code>目录下的<code>_config.yml</code>，找到<code>theme: landscape</code>修改为<code>theme: next</code>。</p>
<p>终端<code>cd</code>到<code>blog</code>目录下，依次执行如下命令(每次部署文章的步骤)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>至于更改博客的名称、描述、头像等，只需要修改<code>blog/_config.yml</code>文件和<code>blog/themes/next/_config.yml</code>文件中对应的属性名称即可(不要忘记冒号<code>:</code>后加空格)。</p>
<ul>
<li>更多设置<a class="link"   href="http://theme-next.iissnan.com/" >NexT 使用文档<i class="fas fa-external-link-alt"></i></a>里有极详细的介绍，推荐阅读。</li>
</ul>
<h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><ul>
<li><strong>首先参照NexT 官方文档进行个性化设置，之后再看下文。</strong></li>
</ul>
<h3 id="为博客加上-GitHub-丝带"><a href="#为博客加上-GitHub-丝带" class="headerlink" title="为博客加上 GitHub 丝带"></a>为博客加上 GitHub 丝带</h3><p>这里以 Next 主题为例(其他主题也差不多)，添加 GitHub 丝带：在<code>blog\themes\next\layout\_layout.swig</code>中加入<a class="link"   href="https://github.com/blog/273-github-ribbons" >相关代码<i class="fas fa-external-link-alt"></i></a>，记得修改自己的链接。</p>
<h3 id="添加-README-md"><a href="#添加-README-md" class="headerlink" title="添加 README.md"></a>添加 README.md</h3><p>每个项目仓库下一般都有一个 <code>README.md</code> 文件，但是使用 hexo 部署到仓库后，项目仓库中是没有 <code>README.md</code> 文件的。</p>
<p>在 <code>blog</code> 目录下的 <code>source</code> 目录下添加一个 <code>README.md</code> 文件，修改站点配置文件 <code>_config.yml</code>，将 <code>skip_render</code> 参数的值设置为 <code>README.md</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure>
<p>保存退出即可。</p>
<h3 id="为博客添加-LICENSE"><a href="#为博客添加-LICENSE" class="headerlink" title="为博客添加 LICENSE"></a>为博客添加 LICENSE</h3><p>在主题配置文件中添加下面这段代码(添加之前先看看您的主题配置文件是否已经包含这段代码，已经包含就不用添加了，因为重复会报错)，LICENSE 会显示在侧边栏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># http:&#x2F;&#x2F;creativecommons.org&#x2F;</span><br><span class="line"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line">creative_commons: by-nc-sa</span><br><span class="line">#creative_commons:</span><br></pre></td></tr></table></figure>
<h3 id="修改文章底部的带-号的标签"><a href="#修改文章底部的带-号的标签" class="headerlink" title="修改文章底部的带 # 号的标签"></a>修改文章底部的带 <code>#</code> 号的标签</h3><p>如果您觉得<code>#</code>不好看，想改成图标，那么请按照下面修改。<br>打开<code>/themes/next/layout/_macro/post.swig</code>，搜索(组合键<code>command</code>+<code>f</code>)<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。</p>
<h3 id="将阅读量改为热度"><a href="#将阅读量改为热度" class="headerlink" title="将阅读量改为热度"></a>将阅读量改为热度</h3><p>很多人将文章标题下的 <strong>阅读次数</strong> 改为了 <strong>热度</strong>，如果您喜欢的话可以这样修改。</p>
<p>打开<code>blog/themes/next/languages/zh-Hans</code>文件，查找<code>阅读次数</code>这几个字，可以看到，在<code>post</code>中的<code>visitors</code>被定义为<code>阅读次数</code>，把这里的<code>阅读次数</code>改为<code>热度</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visitors: 热度</span><br></pre></td></tr></table></figure>
<p>那么怎么在页面中显示呢？打开Next主题文件夹中<code>blog/themes/next/layout/_macro/post.swig</code>，在这个文件里加上摄氏度的标志，在<code>&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</code>下面增加一行<code>&lt;span&gt;℃&lt;/span&gt;</code>即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span class&#x3D;&quot;leancloud-visitors-count&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;span&gt;℃&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><ul>
<li>修改 hexo-generator-index 插件</li>
</ul>
<p>替换文件<code>blog/node_modules/hexo-generator-index/lib/generator.js</code> 内的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var pagination &#x3D; require(&#39;hexo-pagination&#39;);</span><br><span class="line">module.exports &#x3D; function(locals)&#123;</span><br><span class="line">  var config &#x3D; this.config;</span><br><span class="line">  var posts &#x3D; locals.posts;</span><br><span class="line">    posts.data &#x3D; posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; &#x2F;&#x2F; 两篇文章top都有定义</span><br><span class="line">            if(a.top &#x3D;&#x3D; b.top) return b.date - a.date; &#x2F;&#x2F; 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; &#x2F;&#x2F; 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; &#x2F;&#x2F; 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; &#x2F;&#x2F; 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir &#x3D; config.pagination_dir || &#39;page&#39;;</span><br><span class="line">  return pagination(&#39;&#39;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&#39;index&#39;, &#39;archive&#39;],</span><br><span class="line">    format: paginationDir + &#39;&#x2F;%d&#x2F;&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置文章置顶</li>
</ul>
<p>在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx</span><br><span class="line">date: 2015-04-02 14:36:04</span><br><span class="line">categories: xxx</span><br><span class="line">tags: xxx</span><br><span class="line">top: 10</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="NexT-首页文章-加载更多-设置"><a href="#NexT-首页文章-加载更多-设置" class="headerlink" title="NexT 首页文章 加载更多 设置"></a>NexT 首页文章 加载更多 设置</h3><p>这里只说一个方法：编辑文章时，在您希望显示 <code>加载更多</code> 按钮的地方，加上<code>&lt;!--more--&gt;</code>：</p>
<p><a href="https://camo.githubusercontent.com/a4a9629c1d7a4d8fe4a869a4656c208b9dc955a3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964616366616432333134632e706e67"><img src="https://camo.githubusercontent.com/a4a9629c1d7a4d8fe4a869a4656c208b9dc955a3/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964616366616432333134632e706e67" alt="more"></a></p>
<h3 id="首页分割线"><a href="#首页分割线" class="headerlink" title="首页分割线"></a>首页分割线</h3><p>  在 <code>\themes\next\source\css\_custom\custom.styl</code> 文件中添加以下代码，可以修改博客首页中每篇文章的分割线样式，<code>width</code>是长度，<code>height</code>是宽度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;index页面中每篇文章相隔的那条线</span><br><span class="line">.posts-expand &#123;</span><br><span class="line">  .post-eof &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    margin: $post-eof-margin-top auto $post-eof-margin-bottom;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 3px;</span><br><span class="line">    background: $grey-light;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小图标设置"><a href="#小图标设置" class="headerlink" title="小图标设置"></a>小图标设置</h3><p>博客中一切小图标都可以在<a class="link"   href="http://fontawesome.io/icons/" >fontawesome 图标库<i class="fas fa-external-link-alt"></i></a>自行搜索(qq、微博、微信等图标是有的，但知乎、豆瓣等图标目前还没有)。</p>
<ul>
<li>修改网页底部的桃心图标<br>打开<code>blog/themes/next/layout/_partials/footer.swig</code>，找到这段代码进行修改(还是在<a class="link"   href="http://fontawesome.io/icons/" >fontawesome 图标库<i class="fas fa-external-link-alt"></i></a>找自己喜欢的图标)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span class&#x3D;&quot;with-love&quot;&gt;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-share-alt&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<h3 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h3><p>准备一张 icon 图标文件，放在 source 目录下就可以了，在<code>主题配置文件</code>中找到 favicon 的设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Put your favicon.ico into &#96;hexo-site&#x2F;source&#x2F;&#96; directory.</span><br><span class="line">favicon: &#x2F;favicon.ico</span><br></pre></td></tr></table></figure>
<h3 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>具体实现方法</p>
<p>打开<code>blog\themes\next\source\css\_custom\custom.styl</code>文件，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐藏网页底部-powered-By-Hexo-强力驱动"><a href="#隐藏网页底部-powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部 powered By Hexo / 强力驱动"></a>隐藏网页底部 powered By Hexo / 强力驱动</h3><p>打开<code>blog/themes/next/layout/_partials/footer.swig</code>，使用<code>&lt;!--</code> <code>--&gt;</code>隐藏符号之间的代码即可，或者直接将这段代码删除。位置如图：</p>
<p><a href="https://camo.githubusercontent.com/ccd1f539b033ed7f11d9f8ae7f5f052b9a79944e/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964396236313963646232372e706e67"><img src="https://camo.githubusercontent.com/ccd1f539b033ed7f11d9f8ae7f5f052b9a79944e/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964396236313963646232372e706e67" alt="隐藏底部 Hexo"></a></p>
<h3 id="添加-SSH-key-到-GitHub"><a href="#添加-SSH-key-到-GitHub" class="headerlink" title="添加 SSH key 到 GitHub"></a>添加 SSH key 到 GitHub</h3><ul>
<li>检查 SSH keys 是否已经存在</li>
</ul>
<p>终端执行如下命令，检查SSH keys是否存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls ~&#x2F;.ssh</span><br></pre></td></tr></table></figure>
<p>如果显示如下信息(下面是我个人的显示，也许您跟我显示的不一样，但重点是只要有<code>id_rsa</code>和<code>id_rsa.pub</code>)，就说明 SSH keys 已经存在了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa	   id_rsa.pub	  known_hosts</span><br></pre></td></tr></table></figure>
<p>如果存在，则直接跳过下一个步骤进入<code>将 SSH key 添加到 GitHub 中</code>，否则请继续下一步骤 <code>生成新的 SSH key</code>。</p>
<ul>
<li>生成新的 SSH key</li>
</ul>
<p>终端执行如下命令生成新的 SSH key，注意将<code>your_email@example.com</code>换成你自己注册 GitHub 的邮箱地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>默认会在相应路径<code>~/.ssh</code>下生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。</p>
<p>1.3.将 SSH key 添加到 GitHub 中</p>
<p>终端依次输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>复制所有显示的内容</p>
<p>进入GitHub –&gt; Settings –&gt; SSH and GPG keys –&gt; NEW SSH key，如下图所示：</p>
<p><a href="https://camo.githubusercontent.com/74765507927a29b4bef4b04a5c0dc470e4a62a5d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663639656337332e706e67"><img src="https://camo.githubusercontent.com/74765507927a29b4bef4b04a5c0dc470e4a62a5d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663639656337332e706e67" alt="settings"></a></p>
<p><a href="https://camo.githubusercontent.com/4aac3af0611d3b11a554f9d8b297826d8d73733c/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663830393662372e706e67"><img src="https://camo.githubusercontent.com/4aac3af0611d3b11a554f9d8b297826d8d73733c/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383466663830393662372e706e67" alt="ssh_key"></a></p>
<p>Title 里任意添一个标题，将复制的内容粘贴到 Key 里，点击下方 Add SSH key 绿色按钮即可，如下图所示：</p>
<p><a href="https://camo.githubusercontent.com/d7f739371b722e2a5e69a4b10c536c866bc32a64/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383532306339666362632e706e67"><img src="https://camo.githubusercontent.com/d7f739371b722e2a5e69a4b10c536c866bc32a64/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30372f353964383532306339666362632e706e67" alt="add_ssh_key"></a></p>
<h3 id="绑定独立域名"><a href="#绑定独立域名" class="headerlink" title="绑定独立域名"></a>绑定独立域名</h3><ul>
<li>首先，需要注册一个域名。可以选择<a class="link"   href="https://www.godaddy.com/" >GoDaddy<i class="fas fa-external-link-alt"></i></a>或<a class="link"   href="https://wanwang.aliyun.com/" >万网<i class="fas fa-external-link-alt"></i></a>中的任意一家。</li>
<li>然后，我们需要配置一下域名解析。推荐使用<a class="link"   href="https://www.dnspod.cn/" >DNSPod<i class="fas fa-external-link-alt"></i></a>的服务，免费稳定，解析速度也比较快。在域名注册商处(Godaddy 或万网)修改 NS 服务器地址为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1g1ns1.dnspod.net</span><br><span class="line">f1g1ns2.dnspod.net</span><br></pre></td></tr></table></figure>
<p>域名解析详细的步骤这里我就不写了，给个图：</p>
<p><a href="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67"><img src="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67" alt="dnspod"></a></p>
<p>图中设置国内国外的原因是想让博客加载速度更快，方法请阅读后文 <strong>将个人博客同时部署到 GitHub 和 Coding</strong>。</p>
<ul>
<li>如果将域名指向另一个域名，实现与被指向域名相同的访问效果，需要增加 CNAME 记录。</li>
</ul>
<p>进入 <code>blog/source</code> 目录下，添加并打开 <code>CNAME</code> 文件，输入您的域名，重新上传您的博客。</p>
<p>在 GitHub 中打开您自己的博客仓库，进入库的 Settings 界面，如果看到了如下提示，说明配置成功了。</p>
<p><a href="https://camo.githubusercontent.com/6431246933090b54e265ac2ea1cc8c19ceefa85b/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613432336336353138392e706e67"><img src="https://camo.githubusercontent.com/6431246933090b54e265ac2ea1cc8c19ceefa85b/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613432336336353138392e706e67" alt="CNAME"></a></p>
<p>在这一系列的操作中，修改 NS 服务器、设置解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的 DNS 服务器。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="将个人博客同时部署到-GitHub-和-Coding"><a href="#将个人博客同时部署到-GitHub-和-Coding" class="headerlink" title="将个人博客同时部署到 GitHub 和 Coding"></a>将个人博客同时部署到 GitHub 和 Coding</h3><p><a class="link"   href="https://coding.net/" >Coding<i class="fas fa-external-link-alt"></i></a> 可以理解为国内的 GitHub。通过将博客同时部署到 GitHub 和 Coding，可以提升博客的加载速度。</p>
<p>这里有个提醒，Coding 会强制用户在网站上挂推广图标，通过 Coding 加载博客还会有5s广告，如果觉得这样不好，可以选择放弃部署在 Coding 上。还有一个选择，就是花钱成为 Coding 的会员，这样上述的问题就都没有了。</p>
<ul>
<li>首先到<a class="link"   href="https://coding.net/" >Coding<i class="fas fa-external-link-alt"></i></a>注册。创建仓库跟 GitHub 上创建仓库的要求一样。</li>
<li>打开本地 <code>blog</code> 目录下的 <code>_config.yml</code> 文件，滑到最下面，修改如下(xxx换成自己的用户名)：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io.git</span><br><span class="line">    coding: https:&#x2F;&#x2F;git.coding.net&#x2F;xxx&#x2F;xxx.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<ul>
<li>然后执行命令<code>hexo clean</code> <code>hexo g</code> <code>hexo d</code></li>
<li>个人域名添加两条 CNAME 解析。将 GitHub 的地址 解析为 <code>国外</code> ，将 Coding 的地址 解析为 <code>国内</code> ：</li>
</ul>
<p><a href="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67"><img src="https://camo.githubusercontent.com/ad380b4619e75b1267229118fb8cfc39c2aca851/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30382f353964613363333663663433362e706e67" alt="dnspod"></a></p>
<ul>
<li>如果您有个人域名的话，到 Coding 博客仓库的 <code>Pages 服务</code> 界面，添加域名绑定，输入个人域名就 OK 了，可能需要耐心等待几分钟。</li>
</ul>
<p>这样就可以实现从国内访问就通过 Coding 加载博客项目，从国外访问就通过 GitHub 加载博客项目，从而提升加载博客的速度。</p>
<h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>压缩代码也是一个优化加载速度的方法。</p>
<p>目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp 插件。hexo-all-minifier 使用比较简单，也可以压缩图片，不过对文章缩进不支持。如果您对文章缩进有要求，可以暂时使用 gulp 压缩手段。</p>
<ul>
<li>hexo-all-minifier 使用方法</li>
</ul>
<p>安装 hexo-all-minifier，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure>
<p><code>hexo g</code>编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 <a class="link"   href="https://github.com/chenzhutian/hexo-all-minifier" >hexo-all-minifier<i class="fas fa-external-link-alt"></i></a>。</p>
<ul>
<li>glup 使用方法</li>
</ul>
<p>Hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install gulp -g</span><br><span class="line">npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure>
<p>在<code>blog</code>目录下，新建 <code>gulpfile.js</code> 并填入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gulp &#x3D; require(&#39;gulp&#39;);</span><br><span class="line">var minifycss &#x3D; require(&#39;gulp-minify-css&#39;);</span><br><span class="line">var uglify &#x3D; require(&#39;gulp-uglify&#39;);</span><br><span class="line">var htmlmin &#x3D; require(&#39;gulp-htmlmin&#39;);</span><br><span class="line">var htmlclean &#x3D; require(&#39;gulp-htmlclean&#39;);</span><br><span class="line">&#x2F;&#x2F; 压缩 public 目录 css</span><br><span class="line">gulp.task(&#39;minify-css&#39;, function() &#123;</span><br><span class="line">    return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.css&#39;)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(&#39;.&#x2F;public&#39;));</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 压缩 public 目录 html</span><br><span class="line">gulp.task(&#39;minify-html&#39;, function() &#123;</span><br><span class="line">  return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.html&#39;)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: true,</span><br><span class="line">         minifyJS: true,</span><br><span class="line">         minifyCSS: true,</span><br><span class="line">         minifyURLs: true,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#39;.&#x2F;public&#39;))</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 压缩 public&#x2F;js 目录 js</span><br><span class="line">gulp.task(&#39;minify-js&#39;, function() &#123;</span><br><span class="line">    return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.js&#39;)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&#39;.&#x2F;public&#39;));</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(&#39;default&#39;, [</span><br><span class="line">    &#39;minify-html&#39;,&#39;minify-css&#39;,&#39;minify-js&#39;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>生成博文时执行 <code>hexo g &amp;&amp; gulp</code> 就会根据 <code>gulpfile.js</code> 中的配置，对 public 目录中的静态资源文件进行压缩。</p>
<h2 id="SEO-搜索引擎优化"><a href="#SEO-搜索引擎优化" class="headerlink" title="SEO(搜索引擎优化)"></a>SEO(搜索引擎优化)</h2><h3 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h3><ul>
<li><a class="link"   href="https://accounts.google.com/signin/v2/sl/pwd?service=sitemaps&passive=1209600&continue=https://www.google.com/webmasters/verification/home?hl=zh-CN&followup=https://www.google.com/webmasters/verification/home?hl=zh-CN&hl=zh-CN&flowName=GlifWebSignIn&flowEntry=ServiceLogin" >Google 提交入口<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://zhanzhang.baidu.com/dashboard/index" >百度提交入口<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>验证方式有几种，推荐最简单的两种：文件验证和 CNAME 验证。</p>
<ul>
<li>文件验证</li>
</ul>
<ol>
<li>登录百度站长选择添加网站，使用方式为文件验证</li>
<li>将下载的文件放到<code>source</code>文件下</li>
<li>由于 hexo 自动会对 html 文件进行渲染，所以在<code>站点配置文件</code>中找到<code>skip_render:</code></li>
<li>在后面添加文件名字，若有多个用这样的形式<code>[xxx.html, xxx.html]</code>，比如： <code>skip_render: [googleff0226f76d5f451b.html, baidu_verify_vHC5EAW09E.html]</code></li>
<li>重新渲染文件： <code>hexo clean</code> <code>hexo d -g</code></li>
<li>点击站长的验证按钮，完成验证。</li>
</ol>
<ul>
<li>CNAME 验证</li>
</ul>
<ol>
<li>去站长添加网站选择 CNAME 验证</li>
<li>把地址解析到<code>zz.baidu.com</code></li>
<li>完成验证</li>
</ol>
<h3 id="添加并提交sitemap"><a href="#添加并提交sitemap" class="headerlink" title="添加并提交sitemap"></a>添加并提交sitemap</h3><p>安装 Hexo 的 sitemap 网站地图生成插件，终端<code>cd</code>到<code>blog</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p>在<code>站点配置文件</code>中任意位置添加如下代码，但要看清您的 Hexo 版本。</p>
<p>如果您的 Hexo 版本是 2.x.x</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>如果您的 Hexo 版本是 3.x.x</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>配置成功后，会生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。</p>
<p>百度 sitemap 提交如图，Google 也是一样的：</p>
<p><a href="https://camo.githubusercontent.com/78d3ea331416e6c1a53b9a42bb0f539e1c4f0bca/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623331643630633836612e706e67"><img src="https://camo.githubusercontent.com/78d3ea331416e6c1a53b9a42bb0f539e1c4f0bca/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623331643630633836612e706e67" alt="sitemap_yz"></a></p>
<p>验证成功之后就可以开始推送了。Google 的收录比较快，通常第二天就能搜得到，百度就比较慢了。</p>
<h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><p>安装主动推送插件，终端<code>cd</code>到<code>blog</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>
<p>在根目录下，把以下内容配置到站点配置文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3     ## 比如3，代表提交最新的三个链接</span><br><span class="line">  host: xxx     ## 在百度站长平台中注册的域名</span><br><span class="line">  token: xxx       ## 请注意这是您的秘钥，请不要发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt       ## 文本文档的地址，新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>
<p>至于上面提到的<code>token</code>可在百度站长如下位置找到：</p>
<p><a href="https://camo.githubusercontent.com/0be351243233a8d88d3671a58368e0e583f49615/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623361633931616635332e706e67"><img src="https://camo.githubusercontent.com/0be351243233a8d88d3671a58368e0e583f49615/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623361633931616635332e706e67" alt="token"></a></p>
<p>其次，记得查看<code>站点配置文件</code>中的<code>url</code>，必须包含站长平台注册的域名，比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;harleywang93.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br></pre></td></tr></table></figure>
<p>接下来添加一个新的 <code>deploy</code> 类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: baidu_url_submitter</span><br><span class="line">- type: git</span><br><span class="line">  repository:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.github.io.git</span><br><span class="line">    coding: https:&#x2F;&#x2F;git.coding.net&#x2F;xxx&#x2F;xxx.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>执行<code>hexo d</code>的时候，新的链接就会被推送了。原理：</p>
<ul>
<li>新链接的产生，<code>hexo g</code>会产生一个文本文件，里面包含最新的链接。</li>
<li>新链接的提交，<code>hexo d</code>会从上述文件中读取链接，提交至百度搜索引擎。</li>
</ul>
<h3 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h3><p>把 NexT 主题配置文件中的<code>baidu_push:</code>设置为<code>true</code>，就可以了。</p>
<h3 id="添加蜘蛛协议"><a href="#添加蜘蛛协议" class="headerlink" title="添加蜘蛛协议"></a>添加蜘蛛协议</h3><p>在<code>blog/source/</code>目录下新建一个<code>robots.txt</code>文件，添加下面的一段代码(可根据自己的需要修改)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line"></span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: http:&#x2F;&#x2F;xxx&#x2F;sitemap.xml</span><br><span class="line">Sitemap: http:&#x2F;&#x2F;xxx&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>然后到站长(这里以百度为例，Google 一样)更新一下，就像这样：</p>
<p><a href="https://camo.githubusercontent.com/3ca54425ad21dd7925c9ce541cfc4ba60dc7f00d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623364636531616566382e706e67"><img src="https://camo.githubusercontent.com/3ca54425ad21dd7925c9ce541cfc4ba60dc7f00d/68747470733a2f2f692e6c6f6c692e6e65742f323031372f31302f30392f353964623364636531616566382e706e67" alt="robots"></a></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>自己搭建博客时，很是折腾了一番，也学习到了很多知识，阅读了很多相关的博文，在此向相关博文的作者表示感谢，谢谢你们的文章让我进步。同时，我看到有很多人想拥有自己的博客或者优化自己的博客，期间可能会遇到很多问题，我也是这么一个坑一个坑踩过来的，所以我就写了这么一篇自己折腾博客的分享，希望可以在帮助自己的同时帮助到别人。(如果踩了新坑的话，一定会更新的。)</p>
<ul>
<li>目前已经弃掉了此方法写博客，因为想回到回归初心，写博客最初的目的 - 总结梳理知识以及分享一些感受，不在乎形式。( 其实是因为懒得折腾了，Hexo 有一些不稳定性，所以目前弃掉了，喜欢折腾的可以继续尝试 lol )</li>
</ul>
<p>希望大家也能有此感受。</p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot快速集成swagger</title>
    <url>/p/e48d.html</url>
    <content><![CDATA[<blockquote>
<p>今天技术总监说：小明，我们本次3.0改造，使用swagger2.0作为前后端分离的接口规范，它可以一键生成前后端的API,一劳永逸……小明：？？？</p>
</blockquote>
<p>Spring Boot 框架是目前非常流行的微服务框架，我们很多情况下使用它来提供 Rest API，而对于 Rest API 来说很重要的一部分内容就是文档，Swagger 为我们提供了一套通过代码和注解自动生成文档的方法，这一点对于保证 API 文档的及时性将有很大的帮助。本文将使用 Swagger 2 规范的 Springfox 实现来了解如何在 Spring Boot 项目中使用 Swagger，主要包含了如何使用 Swagger 自动生成文档、使用 Swagger 文档以及 Swagger 相关的一些高级配置和注解。</p>
<h1 id="Swagger-简介"><a href="#Swagger-简介" class="headerlink" title="Swagger 简介"></a>Swagger 简介</h1><p>Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。Swagger 主要包含了以下三个部分：</p>
<ol>
<li>Swagger Editor：基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范。</li>
<li>Swagger UI：它会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 Rest API。</li>
<li>Swagger Codegen：它可以通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程。</li>
</ol>
<h2 id="为什么要使用-Swagger"><a href="#为什么要使用-Swagger" class="headerlink" title="为什么要使用 Swagger"></a>为什么要使用 Swagger</h2><p>当下很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的 Rest API 文档将会极大的提高我们的工作效率。传统意义上的文档都是后端开发人员手动编写的，相信大家也都知道这种方式很难保证文档的及时性，这种文档久而久之也就会失去其参考意义，反而还会加大我们的沟通成本。而 Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们就来了解一下它的优点：</p>
<ol>
<li><p>代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。</p>
</li>
<li><p>跨语言性，支持 40 多种语言。</p>
</li>
<li><p>Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</p>
</li>
<li><p>还可以将文档规范导入相关的工具（例如 SoapUI）, 这些工具将会为我们自动地创建自动化测试。</p>
</li>
</ol>
<p>以上这些优点足以说明我们为什么要使用 Swagger 了，您是否已经对 Swagger 产生了浓厚的兴趣了呢？下面我们就将一步一步地在 Spring Boot 项目中集成和使用 Swagger，让我们从准备一个 Spring Boot 的 Web 项目开始吧。</p>
<h1 id="准备-Spring-Boot-Web-项目"><a href="#准备-Spring-Boot-Web-项目" class="headerlink" title="准备 Spring Boot Web 项目"></a>准备 Spring Boot Web 项目</h1><p>在这一步我们将准备一个基础的 Spring Boot 的 Web 项目，并且提供后面所需要的所有 API。</p>
<h2 id="创建一个空的-Spring-Boot-项目"><a href="#创建一个空的-Spring-Boot-项目" class="headerlink" title="创建一个空的 Spring Boot 项目"></a>创建一个空的 Spring Boot 项目</h2><p>您可以通过 Spring Initializr 页面生成一个空的 Spring Boot 项目，当然也可以下载 springboot-pom.xml 文件，然后使用 Maven 构建一个 Spring Boot 项目。项目创建完成后，为了方便后面代码的编写您可以将其导入到您喜欢的 IDE 中，我这里选择了 Intelli IDEA 打开。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>由于创建的是一个 Web 项目，所以我们需要依赖 Spring Boot 的 Web 组件，只需要在 pom.xml 增加如下内容即可：</p>
<p>清单 1. 添加 Web 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h2><ol>
<li>首先我们创建三个包：cn.itweknow.sbswagger.controller、cn.itweknow.sbswagger.testcontroller 以及 cn.itweknow.sbswagger.model。</li>
<li>在 controller 包下新建 UserController.java 类，在 testcontroller 包下新建 TestController.java 类，在 model 包下新建 User.java 类。</li>
<li>UserController 提供用户的增、删、改、查四个接口，TestContrller 提供一个测试接口，这里粘上 UserController.java 的代码，其余代码可以查看源码。</li>
</ol>
<p>清单 2. UserController.java 代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;&#x2F;add&quot;)</span><br><span class="line">    public boolean addUser(@RequestBody User user) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    @GetMapping(&quot;&#x2F;find&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public User findById(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">    @PutMapping(&quot;&#x2F;update&quot;)</span><br><span class="line">    public boolean update(@RequestBody User user) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @DeleteMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="集成-Swagger2"><a href="#集成-Swagger2" class="headerlink" title="集成 Swagger2"></a>集成 Swagger2</h1><p>经过上面的步骤，我们已经拥有了五个接口，分别是:</p>
<ol>
<li>/user/add：新增用户。</li>
<li>/user/find/{id}：根据 id 查询用户。</li>
<li>/user/update：更新用户。</li>
<li>/user/delete/{id}：根据 id 删除用户。</li>
<li>/test/test：测试接口。</li>
</ol>
<p>下面我们将通过集成 Swagger2，然后为这 5 个 Rest API 自动生成接口文档。</p>
<h2 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>首先要做的自然是添加 Swagger2 所需要的依赖包：</p>
<p>清单 3. 添加 Swagger 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h2><p>Springfox 提供了一个 Docket 对象，让我们可以灵活的配置 Swagger 的各项属性。下面我们新建一个 cn.itweknow.sbswagger.conf.SwaggerConfig.java 类，并增加如下内容:</p>
<p>清单 4. Swagger Java 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket api() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: @Configuration 是告诉 Spring Boot 需要加载这个配置类，@EnableSwagger2 是启用 Swagger2，如果没加的话自然而然也就看不到后面的验证效果了。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>至此，我们已经成功的在 Spring Boot 项目中集成了 Swagger2，启动项目后，我们可以通过在浏览器中访问 <a class="link"   href="http://localhost:8080/" >http://localhost:8080/<i class="fas fa-external-link-alt"></i></a> v2/api-docs 来验证，您会发现返回的结果是一段 JSON 串，可读性非常差。幸运的是 Swagger2 为我们提供了可视化的交互界面 SwaggerUI，下面我们就一起来试试吧。</p>
<h1 id="集成-Swagger-UI"><a href="#集成-Swagger-UI" class="headerlink" title="集成 Swagger UI"></a>集成 Swagger UI</h1><h2 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>和之前一样，集成的第一步就是添加相关依赖，在 pom.xml 中添加如下内容即可：</p>
<p>清单 5. 添加 Swagger UI 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="访问验证"><a href="#访问验证" class="headerlink" title="访问验证"></a>访问验证</h2><p>其实就只需要添加一下依赖就可以了，我们重新启动一下项目，然后在浏览器中访问 <a class="link"   href="http://localhost:8080/swagger-ui.html" >http://localhost:8080/swagger-ui.html<i class="fas fa-external-link-alt"></i></a> 就可以看到如下的效果了:</p>
<p>图 1. Swagger UI</p>
<p><img src="https://s2.ax1x.com/2019/06/06/VdbBqK.png" alt="点击查看大图"></p>
<p>可以看到虽然可读性好了一些，但对接口的表述还不是那么的清楚，接下来我们就通过一些高级配置，让这份文档变的更加的易读。</p>
<h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><h2 id="文档相关描述配置"><a href="#文档相关描述配置" class="headerlink" title="文档相关描述配置"></a>文档相关描述配置</h2><ol>
<li>通过在控制器类上增加@Api 注解，可以给控制器增加描述和标签信息。</li>
</ol>
<p>清单 6. 给 Controller 添加描述信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api(tags &#x3D; &quot;用户相关接口&quot;, description &#x3D; &quot;提供用户相关的 Rest API&quot;)</span><br><span class="line">public class UserController</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过在接口方法上增加 @ApiOperation 注解来展开对接口的描述，当然这个注解还可以指定很多内容，我们在下面的相关注解说明章节中详细解释。</li>
</ol>
<p>清单 7. 给接口添加描述信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;新增用户接口&quot;)</span><br><span class="line">@PostMapping(&quot;&#x2F;add&quot;)</span><br><span class="line">public boolean addUser(@RequestBody User user) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>实体描述，我们可以通过 @ApiModel 和 @ApiModelProperty 注解来对我们 API 中所涉及到的对象做描述。</li>
</ol>
<p>清单 8. 给实体类添加描述信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @ApiModelProperty(&quot;用户 id&quot;)</span><br><span class="line">private int id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>文档信息配置，Swagger 还支持设置一些文档的版本号、联系人邮箱、网站、版权、开源协议等等信息，但与上面几条不同的是这些信息不是通过注解配置，而是通过创建一个 ApiInfo 对象，并且使用 Docket.appInfo() 方法来设置，我们在 SwaggerConfig.java 类中新增如下内容即可。</li>
</ol>
<p>清单 9. 配置文档信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket api() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.select()</span><br><span class="line">            .apis(RequestHandlerSelectors.any())</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line">private ApiInfo apiInfo() &#123;</span><br><span class="line">return new ApiInfo(</span><br><span class="line">            &quot;Spring Boot 项目集成 Swagger 实例文档&quot;,</span><br><span class="line">            &quot;我的博客网站：https:&#x2F;&#x2F;itweknow.cn，欢迎大家访问。&quot;,</span><br><span class="line">            &quot;API V1.0&quot;,</span><br><span class="line">            &quot;Terms of service&quot;,</span><br><span class="line">            new Contact(&quot;名字想好没&quot;, &quot;https:&#x2F;&#x2F;itweknow.cn&quot;, &quot;gancy.programmer@gmail.com&quot;),</span><br><span class="line">                &quot;Apache&quot;, &quot;http:&#x2F;&#x2F;www.apache.org&#x2F;&quot;, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上面的步骤，我们的文档将会变成下图的样子，现在看起来就清楚很多了。</p>
<p>图 2. 补全信息后的 Swagger 文档界面</p>
<p><img src="https://s2.ax1x.com/2019/06/06/VdqRkF.png" alt="点击查看大图"></p>
<h2 id="接口过滤"><a href="#接口过滤" class="headerlink" title="接口过滤"></a>接口过滤</h2><p>有些时候我们并不是希望所有的 Rest API 都呈现在文档上，这种情况下 Swagger2 提供给我们了两种方式配置，一种是基于 @ApiIgnore 注解，另一种是在 Docket 上增加筛选。</p>
<ol>
<li>@ApiIgnore 注解。</li>
</ol>
<p>如果想在文档中屏蔽掉删除用户的接口（user/delete），那么只需要在删除用户的方法上加上 @ApiIgnore 即可。</p>
<p>清单 10. @ApiIgnore 使用实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiIgnore</span><br><span class="line">public boolean delete(@PathVariable(&quot;id&quot;) int id)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 Docket 上增加筛选。Docket 类提供了 apis() 和 paths()两 个方法来帮助我们在不同级别上过滤接口：</li>
</ol>
<ul>
<li><p>apis()：这种方式我们可以通过指定包名的方式，让 Swagger 只去某些包下面扫描。</p>
</li>
<li><p>paths()：这种方式可以通过筛选 API 的 url 来进行过滤。</p>
</li>
</ul>
<p>在集成 Swagger2 的章节中我们这两个方法指定的都是扫描所有，没有指定任何过滤条件。如果我们在我们修改之前定义的 Docket 对象的 apis() 方法和 paths() 方法为下面的内容，那么接口文档将只会展示 /user/add 和 /user/find/{id} 两个接口。</p>
<p>清单 11. 使用 Docket 配置接口筛选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;cn.itweknow.sbswagger.controller&quot;))</span><br><span class="line">.paths(Predicates.or(PathSelectors.ant(&quot;&#x2F;user&#x2F;add&quot;),</span><br><span class="line">        PathSelectors.ant(&quot;&#x2F;user&#x2F;find&#x2F;*&quot;)))</span><br></pre></td></tr></table></figure>
<p>图 3. 经过筛选过后的 Swagger 文档界面</p>
<p><img src="https://s2.ax1x.com/2019/06/06/VdqcwT.png" alt="点击查看大图"></p>
<h2 id="自定义响应消息"><a href="#自定义响应消息" class="headerlink" title="自定义响应消息"></a>自定义响应消息</h2><p>Swagger 允许我们通过 Docket 的 globalResponseMessage() 方法全局覆盖 HTTP 方法的响应消息，但是首先我们得通过 Docket 的 useDefaultResponseMessages 方法告诉 Swagger 不使用默认的 HTTP 响应消息，假设我们现在需要覆盖所有 GET 方法的 500 和 403 错误的响应消息，我们只需要在 SwaggerConfig.java 类中的 Docket Bean 下添加如下内容：</p>
<p>清单 12. 自定义响应消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.useDefaultResponseMessages(false)</span><br><span class="line">.globalResponseMessage(RequestMethod.GET, newArrayList(</span><br><span class="line">new ResponseMessageBuilder()</span><br><span class="line">              .code(500)</span><br><span class="line">              .message(&quot;服务器发生异常&quot;)</span><br><span class="line">              .responseModel(new ModelRef(&quot;Error&quot;))</span><br><span class="line">              .build(),</span><br><span class="line">       new ResponseMessageBuilder()</span><br><span class="line">              .code(403)</span><br><span class="line">              .message(&quot;资源不可用&quot;)</span><br><span class="line">              .build()</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>添加如上面的代码后，如下图所示，您会发现在 SwaggerUI 页面展示的所有 GET 类型请求的 403 以及 500 错误的响应消息都变成了我们自定义的内容。</p>
<p>图 4. 自定义响应消息</p>
<p><img src="https://s2.ax1x.com/2019/06/06/Vdq6mV.png" alt="点击查看大图"></p>
<h1 id="Swagger-UI-的使用"><a href="#Swagger-UI-的使用" class="headerlink" title="Swagger UI 的使用"></a>Swagger UI 的使用</h1><h2 id="接口查看"><a href="#接口查看" class="headerlink" title="接口查看"></a>接口查看</h2><p>SwaggerUI 会以列表的方式展示所有扫描到的接口，初始状态是收缩的，我们只需要点击展开就好，而且会在左边标识接口的请求方式（GET、POST、PUT、DELETE 等等）。</p>
<p>图 5. Swagger 接口列表界面</p>
<p><img src="https://s2.ax1x.com/2019/06/06/VdqsO0.png" alt="点击查看大图"></p>
<h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>如下图所示，点击接口展开后页面右上角的 Try it out 按钮后，页面会变成如图所示：</p>
<p>图 6. 接口详情界面</p>
<p><img src="https://s2.ax1x.com/2019/06/06/Vdqryq.png" alt="点击查看大图"></p>
<p>SwaggerUI 会给我们自动填充请求参数的数据结构，我们需要做的只是点击 Execute 即可发起调用</p>
<p>图 7. 接口调用界面</p>
<p><img src="https://s2.ax1x.com/2019/06/06/VdqgTU.png" alt="点击查看大图"></p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>如下图所示，SwaggerUI 会通过我们在实体上使用的 @ApiModel 注解以及@ApiModelProperty 注解来自动补充实体以及其属性的描述和备注。</p>
<p>图 8. 实体界面</p>
<p><img src="https://s2.ax1x.com/2019/06/06/VdqWY4.png" alt="点击查看大图"></p>
<h1 id="相关注解说明"><a href="#相关注解说明" class="headerlink" title="相关注解说明"></a>相关注解说明</h1><p>在本章节中我将给出一些 Swagger 中常用的注解以及其常用的属性，并对其一一解释，方便您查看。</p>
<h2 id="Controller-相关注解"><a href="#Controller-相关注解" class="headerlink" title="Controller 相关注解"></a>Controller 相关注解</h2><p>@Api: 可设置对控制器的描述。</p>
<p>表 1. @Api 主要属性<br>|注解属性    |类型    |描述|<br>| ——|——–|——–|<br>|tags    |String[]    |控制器标签。|<br>|description    |String    |控制器描述（该字段被申明为过期）。|</p>
<h2 id="接口相关注解"><a href="#接口相关注解" class="headerlink" title="接口相关注解"></a>接口相关注解</h2><ol>
<li>@ApiOperation: 可设置对接口的描述。</li>
</ol>
<p>表 2. @ApiOperation 主要属性<br>|注解属性    |类型    |描述|<br>| ——|——–|——–|<br>|value|    String|    接口说明。|<br>|notes    |String    |接口发布说明。|<br>|tags    |Stirng[]|    标签。|<br>|response    |Class&lt;?&gt;|    接口返回类型。|<br>|httpMethod|    String|    接口请求方式。|<br>2. @ApiIgnore: Swagger 文档不会显示拥有该注解的接口。</p>
<ol start="3">
<li><p>@ApiImplicitParams: 用于描述接口的非对象参数集。</p>
</li>
<li><p>@ApiImplicitParam: 用于描述接口的非对象参数，一般与 @ApiImplicitParams 组合使用。</p>
</li>
</ol>
<p>表 3. @ApiImplicitParam 主要属性<br>| 注解属性        | 描述                                                                                                                               |<br>|————-|———————————————————————————————————————————-|<br>|  paramType  |  查询参数类型，实际上就是参数放在那里。取值：path：以地址的形式提交数据，根据 id 查询用户的接口就是这种形式传参。query：Query string 的方式传参。header：以流的形式提交。form：以 Form 表单的形式提交。 |<br>|  dataType   |  参数的数据类型。取值：Long、String|<br>|  name       |  参数名字。                                                                                                                           |<br>|  value      |  参数意义的描述。                                                                                                                        |<br>|  required   |  是否必填。取值：true：必填参数。false：非必填参数。|</p>
<h2 id="Model-相关注解"><a href="#Model-相关注解" class="headerlink" title="Model 相关注解"></a>Model 相关注解</h2><ol>
<li>@ApiModel: 可设置接口相关实体的描述。</li>
<li>@ApiModelProperty: 可设置实体属性的相关描述。</li>
</ol>
<p>表 4. @ApiModelProperty 主要属性<br>|注解属性|    类型|    描述|<br>|——-|——-|——|<br>|value    |String|    字段说明。|<br>|name    |String    |重写字段名称。|<br>|dataType|    Stirng|    重写字段类型。|<br>|required    |boolean|    是否必填。|<br>|example    |Stirng|    举例说明。|<br>|hidden    |boolean    |是否在文档中隐藏该字段。|<br>|allowEmptyValue|    boolean    |是否允许为空。|<br>|allowableValues|    String    |该字段允许的值，当我们 API 的某个参数为枚举类型时，使用这个属性就可以清楚地告诉 API 使用者该参数所能允许传入的值。|</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>在本教程中，我们学会了如何使用 Swagger 2 来生成 Spring Boot REST API 的文档。我们还研究了如何过滤 API、自定义 HTTP 响应消息以及如何使用 SwaggerUI 直接调用我们的 API。您可以在 Github 上找到本教程的完整实现，这是一个基于 IntelliJ IDEA 的项目，因此它应该很容易导入和运行，当然如果您想对本教程做补充的话欢迎发邮件给我 (<a class="link"   href="mailto:&#109;&#121;&#110;&#97;&#x6d;&#x65;&#x63;&#111;&#100;&#x65;&#x72;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;" >&#109;&#121;&#110;&#97;&#x6d;&#x65;&#x63;&#111;&#100;&#x65;&#x72;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;<i class="fas fa-external-link-alt"></i></a>) 或者直接在 GitHub 上提交 Pull Request。</p>
<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a class="link"   href="https://spring.io/guides" >Spring 指南<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://spring.io/" >Spring 主页<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" >Spring Boot 参考指南<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" >Swagger 主页<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/WhenCoding/spring-tutorial/tree/master/sb-swagger" >本文源码地址<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="欢迎关注微信公众号，获取更多资源"><a href="#欢迎关注微信公众号，获取更多资源" class="headerlink" title="欢迎关注微信公众号，获取更多资源"></a>欢迎关注微信公众号，获取更多资源</h3><p><img src="https://i.ibb.co/rMxVLpD/qrcode-for-gh-912975c21d10-344.jpg" alt="程序员小明"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8</title>
    <url>/p/2f61.html</url>
    <content><![CDATA[<blockquote>
<p>参考自 1. <a class="link"   href="https://www.jianshu.com/p/5b800057f2d8"  title="java8新特性-终极版">杜琪<i class="fas fa-external-link-alt"></i></a>，2. github地址：<a class="link"   href="https://github.com/winterbe/java8-tutorial"  title="Java 8 新特性最佳指南">SnailClimb<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习这些新特性，并用实际的例子说明在什么场景下适合使用。</p>
<p>这个教程包含Java开发者经常面对的几类问题：</p>
<a id="more"></a>

<ul>
<li>语言</li>
<li>编译器</li>
<li>库</li>
<li>工具</li>
<li>运行时（JVM）</li>
</ul>
<h1 id="Java语言的新特性"><a href="#Java语言的新特性" class="headerlink" title="Java语言的新特性"></a>Java语言的新特性</h1><p>Java 8是Java的一个重大版本，有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。在这一小节中，我们将介绍Java 8的大部分新特性。</p>
<h2 id="Lambda表达式和函数式接口"><a href="#Lambda表达式和函数式接口" class="headerlink" title="Lambda表达式和函数式接口"></a>Lambda表达式和函数式接口</h2><p>Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。</p>
<p>Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure>
<p>在上面这个代码中的参数e的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure>
<p>如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print( e );</span><br><span class="line">    System.out.print( e );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String separator &#x3D; &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final String separator &#x3D; &quot;,&quot;;</span><br><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure>
<p>Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    int result &#x3D; e1.compareTo( e2 );</span><br><span class="line">    return result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Functional &#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalDefaultMethods &#123;</span><br><span class="line">    void method();</span><br><span class="line">        </span><br><span class="line">    default void defaultMethod() &#123;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式作为Java 8的最大卖点，它有潜力吸引更多的开发者加入到JVM平台，并在纯Java编程中使用函数式编程的概念。如果你需要了解更多Lambda表达式的细节，可以参考官方文档。</p>
<h2 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h2><p>Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p>
<p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Defaulable &#123;</span><br><span class="line">    &#x2F;&#x2F; Interfaces now allow default methods, the implementer may or </span><br><span class="line">    &#x2F;&#x2F; may not implement (override) them.</span><br><span class="line">    default String notRequired() &#123; </span><br><span class="line">        return &quot;Default implementation&quot;; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">public  class DefaultableImpl implements Defaulable &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public  class OverridableImpl implements Defaulable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String notRequired() &#123;</span><br><span class="line">        return &quot;Overridden implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p>
<p>Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface DefaulableFactory &#123;</span><br><span class="line">    &#x2F;&#x2F; Interfaces now allow static methods</span><br><span class="line">    static String notRequiredTwo()&#123;</span><br><span class="line">        return &quot;default implementation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码片段整合了默认方法和静态方法的使用场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main( String[] args ) &#123;</span><br><span class="line">    Defaulable defaulable &#x3D; DefaulableFactory.create( DefaultableImpl::new );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line">        </span><br><span class="line">    defaulable &#x3D; DefaulableFactory.create( OverridableImpl::new );</span><br><span class="line">    System.out.println( defaulable.notRequired() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Default implementation</span><br><span class="line">Overridden implementation</span><br></pre></td></tr></table></figure>
<p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</p>
<p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p>
<p>下面的例子中，Car类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public  class Car &#123;</span><br><span class="line">    public static Car create( final Supplier&lt; Car &gt; supplier ) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;              </span><br><span class="line">        </span><br><span class="line">    public static void collide( final Car car ) &#123;</span><br><span class="line">        System.out.println( &quot;Collided &quot; + car.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    public void repair() &#123;   </span><br><span class="line">        System.out.println( &quot;Repaired &quot; + this.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    public void follow( final Car another ) &#123;</span><br><span class="line">        System.out.println( &quot;Following the &quot; + another.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种方法引用的类型是构造器引用，语法是<code>Class::new</code>，或者更一般的形式：<code>Class&lt;T&gt;::new</code>。注意：这个构造器没有参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Car car &#x3D; Car.create( Car::new );</span><br><span class="line">final List&lt; Car &gt; cars &#x3D; Arrays.asList( car );</span><br></pre></td></tr></table></figure>
<p>第二种方法引用的类型是静态方法引用，语法是<code>Class::static_method</code>。注意：这个方法接受一个Car类型的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure>
<p>第三种方法引用的类型是某个类的成员方法的引用，语法是<code>Class::method</code>，注意，这个方法没有定义入参：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure>
<p>第四种方法引用的类型是某个实例对象的成员方法的引用，语法是<code>instance::method</code>。注意：这个方法接受一个Car类型的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Car police &#x3D; Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>
<p>运行上述例子，可以在控制台看到如下输出（Car实例可能不同）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</span><br><span class="line">Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</span><br><span class="line">Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</span><br></pre></td></tr></table></figure>
<p>如果想了解和学习更详细的内容，可以参考官方文档</p>
<h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>自从Java 5中引入注解以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p>
<p>在Java 8中使用<code>@Repeatable</code>注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个trick，底层的技术仍然相同。可以利用下面的代码说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.repeatable.annotations;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Repeatable;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">public class RepeatingAnnotations &#123;</span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    public @interface Filters &#123;</span><br><span class="line">        Filter[] value();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    @Repeatable( Filters.class )</span><br><span class="line">    public @interface Filter &#123;</span><br><span class="line">        String value();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    @Filter( &quot;filter1&quot; )</span><br><span class="line">    @Filter( &quot;filter2&quot; )</span><br><span class="line">    public interface Filterable &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123;</span><br><span class="line">            System.out.println( filter.value() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所见，这里的Filter类使用<code>@Repeatable(Filters.class)</code>注解修饰，而Filters是存放Filter注解的容器，编译器尽量对开发者屏蔽这些细节。这样，Filterable接口可以用两个Filter注解注释（这里并没有提到任何关于Filters的信息）。</p>
<p>另外，反射API提供了一个新的方法：<code>getAnnotationsByType()</code>，可以返回某个类型的重复注解，例如<code>Filterable.class.getAnnoation(Filters.class)</code>将返回两个Filter实例，输出到控制台的内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter1</span><br><span class="line">filter2</span><br></pre></td></tr></table></figure>
<p>如果你希望了解更多内容，可以参考官方文档。</p>
<h2 id="更好的类型推断"><a href="#更好的类型推断" class="headerlink" title="更好的类型推断"></a>更好的类型推断</h2><p>Java 8编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.type.inference;</span><br><span class="line"></span><br><span class="line">public class Value&lt; T &gt; &#123;</span><br><span class="line">    public static&lt; T &gt; T defaultValue() &#123; </span><br><span class="line">        return null; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public T getOrDefault( T value, T defaultValue ) &#123;</span><br><span class="line">        return ( value !&#x3D; null ) ? value : defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列代码是<code>Value&lt;String&gt;</code>类型的应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.type.inference;</span><br><span class="line"></span><br><span class="line">public class TypeInference &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Value&lt; String &gt; value &#x3D; new Value&lt;&gt;();</span><br><span class="line">        value.getOrDefault( &quot;22&quot;, Value.defaultValue() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数<code>Value.defaultValue()</code>的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用<code>Value.&lt;String&gt;defaultValue()</code>。</p>
<h2 id="拓宽注解的应用场景"><a href="#拓宽注解的应用场景" class="headerlink" title="拓宽注解的应用场景"></a>拓宽注解的应用场景</h2><p>Java 8拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.annotations;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line"></span><br><span class="line">public class Annotations &#123;</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    @Target( &#123; ElementType.TYPE_USE, ElementType.TYPE_PARAMETER &#125; )</span><br><span class="line">    public @interface NonEmpty &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    public static class Holder&lt; @NonEmpty T &gt; extends @NonEmpty Object &#123;</span><br><span class="line">        public void method() throws @NonEmpty Exception &#123;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    @SuppressWarnings( &quot;unused&quot; )</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Holder&lt; String &gt; holder &#x3D; new @NonEmpty Holder&lt; String &gt;();       </span><br><span class="line">        @NonEmpty Collection&lt; @NonEmpty String &gt; strings &#x3D; new ArrayList&lt;&gt;();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ElementType.TYPE_USER和ElementType.TYPE_PARAMETER</code>是Java 8新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。</p>
<h1 id="Java编译器的新特性"><a href="#Java编译器的新特性" class="headerlink" title="Java编译器的新特性"></a>Java编译器的新特性</h1><h2 id="参数名称"><a href="#参数名称" class="headerlink" title="参数名称"></a>参数名称</h2><p>为了在运行时获得Java程序中方法的参数名称，老一辈的Java程序员必须使用不同方法，例如<code>Paranamer liberary</code>。Java 8终于将这个特性规范化，在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.parameter.names;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line">public class ParameterNames &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Method method &#x3D; ParameterNames.class.getMethod( &quot;main&quot;, String[].class );</span><br><span class="line">        for( final Parameter parameter: method.getParameters() ) &#123;</span><br><span class="line">            System.out.println( &quot;Parameter: &quot; + parameter.getName() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java 8中这个特性是默认关闭的，因此如果不带<code>parameters</code>参数编译上述代码并运行，则会输出如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parameter: arg0</span><br></pre></td></tr></table></figure>
<p>如果带<code>parameters</code>参数，则会输出如下结果（正确的结果）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parameter: args</span><br></pre></td></tr></table></figure>
<p>如果你使用Maven进行项目管理，则可以在<code>maven-compiler-plugin</code>编译器的配置项中配置<code>parameters</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;compilerArgument&gt;-parameters&lt;&#x2F;compilerArgument&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">    &lt;&#x2F;configuration&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Java官方库的新特性"><a href="#Java官方库的新特性" class="headerlink" title="Java官方库的新特性"></a>Java官方库的新特性</h1><p>Java 8增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。</p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了<code>Optionals</code>类来解决<code>NullPointerException</code>，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将<code>Optional</code>加入了官方库。</p>
<p><code>Optional</code>仅仅是一个容器：存放T类型的值或者<code>null</code>。它提供了一些有用的接口来避免显式的<code>null</code>检查，可以参考Java 8官方文档了解更多细节。</p>
<p>接下来看一点使用<code>Optional</code>的例子：可能为空的值或者某个类型的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt; String &gt; fullName &#x3D; Optional.ofNullable( null );</span><br><span class="line">System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );        </span><br><span class="line">System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) ); </span><br><span class="line">System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</span><br></pre></td></tr></table></figure>
<p>如果Optional实例持有一个非空值，则<code>isPresent()</code>方法返回<code>true</code>，否则返回<code>false</code>；<code>orElseGet()</code>方法，<code>Optional</code>实例持有<code>null</code>，则可以接受一个lambda表达式生成的默认值；<code>map()</code>方法可以将现有的<code>Opetional</code>实例的值转换成新的值；<code>orElse()</code>方法与<code>orElseGet()</code>方法类似，但是在持有<code>null</code>的时候返回传入的默认值。</p>
<p>上述代码的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Full Name is set? false</span><br><span class="line">Full Name: [none]</span><br><span class="line">Hey Stranger!</span><br></pre></td></tr></table></figure>
<p>再看下另一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt; String &gt; firstName &#x3D; Optional.of( &quot;Tom&quot; );</span><br><span class="line">System.out.println( &quot;First Name is set? &quot; + firstName.isPresent() );        </span><br><span class="line">System.out.println( &quot;First Name: &quot; + firstName.orElseGet( () -&gt; &quot;[none]&quot; ) ); </span><br><span class="line">System.out.println( firstName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
<p>这个例子的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">First Name is set? true</span><br><span class="line">First Name: Tom</span><br><span class="line">Hey Tom!</span><br></pre></td></tr></table></figure>
<p>如果想了解更多的细节，请参考官方文档。</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>新增的<code>Stream API（java.util.stream）</code>将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p>
<p>Stream API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Streams  &#123;</span><br><span class="line">    private enum Status &#123;</span><br><span class="line">        OPEN, CLOSED</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    private static final class Task &#123;</span><br><span class="line">        private final Status status;</span><br><span class="line">        private final Integer points;</span><br><span class="line"></span><br><span class="line">        Task( final Status status, final Integer points ) &#123;</span><br><span class="line">            this.status &#x3D; status;</span><br><span class="line">            this.points &#x3D; points;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Integer getPoints() &#123;</span><br><span class="line">            return points;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Status getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return String.format( &quot;[%s, %d]&quot;, status, points );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Task类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Collection&lt; Task &gt; tasks &#x3D; Arrays.asList(</span><br><span class="line">    new Task( Status.OPEN, 5 ),</span><br><span class="line">    new Task( Status.OPEN, 13 ),</span><br><span class="line">    new Task( Status.CLOSED, 8 ) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>首先看一个问题：在这个task集合中一共有多少个OPEN状态的点？在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Calculate total points of all active tasks using sum()</span><br><span class="line">final long totalPointsOfOpenTasks &#x3D; tasks</span><br><span class="line">    .stream()</span><br><span class="line">    .filter( task -&gt; task.getStatus() &#x3D;&#x3D; Status.OPEN )</span><br><span class="line">    .mapToInt( Task::getPoints )</span><br><span class="line">    .sum();</span><br><span class="line">        </span><br><span class="line">System.out.println( &quot;Total points: &quot; + totalPointsOfOpenTasks );</span><br></pre></td></tr></table></figure>
<p>运行这个方法的控制台输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total points: 18</span><br></pre></td></tr></table></figure>
<p>这里有很多知识点值得说。首先，tasks集合被转换成steam表示；其次，在steam上的filter操作会过滤掉所有CLOSED的task；第三，mapToInt操作基于每个task实例的Task::getPoints方法将task流转换成Integer集合；最后，通过sum方法计算总和，得出最后的结果。</p>
<p>在学习下一个例子之前，还需要记住一些steams（点此更多细节）的知识点。Steam之上的操作可分为中间操作和晚期操作。</p>
<p>中间操作会返回一个新的steam——执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。</p>
<p>晚期操作（例如forEach或者sum），会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对steam进行遍历。</p>
<p>steam的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有任务的点数之和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Calculate total points of all tasks</span><br><span class="line">final double totalPoints &#x3D; tasks</span><br><span class="line">   .stream()</span><br><span class="line">   .parallel()</span><br><span class="line">   .map( task -&gt; task.getPoints() ) &#x2F;&#x2F; or map( Task::getPoints ) </span><br><span class="line">   .reduce( 0, Integer::sum );</span><br><span class="line">    </span><br><span class="line">System.out.println( &quot;Total points (all tasks): &quot; + totalPoints );</span><br></pre></td></tr></table></figure>
<p>这里我们使用parallel方法并行处理所有的task，并使用reduce方法计算最终的结果。控制台输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total points（all tasks）: 26.0</span><br></pre></td></tr></table></figure>
<p>对于一个集合，经常需要根据某些条件对其中的元素分组。利用steam提供的API可以很快完成这类任务，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Group tasks by their status</span><br><span class="line">final Map&lt; Status, List&lt; Task &gt; &gt; map &#x3D; tasks</span><br><span class="line">    .stream()</span><br><span class="line">    .collect( Collectors.groupingBy( Task::getStatus ) );</span><br><span class="line">System.out.println( map );</span><br></pre></td></tr></table></figure>
<p>控制台的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;CLOSED&#x3D;[[CLOSED, 8]], OPEN&#x3D;[[OPEN, 5], [OPEN, 13]]&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Calculate the weight of each tasks (as percent of total points) </span><br><span class="line">final Collection&lt; String &gt; result &#x3D; tasks</span><br><span class="line">    .stream()                                        &#x2F;&#x2F; Stream&lt; String &gt;</span><br><span class="line">    .mapToInt( Task::getPoints )                     &#x2F;&#x2F; IntStream</span><br><span class="line">    .asLongStream()                                  &#x2F;&#x2F; LongStream</span><br><span class="line">    .mapToDouble( points -&gt; points &#x2F; totalPoints )   &#x2F;&#x2F; DoubleStream</span><br><span class="line">    .boxed()                                         &#x2F;&#x2F; Stream&lt; Double &gt;</span><br><span class="line">    .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) &#x2F;&#x2F; LongStream</span><br><span class="line">    .mapToObj( percentage -&gt; percentage + &quot;%&quot; )      &#x2F;&#x2F; Stream&lt; String&gt; </span><br><span class="line">    .collect( Collectors.toList() );                 &#x2F;&#x2F; List&lt; String &gt; </span><br><span class="line">        </span><br><span class="line">System.out.println( result );</span><br></pre></td></tr></table></figure>
<p>控制台输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[19%, 50%, 30%]</span><br></pre></td></tr></table></figure>
<p>最后，正如之前所说，Steam API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行得读取数据）可以受益于steam处理，这里有一个小例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Path path &#x3D; new File( filename ).toPath();</span><br><span class="line">try( Stream&lt; String &gt; lines &#x3D; Files.lines( path, StandardCharsets.UTF_8 ) ) &#123;</span><br><span class="line">    lines.onClose( () -&gt; System.out.println(&quot;Done!&quot;) ).forEach( System.out::println );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stream的方法<code>onClose</code> 返回一个等价的有额外句柄的Stream，当<code>Stream的close（）</code>方法被调用的时候这个句柄会被执行。Stream API、Lambda表达式还有接口默认方法和静态方法支持的方法引用，是Java 8对软件开发的现代范式的响应。</p>
<h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date/Time API(JSR 310)"></a>Date/Time API(JSR 310)</h2><p>Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。<code>java.util.Date</code>和后来的<code>java.util.Calendar</code>一直没有解决这个问题（甚至令开发者更加迷茫）。</p>
<p>因为上面这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从<code>java.util.Calendar</code>吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p>
<p>我们接下来看看java.time包中的关键类和各自的使用例子。首先，Clock类使用时区来返回当前的纳秒时间和日期。Clock可以替代<code>System.currentTimeMillis()</code>和<code>TimeZone.getDefault()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Get the system clock as UTC offset </span><br><span class="line">final Clock clock &#x3D; Clock.systemUTC();</span><br><span class="line">System.out.println( clock.instant() );</span><br><span class="line">System.out.println( clock.millis() );</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-04-12T15:19:29.282Z</span><br><span class="line">1397315969360</span><br></pre></td></tr></table></figure>
<p>第二，关注下<code>LocalDate</code>和<code>LocalTime</code>类。LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Get the local date and local time</span><br><span class="line">final LocalDate date &#x3D; LocalDate.now();</span><br><span class="line">final LocalDate dateFromClock &#x3D; LocalDate.now( clock );</span><br><span class="line">        </span><br><span class="line">System.out.println( date );</span><br><span class="line">System.out.println( dateFromClock );</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F; Get the local date and local time</span><br><span class="line">final LocalTime time &#x3D; LocalTime.now();</span><br><span class="line">final LocalTime timeFromClock &#x3D; LocalTime.now( clock );</span><br><span class="line">        </span><br><span class="line">System.out.println( time );</span><br><span class="line">System.out.println( timeFromClock );</span><br></pre></td></tr></table></figure>
<p>上述例子的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-04-12</span><br><span class="line">2014-04-12</span><br><span class="line">11:25:54.568</span><br><span class="line">15:25:54.568</span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>类包含了<code>LocalDate</code>和<code>LocalTime</code>的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些关于<code>LocalDate</code>和<code>LocalTime</code>的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Get the local date&#x2F;time</span><br><span class="line">final LocalDateTime datetime &#x3D; LocalDateTime.now();</span><br><span class="line">final LocalDateTime datetimeFromClock &#x3D; LocalDateTime.now( clock );</span><br><span class="line">        </span><br><span class="line">System.out.println( datetime );</span><br><span class="line">System.out.println( datetimeFromClock );</span><br></pre></td></tr></table></figure>
<p>上述这个例子的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-04-12T11:37:52.309</span><br><span class="line">2014-04-12T15:37:52.309</span><br></pre></td></tr></table></figure>
<p>如果你需要特定时区的data/time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Get the zoned date&#x2F;time</span><br><span class="line">final ZonedDateTime zonedDatetime &#x3D; ZonedDateTime.now();</span><br><span class="line">final ZonedDateTime zonedDatetimeFromClock &#x3D; ZonedDateTime.now( clock );</span><br><span class="line">final ZonedDateTime zonedDatetimeFromZone &#x3D; ZonedDateTime.now( ZoneId.of( &quot;America&#x2F;Los_Angeles&quot; ) );</span><br><span class="line">        </span><br><span class="line">System.out.println( zonedDatetime );</span><br><span class="line">System.out.println( zonedDatetimeFromClock );</span><br><span class="line">System.out.println( zonedDatetimeFromZone );</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2014-04-12T11:47:01.017-04:00[America&#x2F;New_York]</span><br><span class="line">2014-04-12T15:47:01.017Z</span><br><span class="line">2014-04-12T08:47:01.017-07:00[America&#x2F;Los_Angeles]</span><br></pre></td></tr></table></figure>
<p>最后看下Duration类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Get duration between two dates</span><br><span class="line">final LocalDateTime from &#x3D; LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );</span><br><span class="line">final LocalDateTime to &#x3D; LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );</span><br><span class="line"></span><br><span class="line">final Duration duration &#x3D; Duration.between( from, to );</span><br><span class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</span><br><span class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</span><br></pre></td></tr></table></figure>
<p>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Duration in days: 365</span><br><span class="line">Duration in hours: 8783</span><br></pre></td></tr></table></figure>
<p>对于Java 8的新日期时间的总体印象还是比较积极的，一部分是因为Joda-Time的积极影响，另一部分是因为官方终于听取了开发人员的需求。如果希望了解更多细节，可以参考官方文档。</p>
<h3 id="LocalDateTime常用举例"><a href="#LocalDateTime常用举例" class="headerlink" title="LocalDateTime常用举例"></a>LocalDateTime常用举例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDatetime &#x3D; LocalDateTime.of(LocalDate.now(), LocalTime.of(11, 0);&#x2F;&#x2F; 获取当天某一时刻</span><br><span class="line">LocalDateTime today_start &#x3D; LocalDateTime.of(LocalDate.now(), LocalTime.MIN);&#x2F;&#x2F;当天零点</span><br></pre></td></tr></table></figure>
<h3 id="日期类型之间的转换"><a href="#日期类型之间的转换" class="headerlink" title="日期类型之间的转换"></a>日期类型之间的转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Instant instant &#x3D; LocalDateTime.of(LocalDate.now(), LocalTime.of(11, 0)).atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date &#x3D;  Date.from(instant);&#x2F;&#x2F;传入instant即可</span><br></pre></td></tr></table></figure>
<h2 id="Nashorn-JavaScript引擎"><a href="#Nashorn-JavaScript引擎" class="headerlink" title="Nashorn JavaScript引擎"></a>Nashorn JavaScript引擎</h2><p>Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是<code>javax.script.ScriptEngine</code>的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ScriptEngineManager manager &#x3D; new ScriptEngineManager();</span><br><span class="line">ScriptEngine engine &#x3D; manager.getEngineByName( &quot;JavaScript&quot; );</span><br><span class="line">        </span><br><span class="line">System.out.println( engine.getClass().getName() );</span><br><span class="line">System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() &#123; return 1; &#125;; f() + 1;&quot; ) );</span><br></pre></td></tr></table></figure>
<p>这个代码的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk.nashorn.api.scripting.NashornScriptEngine</span><br><span class="line">Result: 2</span><br></pre></td></tr></table></figure>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>对Base64编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码，例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.base64;</span><br><span class="line"></span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Base64s &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final String text &#x3D; &quot;Base64 finally in Java 8!&quot;;</span><br><span class="line">        </span><br><span class="line">        final String encoded &#x3D; Base64</span><br><span class="line">            .getEncoder()</span><br><span class="line">            .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );</span><br><span class="line">        System.out.println( encoded );</span><br><span class="line">        </span><br><span class="line">        final String decoded &#x3D; new String( </span><br><span class="line">            Base64.getDecoder().decode( encoded ),</span><br><span class="line">            StandardCharsets.UTF_8 );</span><br><span class="line">        System.out.println( decoded );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ&#x3D;&#x3D;</span><br><span class="line">Base64 finally in Java 8!</span><br></pre></td></tr></table></figure>
<p>新的Base64API也支持URL和MINE的编码解码。<br><code>(Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder())</code>。</p>
<p>4.6 并行数组<br>Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是<code>parallelSort()</code>，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.javacodegeeks.java8.parallel.arrays;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">public class ParallelArrays &#123;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">        long[] arrayOfLong &#x3D; new long [ 20000 ];        </span><br><span class="line">        </span><br><span class="line">        Arrays.parallelSetAll( arrayOfLong, </span><br><span class="line">            index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );</span><br><span class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach( </span><br><span class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        Arrays.parallelSort( arrayOfLong );     </span><br><span class="line">        Arrays.stream( arrayOfLong ).limit( 10 ).forEach( </span><br><span class="line">            i -&gt; System.out.print( i + &quot; &quot; ) );</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述这些代码使用<code>parallelSetAll()</code>方法生成20000个随机数，然后使用<code>parallelSort()</code>方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 </span><br><span class="line">Sorted: 39 220 263 268 325 607 655 678 723 793</span><br></pre></td></tr></table></figure>
<h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>基于新增的lambda表达式和steam特性，为Java 8中为<code>java.util.concurrent.ConcurrentHashMap</code>类添加了新的方法来支持聚焦操作；另外，也为<code>java.util.concurrentForkJoinPool</code>类添加了新的方法来支持通用线程池操作（更多内容可以参考我们的并发编程课程）。</p>
<p>Java 8还添加了新的<code>java.util.concurrent.locks.StampedLock</code>类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是<code>java.util.concurrent.locks.ReadWriteLock</code>的替代者）。</p>
<p>在<code>java.util.concurrent.atomic</code>包中也新增了不少工具类，列举如下：</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h1 id="新的Java工具"><a href="#新的Java工具" class="headerlink" title="新的Java工具"></a>新的Java工具</h1><p>Java 8提供了一些新的命令行工具，这部分会讲解一些对开发者最有用的工具。</p>
<h2 id="Nashorn引擎：jjs"><a href="#Nashorn引擎：jjs" class="headerlink" title="Nashorn引擎：jjs"></a>Nashorn引擎：jjs</h2><p>jjs是一个基于标准Nashorn引擎的命令行工具，可以接受js源码并执行。例如，我们写一个func.js文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f() &#123; </span><br><span class="line">     return 1; </span><br><span class="line">&#125;; </span><br><span class="line">print( f() + 1 );</span><br></pre></td></tr></table></figure>
<p>可以在命令行中执行这个命令：<code>jjs func.js</code>，控制台输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>如果需要了解细节，可以参考官方文档。</p>
<h2 id="类依赖分析器：jdeps"><a href="#类依赖分析器：jdeps" class="headerlink" title="类依赖分析器：jdeps"></a>类依赖分析器：jdeps</h2><p>jdeps是一个相当棒的命令行工具，它可以展示包层级和类层级的Java类依赖关系，它以.class文件、目录或者Jar文件为输入，然后会把依赖关系输出到控制台。</p>
<p>我们可以利用jedps分析下Spring Framework库，为了让结果少一点，仅仅分析一个JAR文件：<code>org.springframework.core-3.0.5.RELEASE.jar</code>。</p>
<p><code>jdeps org.springframework.core-3.0.5.RELEASE.jar</code><br>这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在classpath上找不到依赖，则显示”not found”.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.core-3.0.5.RELEASE.jar -&gt; C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar</span><br><span class="line">   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)</span><br><span class="line">      -&gt; java.io                                            </span><br><span class="line">      -&gt; java.lang                                          </span><br><span class="line">      -&gt; java.lang.annotation                               </span><br><span class="line">      -&gt; java.lang.ref                                      </span><br><span class="line">      -&gt; java.lang.reflect                                  </span><br><span class="line">      -&gt; java.util                                          </span><br><span class="line">      -&gt; java.util.concurrent                               </span><br><span class="line">      -&gt; org.apache.commons.logging                         not found</span><br><span class="line">      -&gt; org.springframework.asm                            not found</span><br><span class="line">      -&gt; org.springframework.asm.commons                    not found</span><br><span class="line">   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)</span><br><span class="line">      -&gt; java.lang                                          </span><br><span class="line">      -&gt; java.lang.annotation                               </span><br><span class="line">      -&gt; java.lang.reflect                                  </span><br><span class="line">      -&gt; java.util</span><br></pre></td></tr></table></figure>
<p>更多的细节可以参考官方文档。</p>
<h1 id="JVM的新特性"><a href="#JVM的新特性" class="headerlink" title="JVM的新特性"></a>JVM的新特性</h1><p>使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>
<h1 id="常用举例"><a href="#常用举例" class="headerlink" title="常用举例"></a>常用举例</h1><h2 id="List对象多条件排序"><a href="#List对象多条件排序" class="headerlink" title="List对象多条件排序"></a>List对象多条件排序</h2><p>一个List 先按照名字的拼音排序，然后按照年龄排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Person&gt; persons &#x3D; getPersons();</span><br><span class="line">        </span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 方法一：方法引用方式</span><br><span class="line">&#x2F;&#x2F;        List&lt;Person&gt; result &#x3D; persons.stream().sorted(Comparator.comparing(Person::getNamePinyin).thenComparing(Person::getAge)).collect(Collectors.toList());</span><br><span class="line">        List&lt;Person&gt; result &#x3D; persons.stream()</span><br><span class="line">                .sorted(Comparator.comparing((Person p) -&gt; p.getNamePinyin())</span><br><span class="line">                        .thenComparing((Person p) -&gt; p.getAge()).collect(Collectors.toList());</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;duration time:&quot; + (end-start) + &quot;ms&quot;);</span><br><span class="line">        for(Person p: result) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static List&lt;Person&gt; getPersons() &#123;</span><br><span class="line">        List&lt;Person&gt; persons &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        persons.add(new Person(&quot;中国&quot;, 24));</span><br><span class="line">        persons.add(new Person(&quot;中国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;中国&quot;, 78));</span><br><span class="line">        persons.add(new Person(&quot;美国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;泰国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;韩国&quot;, 23));</span><br><span class="line">        persons.add(new Person(&quot;日本&quot;, 23));</span><br><span class="line">        return persons;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="flatMap-用法举例"><a href="#flatMap-用法举例" class="headerlink" title="flatMap 用法举例"></a>flatMap 用法举例</h2><h3 id="将两个List转换为一个Stream"><a href="#将两个List转换为一个Stream" class="headerlink" title="将两个List转换为一个Stream"></a>将两个List<T>转换为一个Stream<T></h3><p>e.g. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream.of(requestTaskVo.getEverydayTasks(),requestTaskVo.getNoviceTasks()).flatMap(Collection::stream).forEach(appTask -&gt; checkTaskState(userId,appTask));</span><br></pre></td></tr></table></figure>
<h3 id="将两层list转换为一个Stream"><a href="#将两层list转换为一个Stream" class="headerlink" title="将两层list转换为一个Stream"></a>将两层list转换为一个Stream</h3><p>e.g.<br>有一个List<A> aList，A 中有成员变量 List<B> bList，要将aList中的所有B提取出来<br>aList.stream().flatMap(a -&gt; a.getBList().stream())</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
